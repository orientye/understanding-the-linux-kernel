:toc:
:toclevels: 5
:hardbreaks-option:

== tcp

=== 协议

=== 创建

=== 接收

=== 发送

=== 终止
==== 过程
TCP连接是全双工的，存在半关闭状态，终止需要4步握手。

正常关闭:
示意图: TODO

同时关闭:
示意图: TODO

==== shutdown
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c
----
/*
 *	Shutdown the sending side of a connection. Much like close except
 *	that we don't receive shut down or sock_set_flag(sk, SOCK_DEAD).
 */

void tcp_shutdown(struct sock *sk, int how)
{
	/*	We need to grab some memory, and put together a FIN,
	 *	and then put it into the queue to be sent.
	 *		Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec '92.
	 */
	if (!(how & SEND_SHUTDOWN))
		return;

	/* If we've already sent a FIN, or it's a closed state, skip this. */
	if ((1 << sk->sk_state) &
	    (TCPF_ESTABLISHED | TCPF_SYN_SENT |
	     TCPF_SYN_RECV | TCPF_CLOSE_WAIT)) {
		/* Clear out any half completed packets.  FIN if needed. */
		if (tcp_close_state(sk))
			tcp_send_fin(sk);
	}
}
----
如果是发送方向，且TCP状态为ESTABLISHED/SYN_SENT/SYN_RECV/CLOSE_WAIT，调用tcp_close_state()设置状态，并在需要时调用tcp_send_fin()向对方发送FIN。

那么接收方向的关闭呢？
此时无需向对方发送FIN，因为可能还需要发向对方发送数据。
接收方向的关闭，是在recvmsg等调用中发现设置了RCV_SHUTDOWN会立即返回。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c
----
static int tcp_close_state(struct sock *sk)
{
	int next = (int)new_state[sk->sk_state];
	int ns = next & TCP_STATE_MASK;

	tcp_set_state(sk, ns);

	return next & TCP_ACTION_FIN;
}
----

tcp_send_fin(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_output.c

==== close

=== 定时器

=== 拥塞控制

=== multipath
==== 参考
https://www.mptcp.dev/
https://github.com/multipath-tcp/mptcp
https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/
