:toc:
:toclevels: 5
:hardbreaks-option:

== 相关系统调用

=== 声明
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
----
/* net/socket.c */
asmlinkage long sys_socket(int, int, int);
asmlinkage long sys_socketpair(int, int, int, int __user *);
asmlinkage long sys_bind(int, struct sockaddr __user *, int);
asmlinkage long sys_listen(int, int);
asmlinkage long sys_accept(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_connect(int, struct sockaddr __user *, int);
asmlinkage long sys_getsockname(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_getpeername(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_sendto(int, void __user *, size_t, unsigned,
				struct sockaddr __user *, int);
asmlinkage long sys_recvfrom(int, void __user *, size_t, unsigned,
				struct sockaddr __user *, int __user *);
asmlinkage long sys_setsockopt(int fd, int level, int optname,
				char __user *optval, int optlen);
asmlinkage long sys_getsockopt(int fd, int level, int optname,
				char __user *optval, int __user *optlen);
asmlinkage long sys_shutdown(int, int);
asmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
----

=== socket
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
        __sock_create()

=== bind
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
        int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)
            sock->ops->bind(...)

=== listen
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE2(listen, int, fd, int, backlog)
        __sys_listen(fd, backlog)
            sock->ops->listen(sock, backlog)

=== accept
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen, int, flags)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);
}

SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);
}
----

    __sys_accept4
        __sys_accept4_file
            do_accept
                sock->ops->accept

=== connect
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
int __sys_connect_file(struct file *file, struct sockaddr_storage *address,
		       int addrlen, int file_flags)
{
	struct socket *sock;
	int err;

	sock = sock_from_file(file);
	if (!sock) {
		err = -ENOTSOCK;
		goto out;
	}

	err =
	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
	if (err)
		goto out;

	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
				 sock->file->f_flags | file_flags);
out:
	return err;
}

int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)
{
	int ret = -EBADF;
	struct fd f;

	f = fdget(fd);
	if (f.file) {
		struct sockaddr_storage address;

		ret = move_addr_to_kernel(uservaddr, addrlen, &address);
		if (!ret)
			ret = __sys_connect_file(f.file, &address, addrlen, 0);
		fdput(f);
	}

	return ret;
}

SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
		int, addrlen)
{
	return __sys_connect(fd, uservaddr, addrlen);
}
----

=== sendto
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
		unsigned int, flags, struct sockaddr __user *, addr,
		int, addr_len)
{
	return __sys_sendto(fd, buff, len, flags, addr, addr_len);
}
----

=== send
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,
		unsigned int, flags)
{
	return __sys_sendto(fd, buff, len, flags, NULL, 0);
}
----

=== recvfrom
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
		unsigned int, flags, struct sockaddr __user *, addr,
		int __user *, addr_len)
{
	return __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);
}
----

=== recv
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,
		unsigned int, flags)
{
	return __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
}
----

=== sendmsg
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)
{
	return __sys_sendmsg(fd, msg, flags, true);
}
----

=== recvmsg
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,
		unsigned int, flags)
{
	return __sys_recvmsg(fd, msg, flags, true);
}
----

=== epoll
参考: link:../文件/相关系统调用.asc#epoll[epoll]

=== select
参考: link:../文件/相关系统调用.asc#select[select]

=== poll
参考: link:../文件/相关系统调用.asc#poll[poll]

对于tcp:
tcp_poll: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

对于udp:
udp_poll: https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c

=== shutdown
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE2(shutdown, int, fd, int, how)
        __sys_shutdown(fd, how)
            __sys_shutdown_sock(sock, how)
                sock->ops->shutdown(sock, how)

套接口层:
inet_shutdown: https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

对于tcp:
tcp_shutdown: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

=== close
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
static void __sock_release(struct socket *sock, struct inode *inode)
{
	if (sock->ops) {
		struct module *owner = sock->ops->owner;

		if (inode)
			inode_lock(inode);
		sock->ops->release(sock);
		sock->sk = NULL;
		if (inode)
			inode_unlock(inode);
		sock->ops = NULL;
		module_put(owner);
	}

	if (sock->wq.fasync_list)
		pr_err("%s: fasync list not empty!\n", __func__);

	if (!sock->file) {
		iput(SOCK_INODE(sock));
		return;
	}
	sock->file = NULL;
}
//...
static int sock_close(struct inode *inode, struct file *filp)
{
	__sock_release(SOCKET_I(inode), inode);
	return 0;
}
----

套接口层:
inet_release: https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

对于tcp:
tcp_close: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

对于udp:
udp_lib_close: https://elixir.bootlin.com/linux/latest/source/include/net/udp.h

=== setsockopt
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname, char __user *, optval, int, optlen)
        int __sys_setsockopt(int fd, int level, int optname, char __user *user_optval,int optlen)
            sock->ops->setsockopt

套接口层:
sock_common_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/core/sock.c

对于tcp:
tcp_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

对于udp:
udp_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c