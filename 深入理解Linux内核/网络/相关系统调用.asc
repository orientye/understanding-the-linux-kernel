:toc:
:toclevels: 5
:hardbreaks-option:

== 相关系统调用

=== 声明
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
----
/* net/socket.c */
asmlinkage long sys_socket(int, int, int);
asmlinkage long sys_socketpair(int, int, int, int __user *);
asmlinkage long sys_bind(int, struct sockaddr __user *, int);
asmlinkage long sys_listen(int, int);
asmlinkage long sys_accept(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_connect(int, struct sockaddr __user *, int);
asmlinkage long sys_getsockname(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_getpeername(int, struct sockaddr __user *, int __user *);
asmlinkage long sys_sendto(int, void __user *, size_t, unsigned,
				struct sockaddr __user *, int);
asmlinkage long sys_recvfrom(int, void __user *, size_t, unsigned,
				struct sockaddr __user *, int __user *);
asmlinkage long sys_setsockopt(int fd, int level, int optname,
				char __user *optval, int optlen);
asmlinkage long sys_getsockopt(int fd, int level, int optname,
				char __user *optval, int __user *optlen);
asmlinkage long sys_shutdown(int, int);
asmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
----

=== socket
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
        int __sock_create(struct net *net, int family, int type, int protocol,
            struct socket **res, int kern)
            pf->create(net, sock, protocol, kern);

int family: protocol family 例如AF_INET
https://elixir.bootlin.com/linux/latest/source/include/linux/socket.h

int type: communication type即enum sock_type, 例如SOCK_STREAM
https://elixir.bootlin.com/linux/latest/source/include/linux/net.h

int protocol: 通常指定为0, 实际上IPPROTO_TCP等？

对于AF_INET，pf->create(net, sock, protocol, kern);实际上调用:
https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

    int inet_create(struct net *net, struct socket *sock, int protocol, int kern)

=== bind
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
        int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)
            sock->ops->bind(...)

inet_bind(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c
    
    /* If the socket has its own bind function then use it. (RAW) */
    if (sk->sk_prot->bind) {
        return sk->sk_prot->bind(sk, uaddr, addr_len);
    }
    //...
    __inet_bind
        sk->sk_prot->get_port

inet_csk_get_port(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/inet_connection_sock.c

=== listen
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE2(listen, int, fd, int, backlog)
        __sys_listen(fd, backlog)
            sock->ops->listen(sock, backlog)

inet_listen(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c
    inet_csk_listen_start(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/inet_connection_sock.c

=== accept
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen, int, flags)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);
}

SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);
}
----

    __sys_accept4
        __sys_accept4_file
            do_accept
                sock->ops->accept

inet_accept(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c
    inet_csk_accept(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/inet_connection_sock.c

=== connect
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
int __sys_connect_file(struct file *file, struct sockaddr_storage *address,
		       int addrlen, int file_flags)
{
	struct socket *sock;
	int err;

	sock = sock_from_file(file);
	if (!sock) {
		err = -ENOTSOCK;
		goto out;
	}

	err =
	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
	if (err)
		goto out;

	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
				 sock->file->f_flags | file_flags);
out:
	return err;
}

int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)
{
	int ret = -EBADF;
	struct fd f;

	f = fdget(fd);
	if (f.file) {
		struct sockaddr_storage address;

		ret = move_addr_to_kernel(uservaddr, addrlen, &address);
		if (!ret)
			ret = __sys_connect_file(f.file, &address, addrlen, 0);
		fdput(f);
	}

	return ret;
}

SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
		int, addrlen)
{
	return __sys_connect(fd, uservaddr, addrlen);
}
----

inet_stream_connect(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

    __inet_stream_connect()
        sk->sk_prot->connect
    
tcp_v4_connect(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_ipv4.c

=== sendmsg
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)
{
	return __sys_sendmsg(fd, msg, flags, true);
}
----

__sys_sendmsg:

    ____sys_sendmsg
            sock_sendmsg_nosec(sock, msg_sys);
            sock_sendmsg(sock, msg_sys);

sock_sendmsg最终也是调用sock_sendmsg_nosec
sock_sendmsg_nosec最终调用inet6_sendmsg或inet_sendmsg
最终调用tcp_sendmsg, udp_sendmsg/udpv6_sendmsg:

tcp_sendmsg(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

    tcp_sendmsg_locked

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c
----
int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct ubuf_info *uarg = NULL;
	struct sk_buff *skb;
	struct sockcm_cookie sockc;
	int flags, err, copied = 0;
	int mss_now = 0, size_goal, copied_syn = 0;
	int process_backlog = 0;
	int zc = 0;
	long timeo;

	flags = msg->msg_flags;

	if ((flags & MSG_ZEROCOPY) && size) {
		if (msg->msg_ubuf) {
			uarg = msg->msg_ubuf;
			if (sk->sk_route_caps & NETIF_F_SG)
				zc = MSG_ZEROCOPY;
		} else if (sock_flag(sk, SOCK_ZEROCOPY)) {
			skb = tcp_write_queue_tail(sk);
			uarg = msg_zerocopy_realloc(sk, size, skb_zcopy(skb));
			if (!uarg) {
				err = -ENOBUFS;
				goto out_err;
			}
			if (sk->sk_route_caps & NETIF_F_SG)
				zc = MSG_ZEROCOPY;
			else
				uarg_to_msgzc(uarg)->zerocopy = 0;
		}
	} else if (unlikely(msg->msg_flags & MSG_SPLICE_PAGES) && size) {
		if (sk->sk_route_caps & NETIF_F_SG)
			zc = MSG_SPLICE_PAGES;
	}

	if (unlikely(flags & MSG_FASTOPEN || inet_sk(sk)->defer_connect) &&
	    !tp->repair) {
		err = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size, uarg);
		if (err == -EINPROGRESS && copied_syn > 0)
			goto out;
		else if (err)
			goto out_err;
	}

	timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	/* Wait for a connection to finish. One exception is TCP Fast Open
	 * (passive side) where data is allowed to be sent before a connection
	 * is fully established.
	 */
	if (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &&
	    !tcp_passive_fastopen(sk)) {
		err = sk_stream_wait_connect(sk, &timeo);
		if (err != 0)
			goto do_error;
	}

	if (unlikely(tp->repair)) {
		if (tp->repair_queue == TCP_RECV_QUEUE) {
			copied = tcp_send_rcvq(sk, msg, size);
			goto out_nopush;
		}

		err = -EINVAL;
		if (tp->repair_queue == TCP_NO_QUEUE)
			goto out_err;

		/* 'common' sending to sendq */
	}

	sockcm_init(&sockc, sk);
	if (msg->msg_controllen) {
		err = sock_cmsg_send(sk, msg, &sockc);
		if (unlikely(err)) {
			err = -EINVAL;
			goto out_err;
		}
	}

	/* This should be in poll */
	sk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);

	/* Ok commence sending. */
	copied = 0;

restart:
	mss_now = tcp_send_mss(sk, &size_goal, flags);

	err = -EPIPE;
	if (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))
		goto do_error;

	while (msg_data_left(msg)) {
		ssize_t copy = 0;

		skb = tcp_write_queue_tail(sk);
		if (skb)
			copy = size_goal - skb->len;

		if (copy <= 0 || !tcp_skb_can_collapse_to(skb)) {
			bool first_skb;

new_segment:
			if (!sk_stream_memory_free(sk))
				goto wait_for_space;

			if (unlikely(process_backlog >= 16)) {
				process_backlog = 0;
				if (sk_flush_backlog(sk))
					goto restart;
			}
			first_skb = tcp_rtx_and_write_queues_empty(sk);
			skb = tcp_stream_alloc_skb(sk, sk->sk_allocation,
						   first_skb);
			if (!skb)
				goto wait_for_space;

			process_backlog++;

			tcp_skb_entail(sk, skb);
			copy = size_goal;

			/* All packets are restored as if they have
			 * already been sent. skb_mstamp_ns isn't set to
			 * avoid wrong rtt estimation.
			 */
			if (tp->repair)
				TCP_SKB_CB(skb)->sacked |= TCPCB_REPAIRED;
		}

		/* Try to append data to the end of skb. */
		if (copy > msg_data_left(msg))
			copy = msg_data_left(msg);

		if (zc == 0) {
			bool merge = true;
			int i = skb_shinfo(skb)->nr_frags;
			struct page_frag *pfrag = sk_page_frag(sk);

			if (!sk_page_frag_refill(sk, pfrag))
				goto wait_for_space;

			if (!skb_can_coalesce(skb, i, pfrag->page,
					      pfrag->offset)) {
				if (i >= READ_ONCE(sysctl_max_skb_frags)) {
					tcp_mark_push(tp, skb);
					goto new_segment;
				}
				merge = false;
			}

			copy = min_t(int, copy, pfrag->size - pfrag->offset);

			if (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb))) {
				if (tcp_downgrade_zcopy_pure(sk, skb))
					goto wait_for_space;
				skb_zcopy_downgrade_managed(skb);
			}

			copy = tcp_wmem_schedule(sk, copy);
			if (!copy)
				goto wait_for_space;

			err = skb_copy_to_page_nocache(sk, &msg->msg_iter, skb,
						       pfrag->page,
						       pfrag->offset,
						       copy);
			if (err)
				goto do_error;

			/* Update the skb. */
			if (merge) {
				skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
			} else {
				skb_fill_page_desc(skb, i, pfrag->page,
						   pfrag->offset, copy);
				page_ref_inc(pfrag->page);
			}
			pfrag->offset += copy;
		} else if (zc == MSG_ZEROCOPY)  {
			/* First append to a fragless skb builds initial
			 * pure zerocopy skb
			 */
			if (!skb->len)
				skb_shinfo(skb)->flags |= SKBFL_PURE_ZEROCOPY;

			if (!skb_zcopy_pure(skb)) {
				copy = tcp_wmem_schedule(sk, copy);
				if (!copy)
					goto wait_for_space;
			}

			err = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);
			if (err == -EMSGSIZE || err == -EEXIST) {
				tcp_mark_push(tp, skb);
				goto new_segment;
			}
			if (err < 0)
				goto do_error;
			copy = err;
		} else if (zc == MSG_SPLICE_PAGES) {
			/* Splice in data if we can; copy if we can't. */
			if (tcp_downgrade_zcopy_pure(sk, skb))
				goto wait_for_space;
			copy = tcp_wmem_schedule(sk, copy);
			if (!copy)
				goto wait_for_space;

			err = skb_splice_from_iter(skb, &msg->msg_iter, copy,
						   sk->sk_allocation);
			if (err < 0) {
				if (err == -EMSGSIZE) {
					tcp_mark_push(tp, skb);
					goto new_segment;
				}
				goto do_error;
			}
			copy = err;

			if (!(flags & MSG_NO_SHARED_FRAGS))
				skb_shinfo(skb)->flags |= SKBFL_SHARED_FRAG;

			sk_wmem_queued_add(sk, copy);
			sk_mem_charge(sk, copy);
		}

		if (!copied)
			TCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;

		WRITE_ONCE(tp->write_seq, tp->write_seq + copy);
		TCP_SKB_CB(skb)->end_seq += copy;
		tcp_skb_pcount_set(skb, 0);

		copied += copy;
		if (!msg_data_left(msg)) {
			if (unlikely(flags & MSG_EOR))
				TCP_SKB_CB(skb)->eor = 1;
			goto out;
		}

		if (skb->len < size_goal || (flags & MSG_OOB) || unlikely(tp->repair))
			continue;

		if (forced_push(tp)) {
			tcp_mark_push(tp, skb);
			__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);
		} else if (skb == tcp_send_head(sk))
			tcp_push_one(sk, mss_now);
		continue;

wait_for_space:
		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
		if (copied)
			tcp_push(sk, flags & ~MSG_MORE, mss_now,
				 TCP_NAGLE_PUSH, size_goal);

		err = sk_stream_wait_memory(sk, &timeo);
		if (err != 0)
			goto do_error;

		mss_now = tcp_send_mss(sk, &size_goal, flags);
	}

out:
	if (copied) {
		tcp_tx_timestamp(sk, sockc.tsflags);
		tcp_push(sk, flags, mss_now, tp->nonagle, size_goal);
	}
out_nopush:
	/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */
	if (uarg && !msg->msg_ubuf)
		net_zcopy_put(uarg);
	return copied + copied_syn;

do_error:
	tcp_remove_empty_skb(sk);

	if (copied + copied_syn)
		goto out;
out_err:
	/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */
	if (uarg && !msg->msg_ubuf)
		net_zcopy_put_abort(uarg, true);
	err = sk_stream_error(sk, flags, err);
	/* make sure we wake any epoll edge trigger waiter */
	if (unlikely(tcp_rtx_and_write_queues_empty(sk) && err == -EAGAIN)) {
		sk->sk_write_space(sk);
		tcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);
	}
	return err;
}
----

udp_sendmsg(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c

=== recvmsg
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,
		unsigned int, flags)
{
	return __sys_recvmsg(fd, msg, flags, true);
}
----

__sys_recvmsg:

    ____sys_recvmsg
            sock_recvmsg_nosec(sock, msg_sys, flags);
            sock_recvmsg(sock, msg_sys, flags);

sock_recvmsg最终也是调用sock_recvmsg_nosec
sock_recvmsg_nosec最终调用inet6_recvmsg或inet_recvmsg
最终调用tcp_recvmsg, udp_recvmsg/udpv6_recvmsg:

tcp_recvmsg(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c
udp_recvmsg(): https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c

=== sendto与send
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
		unsigned int, flags, struct sockaddr __user *, addr,
		int, addr_len)
{
	return __sys_sendto(fd, buff, len, flags, addr, addr_len);
}
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,
		unsigned int, flags)
{
	return __sys_sendto(fd, buff, len, flags, NULL, 0);
}
----

__sys_sendto调用sock_sendmsg。

=== recvfrom与recv
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
		unsigned int, flags, struct sockaddr __user *, addr,
		int __user *, addr_len)
{
	return __sys_recvfrom(fd, ubuf, size, flags, addr, addr_len);
}
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size,
		unsigned int, flags)
{
	return __sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
}
----

__sys_recvfrom调用sock_recvmsg。

=== write
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
static ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct socket *sock = file->private_data;
	struct msghdr msg = {.msg_iter = *from,
			     .msg_iocb = iocb};
	ssize_t res;

	if (iocb->ki_pos != 0)
		return -ESPIPE;

	if (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))
		msg.msg_flags = MSG_DONTWAIT;

	if (sock->type == SOCK_SEQPACKET)
		msg.msg_flags |= MSG_EOR;

	res = sock_sendmsg(sock, &msg);
	*from = msg.msg_iter;
	return res;
}
----

可见，socket write最终也是调用sock_sendmsg。

=== read
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
static ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct socket *sock = file->private_data;
	struct msghdr msg = {.msg_iter = *to,
			     .msg_iocb = iocb};
	ssize_t res;

	if (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))
		msg.msg_flags = MSG_DONTWAIT;

	if (iocb->ki_pos != 0)
		return -ESPIPE;

	if (!iov_iter_count(to))	/* Match SYS5 behaviour */
		return 0;

	res = sock_recvmsg(sock, &msg, msg.msg_flags);
	*to = msg.msg_iter;
	return res;
}
----

可见，socket read最终也是调用sock_recvmsg。

=== epoll
参考: link:../文件/相关系统调用.asc#epoll[epoll]

=== select
参考: link:../文件/相关系统调用.asc#select[select]

=== poll
参考: link:../文件/相关系统调用.asc#poll[poll]

对于tcp:
tcp_poll: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

对于udp:
udp_poll: https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c

=== shutdown
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE2(shutdown, int, fd, int, how)
        __sys_shutdown(fd, how)
            __sys_shutdown_sock(sock, how)
                sock->ops->shutdown(sock, how)

套接口层:
inet_shutdown: https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

对于tcp:
tcp_shutdown: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

=== close
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
static void __sock_release(struct socket *sock, struct inode *inode)
{
	if (sock->ops) {
		struct module *owner = sock->ops->owner;

		if (inode)
			inode_lock(inode);
		sock->ops->release(sock);
		sock->sk = NULL;
		if (inode)
			inode_unlock(inode);
		sock->ops = NULL;
		module_put(owner);
	}

	if (sock->wq.fasync_list)
		pr_err("%s: fasync list not empty!\n", __func__);

	if (!sock->file) {
		iput(SOCK_INODE(sock));
		return;
	}
	sock->file = NULL;
}
//...
static int sock_close(struct inode *inode, struct file *filp)
{
	__sock_release(SOCKET_I(inode), inode);
	return 0;
}
----

套接口层:
inet_release: https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c

对于tcp:
tcp_close: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

对于udp:
udp_lib_close: https://elixir.bootlin.com/linux/latest/source/include/net/udp.h

=== setsockopt
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname, char __user *, optval, int, optlen)
        int __sys_setsockopt(int fd, int level, int optname, char __user *user_optval,int optlen)
            sock->ops->setsockopt

套接口层:
sock_common_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/core/sock.c

对于tcp:
tcp_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c
TCP socket options: https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/tcp.h

对于udp:
udp_setsockopt: https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c
UDP socket options: https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/udp.h

选项:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/socket.h
----
/* For setsockopt(2) */
#define SOL_SOCKET	1

#define SO_DEBUG	1
#define SO_REUSEADDR	2
#define SO_TYPE		3
#define SO_ERROR	4
#define SO_DONTROUTE	5
#define SO_BROADCAST	6
#define SO_SNDBUF	7
#define SO_RCVBUF	8
#define SO_SNDBUFFORCE	32
#define SO_RCVBUFFORCE	33
#define SO_KEEPALIVE	9
#define SO_OOBINLINE	10
#define SO_NO_CHECK	11
#define SO_PRIORITY	12
#define SO_LINGER	13
#define SO_BSDCOMPAT	14
#define SO_REUSEPORT	15
#ifndef SO_PASSCRED /* powerpc only differs in these */
#define SO_PASSCRED	16
#define SO_PEERCRED	17
#define SO_RCVLOWAT	18
#define SO_SNDLOWAT	19
#define SO_RCVTIMEO_OLD	20
#define SO_SNDTIMEO_OLD	21
#endif
----

=== ioctl
ioctl是文件系统的一个系统调用，对于网络系统，会调用到套接口文件的ioctl即sock_ioctl。

sock_ioctl(): https://elixir.bootlin.com/linux/latest/source/net/socket.c

套接口层ioctl:
inet_ioctl: https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c
inet6_ioctl: https://elixir.bootlin.com/linux/latest/source/net/ipv6/af_inet6.c

tcp_ioctl: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

=== getsockname
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
            int __user *, usockaddr_len)

=== getpeername
https://elixir.bootlin.com/linux/latest/source/net/socket.c

    SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
            int __user *, usockaddr_len)