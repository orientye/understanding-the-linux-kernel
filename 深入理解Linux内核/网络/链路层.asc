:toc:
:toclevels: 5
:hardbreaks-option:

== 链路层

=== 说明
这里的链路层指TCP/IP分层模型(四层模型)中的链路层, 基本等同于OSI七层模型中的数据链路层加上物理层。
在使用L层术语的时候, 表示的是OSI七层模型的第几层。

=== 网络设备

==== 注册与注销
注册时机:
(1) 加载网络设备驱动程序
(2) 插入可热插拔网络设备

分配:
alloc_netdev()
alloc_etherdev()

注册:
int register_netdevice(struct net_device *dev);
int register_netdev(struct net_device *dev);

释放:
void free_netdev(struct net_device *dev);

注销:
int unregister_netdevice(struct net_device *dev);
int unregister_netdev(struct net_device *dev);

注册状态通知:
int register_netdevice_notifier(struct notifier_block *nb);
int unregister_netdevice_notifier(struct notifier_block *nb);
等，即netdev_chain通知链

==== 启用

==== 禁用

==== 虚拟网络设备

=== 中断与网络驱动程序
内核准备处理进出L2层的帧之前, 必须先处理中断系统。

负责接受帧的代码分成两部分: 首先, 驱动程序把该帧拷贝到内核可访问的输入队列, 然后内核再予以处理，通常是把那个帧传给一个相关协议(如IP)专用的处理函数。第一部分会在中断环境中执行, 而且可以抢占第二部分的执行。

在高流量负载下，中断代码会持续抢占正在处理的代码。这种结果很明显: 到某一个时间点，输入队列会满，但是由于应该让帧退出队列并予以处理的代码的优先级过低而没有机会执行，结果系统就崩溃了。新的帧无法排入队列, 因为已经没有空间了，而旧的帧又无法被处理，因为灭有CPU可供其使用。这种情况被称为接受-活锁(receive-livelock)。

在低负载下, 纯中断模型可以保证低时延, 但是在高负载下, 其运行就很糟糕。
另一方面, 定时器驱动的中断事件在低负载下可能会引入过多的延时, 而且浪费更多的CPU时间, 但是在高负载下可以大量减少CPU用量并解决接受-活锁问题。
好的组合就是在低负载下使用中断技术, 在高负载下切换至定时器驱动的中断事件。

=== 帧的接收
==== 帧接收的中断处理
中断处理函数:
一些立即性的任务,
1) 把帧拷贝到sk_buf结构(DMA就只需初始化一个指针不需要拷贝)
2) 对一些sk_buff参数进行初始化以便稍后由网络层使用
3) 更新其它一些该设备私用的参数
为NET_RX_SOFTIRQ调度以准备执行。

==== 设备的开启与关闭
设备的开启与关闭是由net_device->state成员进行标识的
dev_open(), dev_close(), _LINK_STATE_START: https://elixir.bootlin.com/linux/latest/source/net/core/dev.c

==== 队列
帧接收时有入口队列，帧传输时有出口队列。
每个队列都有一个指针指向其相关的设备，以及一个指针指向存储输入/输出缓冲区的sk_buff数据接口。
只有少数专用设备不需要队列，例如回环设备。
回环设备: https://elixir.bootlin.com/linux/latest/source/drivers/net/loopback.c

==== 通知内核帧已接收: NAPI和netif_rx
https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h
https://elixir.bootlin.com/linux/latest/source/net/core/dev.c

==== 拥塞管理
高流量网络负载下降低CPU负载的常见方式:
尽可能减少中断事件的数目: 实现方法是驱动程序在一次中断事件中处理许多帧, 或者使用NAPI.
在入口尽早丢弃帧：例如如果设备驱动程序知道入口队列已经满了，就可以立即丢弃帧，而不用转发给内核使其稍后再予以丢弃。

=== 接受分组
分组到达内核的时间是不可预测的。所有现代的设备驱动程序都使用中断来通知内核有分组到达。网络驱动程序对特定于设备的中断设置了一个处理例程，因此每当该中断被引发(即分组到达)，内核都调用该处理程序，将数据从网卡传输到物理内存，或通知内核在一定时间后处理。
几乎所有的网卡都支持DMA模式，能够自行将数据传输到物理内存，但这些数据仍然需要解释和处理。

- 传统方法

- 高速接口

=== 发送分组
int dev_queue_xmit(struct sk_buff *skb)
https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h
https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
