:toc:
:toclevels: 5
:hardbreaks-option:

== 网络层

=== 概念
网络层输入接口packet_type在链路层和网络层起到桥梁作用。
例如在以太网上，当以太网帧到达主机后，内核会根据协议族的报文类型调用相应的网络层接收处理函数。

=== 结构
==== struct packet_type
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h
----
struct packet_type {
	__be16			type;	/* This is really htons(ether_type). */
	bool			ignore_outgoing;
	struct net_device	*dev;	/* NULL is wildcarded here	     */
	netdevice_tracker	dev_tracker;
	int			(*func) (struct sk_buff *,
					 struct net_device *,
					 struct packet_type *,
					 struct net_device *);
	void			(*list_func) (struct list_head *,
					      struct packet_type *,
					      struct net_device *);
	bool			(*id_match)(struct packet_type *ptype,
					    struct sock *sk);
	struct net		*af_packet_net;
	void			*af_packet_priv;
	struct list_head	list;
};
----

ipv4:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/af_inet.c
----
static struct packet_type ip_packet_type __read_mostly = {
	.type = cpu_to_be16(ETH_P_IP),
	.func = ip_rcv,
	.list_func = ip_list_rcv,
};
----

ipv6:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv6/af_inet6.c
----
static struct packet_type ipv6_packet_type __read_mostly = {
	.type = cpu_to_be16(ETH_P_IPV6),
	.func = ipv6_rcv,
	.list_func = ipv6_list_rcv,
};
----

=== 地址

=== 分片与组装

=== 路由