:toc:
:toclevels: 5
:hardbreaks-option:

== 数据的接收

=== 过程概述
• 数据包从外部网络进入网卡
• 网卡(通过DMA)将包拷贝到内核内存中的ring buffer
• 产生硬件中断，通知系统收到了一个包
• 驱动调用NAPI，如果轮询(poll)还没有开始，就开始轮询
• ksoftirqd软中断调用NAPI的poll函数从ring buffer收包(poll函数是网卡驱动在初始化阶段注册的；每个cpu上都运行着一个ksoftirqd进程，在系统启动期间就注册了)
• ring buffer里面对应的内存区域解除映射(unmapped)
• 如果packet steering功能打开，或者网卡有多队列，网卡收到的数据包会被分发到多个cpu
• 数据包从队列进入协议层
• 协议层处理数据包
• 数据包从协议层进入相应socket的接收队列: poll函数将收到的包送到协议栈注册的ip_rcv函数中，ip_rcv函数再将包送到tcp_v4_rcv函数或udp_rcv函数中。

=== 硬中断处理
当数据帧从网线到达网卡上的时候，网卡会在分配给自己的ring buffer中寻找可以使用的内存位置，找到后DMA会把数据DMA到⽹卡之前关联的内存⾥，此时CPU是没有感知的。当DMA操作完成以后，网卡会向CPU发起⼀个硬中断，通知CPU有数据到达。

注意，这个过程中，如果ring buffer满了，新来的数据包将会被丢弃(ifconfig命令查看网卡，可以看到overruns信息项，表示因为环形队列满被丢弃的包，此时可以通过ethtool命令来加大队列的长度)。

对于intel igb网卡，当有数据包到达网卡时，DMA把数据映射到内存，通知CPU硬中断，执行注册的硬中断处理函数igb_msix_ring():

igb_msix_ring(): https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/intel/igb/igb_main.c

    igb_msix_ring() - drivers/net/ethernet/intel/igb/igb_main.c
        __napi_schedule() - net/core/dev.c
            ____napi_schedule() - net/core/dev.c
                __raise_softirq_irqoff(NET_RX_SOFTIRQ) - net/core/dev.c

__raise_softirq_irqoff(NET_RX_SOFTIRQ)发起NET_RX_SOFTIRQ软中断。

=== 软中断处理
ksoftirqd为软中断处理进程，ksoftirqd收到NET_RX_SOFTIRQ软中断后，执行软中断处理函数net_rx_action()，调用网卡驱动poll()函数(对于igb网卡为igb_poll函数)收包。

    run_ksoftirqd() - kernel/softirqd.c
        __do_softirq() - kernel/softirqd.c
            h->action(h) - kernel/softirqd.c
                net_rx_action() - net/core/dev.c
                    napi_poll() - net/core/dev.c
                        __napi_poll - net/core/dev.c
                            work = n->poll(n, weight) - net/core/dev.c
                                igb_poll() - drivers/net/ethernet/intel/igb/igb_main.c

=== 网络接口层
==== igb_clean_rx_irq()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/intel/igb/igb_main.c
----
static int igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget)
{
	struct igb_adapter *adapter = q_vector->adapter;
	struct igb_ring *rx_ring = q_vector->rx.ring;
	struct sk_buff *skb = rx_ring->skb;
	unsigned int total_bytes = 0, total_packets = 0;
	u16 cleaned_count = igb_desc_unused(rx_ring);
	unsigned int xdp_xmit = 0;
	struct xdp_buff xdp;
	u32 frame_sz = 0;
	int rx_buf_pgcnt;

	/* Frame size depend on rx_ring setup when PAGE_SIZE=4K */
#if (PAGE_SIZE < 8192)
	frame_sz = igb_rx_frame_truesize(rx_ring, 0);
#endif
	xdp_init_buff(&xdp, frame_sz, &rx_ring->xdp_rxq);

	while (likely(total_packets < budget)) {
		union e1000_adv_rx_desc *rx_desc;
		struct igb_rx_buffer *rx_buffer;
		ktime_t timestamp = 0;
		int pkt_offset = 0;
		unsigned int size;
		void *pktbuf;

		/* return some buffers to hardware, one at a time is too slow */
		if (cleaned_count >= IGB_RX_BUFFER_WRITE) {
			igb_alloc_rx_buffers(rx_ring, cleaned_count);
			cleaned_count = 0;
		}

		rx_desc = IGB_RX_DESC(rx_ring, rx_ring->next_to_clean);
		size = le16_to_cpu(rx_desc->wb.upper.length);
		if (!size)
			break;

		/* This memory barrier is needed to keep us from reading
		 * any other fields out of the rx_desc until we know the
		 * descriptor has been written back
		 */
		dma_rmb();

		rx_buffer = igb_get_rx_buffer(rx_ring, size, &rx_buf_pgcnt);
		pktbuf = page_address(rx_buffer->page) + rx_buffer->page_offset;

		/* pull rx packet timestamp if available and valid */
		if (igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP)) {
			int ts_hdr_len;

			ts_hdr_len = igb_ptp_rx_pktstamp(rx_ring->q_vector,
							 pktbuf, &timestamp);

			pkt_offset += ts_hdr_len;
			size -= ts_hdr_len;
		}

		/* retrieve a buffer from the ring */
		if (!skb) {
			unsigned char *hard_start = pktbuf - igb_rx_offset(rx_ring);
			unsigned int offset = pkt_offset + igb_rx_offset(rx_ring);

			xdp_prepare_buff(&xdp, hard_start, offset, size, true);
			xdp_buff_clear_frags_flag(&xdp);
#if (PAGE_SIZE > 4096)
			/* At larger PAGE_SIZE, frame_sz depend on len size */
			xdp.frame_sz = igb_rx_frame_truesize(rx_ring, size);
#endif
			skb = igb_run_xdp(adapter, rx_ring, &xdp);
		}

		if (IS_ERR(skb)) {
			unsigned int xdp_res = -PTR_ERR(skb);

			if (xdp_res & (IGB_XDP_TX | IGB_XDP_REDIR)) {
				xdp_xmit |= xdp_res;
				igb_rx_buffer_flip(rx_ring, rx_buffer, size);
			} else {
				rx_buffer->pagecnt_bias++;
			}
			total_packets++;
			total_bytes += size;
		} else if (skb)
			igb_add_rx_frag(rx_ring, rx_buffer, skb, size);
		else if (ring_uses_build_skb(rx_ring))
			skb = igb_build_skb(rx_ring, rx_buffer, &xdp,
					    timestamp);
		else
			skb = igb_construct_skb(rx_ring, rx_buffer,
						&xdp, timestamp);

		/* exit if we failed to retrieve a buffer */
		if (!skb) {
			rx_ring->rx_stats.alloc_failed++;
			rx_buffer->pagecnt_bias++;
			break;
		}

		igb_put_rx_buffer(rx_ring, rx_buffer, rx_buf_pgcnt);
		cleaned_count++;

		/* fetch next buffer in frame if non-eop */
		if (igb_is_non_eop(rx_ring, rx_desc))
			continue;

		/* verify the packet layout is correct */
		if (igb_cleanup_headers(rx_ring, rx_desc, skb)) {
			skb = NULL;
			continue;
		}

		/* probably a little skewed due to removing CRC */
		total_bytes += skb->len;

		/* populate checksum, timestamp, VLAN, and protocol */
		igb_process_skb_fields(rx_ring, rx_desc, skb);

		napi_gro_receive(&q_vector->napi, skb);

		/* reset skb pointer */
		skb = NULL;

		/* update budget accounting */
		total_packets++;
	}

	/* place incomplete frames back on ring for completion */
	rx_ring->skb = skb;

	if (xdp_xmit & IGB_XDP_REDIR)
		xdp_do_flush();

	if (xdp_xmit & IGB_XDP_TX) {
		struct igb_ring *tx_ring = igb_xdp_tx_queue_mapping(adapter);

		igb_xdp_ring_update_tail(tx_ring);
	}

	u64_stats_update_begin(&rx_ring->rx_syncp);
	rx_ring->rx_stats.packets += total_packets;
	rx_ring->rx_stats.bytes += total_bytes;
	u64_stats_update_end(&rx_ring->rx_syncp);
	q_vector->rx.total_packets += total_packets;
	q_vector->rx.total_bytes += total_bytes;

	if (cleaned_count)
		igb_alloc_rx_buffers(rx_ring, cleaned_count);

	return total_packets;
}
----

=== 网络层

=== 传输层

=== 系统调用
无论是socket fd的read系统调用，还是recvfrom/recv/recvmsg系统调用，最终都会调用sock_recvmsg()。

=== 参考
https://blog.packagecloud.io/monitoring-tuning-linux-networking-stack-receiving-data/
https://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/
https://zhuanlan.zhihu.com/p/643195830
https://blog.51cto.com/u_15109148/5469108