:toc:
:toclevels: 5
:hardbreaks-option:

== 数据的发送

=== 过程概述
• 使用系统调用(如sendto，sendmsg等)写数据
• 数据穿过socket子系统，进入socket协议族(protocol family)系统
• 协议族处理：数据穿过协议层，这一过程(在许多情况下)会将数据(data)转换成数据包(packet)
• 数据穿过路由层，这会涉及路由缓存和ARP缓存的更新；如果目的MAC不在ARP缓存表中，将触发一次ARP广播来查找MAC地址
• 穿过协议层，packet到达设备无关层(device agnostic layer)
• 使用XPS(如果启用)或散列函数选择发送队列
• 调用网卡驱动的发送函数
• 数据传送到网卡的qdisc(queue discipline，排队规则)
• qdisc会直接发送数据(如果可以)，或者将其放到队列，下次触发NET_TX类型软中断(softirq)的时候再发送
• 数据从qdisc传送给驱动程序
• 驱动程序创建所需的DMA映射，以便网卡从RAM读取数据
• 驱动向网卡发送信号，通知数据可以发送了
• 网卡从RAM中获取数据并发送
• 发送完成后，设备触发一个硬中断(IRQ)，表示发送完成
• 硬中断处理函数被唤醒执行。对许多设备来说，这会触发NET_RX类型的软中断，然后NAPI poll循环开始收包
• poll函数会调用驱动程序的相应函数，解除DMA映射，释放数据

=== 具体过程

==== 系统调用
无论是socket fd的write系统调用，还是sendto/send/sendmsg系统调用，最终都会调用sock_sendmsg()或者sock_sendmsg_nosec(), 而sock_sendmsg()最终也是调用sock_sendmsg_nosec()。

sock_sendmsg_nosec():
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/socket.c
----
static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)
{
	int ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,
				     inet_sendmsg, sock, msg,
				     msg_data_left(msg));
	//...
}
----

sock_sendmsg_nosec最终调用inet6_sendmsg或inet_sendmsg
最终调用tcp_sendmsg, udp_sendmsg/udpv6_sendmsg:

==== 传输层
===== tcp_sendmsg()
https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp.c

    tcp_sendmsg_locked
        tcp_push
            __tcp_push_pending_frames: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_output.c
                tcp_write_xmit
                    tcp_transmit_skb
                         __tcp_transmit_skb
                            icsk->icsk_af_ops->queue_xmit
                            ip_queue_xmit: https://elixir.bootlin.com/linux/latest/source/net/ipv4/ip_output.c
                                __ip_queue_xmit
                                    ip_local_out

===== udp_sendmsg()
https://elixir.bootlin.com/linux/latest/source/net/ipv4/udp.c

==== 网络层

===== ip_local_out()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/ip_output.c
----
int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	struct iphdr *iph = ip_hdr(skb);

	iph_set_totlen(iph, skb->len);
	ip_send_check(iph);

	/* if egress device is enslaved to an L3 master device pass the
	 * skb to its handler for processing
	 */
	skb = l3mdev_ip_out(sk, skb);
	if (unlikely(!skb))
		return 0;

	skb->protocol = htons(ETH_P_IP);

	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
		       net, sk, skb, NULL, skb_dst(skb)->dev,
		       dst_output);
}

int ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	int err;

	err = __ip_local_out(net, sk, skb);
	if (likely(err == 1))
		err = dst_output(net, sk, skb);

	return err;
}
----
ip_local_out调用__ip_local_out，如果返回值为1，则调用路由层dst_output发送数据包。
__ip_local_out(net, sk, skb):
设置IP数据包的长度；
然后调用ip_send_check来计算要写入IP头的校验和；
之后调用nf_hook进入netfilter，其返回值将传递回ip_local_out。如果nf_hook返回1，则表示允许数据包通过，并且调用者应该自己发送数据包。即上文中的ip_local_out检查返回值1，调用dst_output发送数据包。

nf_hook与netfilter:
nf_hook是一个wrapper，它会检查是否有为这个协议族和hook类型(这里分别为 NFPROTO_IPV4和NF_INET_LOCAL_OUT)安装的过滤器，然后将返回到IP协议层，避免深入到netfilter或更下面，比如iptables和conntrack。
如果有非常多或者非常复杂的netfilter或iptables规则，那些规则将在触发sendmsg系统调的用户进程的上下文中执行。如果对这个用户进程设置了CPU亲和性，相应的CPU将花费系统时间(system time)处理出站(outbound)iptables 规则。如果做性能回归测试，那可能要考虑根据系统的负载，将相应的用户进程绑到到特定的CPU，或者是减少netfilter/iptables规则的复杂度，以减少对性能测试的影响。
假设nf_hook返回1，表示调用者(在这种情况下是IP协议层)应该自己发送数据包。

dst_output:
dst代码在内核中实现协议无关的目标缓存。
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/net/dst.h
----
/* Output packet to network from transport.  */
static inline int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	return INDIRECT_CALL_INET(skb_dst(skb)->output,
				  ip6_output, ip_output,
				  net, sk, skb);
}
----
dst_output()查找关联到skb的dst条目，然后调用output方法，大多数情况下是ip_output。

===== ip_output()
ip_output调用ip_finish_output。

===== ip_finish_output()
ip_finish_out调用ip_finish_output2。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/ip_output.c
----
static int ip_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	struct dst_entry *dst = skb_dst(skb);
	struct rtable *rt = (struct rtable *)dst;
	struct net_device *dev = dst->dev;
	unsigned int hh_len = LL_RESERVED_SPACE(dev);
	struct neighbour *neigh;
	bool is_v6gw = false;

	if (rt->rt_type == RTN_MULTICAST) {
		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTMCAST, skb->len);
	} else if (rt->rt_type == RTN_BROADCAST)
		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTBCAST, skb->len);

	if (unlikely(skb_headroom(skb) < hh_len && dev->header_ops)) {
		skb = skb_expand_head(skb, hh_len);
		if (!skb)
			return -ENOMEM;
	}

	if (lwtunnel_xmit_redirect(dst->lwtstate)) {
		int res = lwtunnel_xmit(skb);

		if (res != LWTUNNEL_XMIT_CONTINUE)
			return res;
	}

	rcu_read_lock();
	neigh = ip_neigh_for_gw(rt, skb, &is_v6gw);
	if (!IS_ERR(neigh)) {
		int res;

		sock_confirm_neigh(skb, neigh);
		/* if crossing protocols, can not use the cached header */
		res = neigh_output(neigh, skb, is_v6gw);
		rcu_read_unlock();
		return res;
	}
	rcu_read_unlock();

	net_dbg_ratelimited("%s: No header cache and no neighbour!\n",
			    __func__);
	kfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_CREATEFAIL);
	return PTR_ERR(neigh);
}
----

==== 邻居系统
===== neigh_output()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/net/neighbour.h
----
static inline int neigh_output(struct neighbour *n, struct sk_buff *skb,
			       bool skip_cache)
{
	const struct hh_cache *hh = &n->hh;

	/* n->nud_state and hh->hh_len could be changed under us.
	 * () is taking care of the race later.
	 */
	if (!skip_cache &&
	    (READ_ONCE(n->nud_state) & NUD_CONNECTED) &&
	    READ_ONCE(hh->hh_len))
		return neigh_hh_output(hh, skb);

	return n->output(n, skb);
}
----

如果hardware header(hh)被缓存(之前发送过数据并进行了缓存)，将调用neigh_hh_output函数;
否则，调用n->output函数。
这两种情况，最后都会调用dev_queue_xmit()，将skb发送给网络设备子系统，在它进入设备驱动程序层之前将对其进行更多处理。

n->output():

struct neighbour包含几个重要字段：nud_state字段，output函数和ops结构。
到如果在缓存中找不到现有条目，会从ip_finish_output2调用__neigh_create创建一个。当调用__neigh_create时，将分配邻居，其output函数最初设置为neigh_blackhole。随着__neigh_create代码的进行，它将根据邻居的状态修改output值以指向适当的发送方法。

例如，当代码确定是"已连接的"邻居时，neigh_connect会将output设置为neigh->ops->connected_output。当代码怀疑邻居可能已关闭时，neigh_suspect会将output设置为neigh->ops->output（例如，如果已超过/proc/sys/net/ipv4/neigh/default/delay_first_probe_time自发送探测以来的delay_first_probe_time 秒）。

也就是说neigh->output会被设置为neigh->ops_connected_output或neigh->ops->output，具体取决于邻居的状态。neigh->ops来自哪里？

分配邻居后，调用arp_constructor来设置struct neighbor的某些字段。特别是，此函数会检查与此邻居关联的设备是否导出来一个struct header_ops实例，该结构体有一个cache方法。
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/ipv4/arp.c
----
static const struct neigh_ops arp_hh_ops = {
	.family =		AF_INET,
	.solicit =		arp_solicit,
	.error_report =		arp_error_report,
	.output =		neigh_resolve_output,
	.connected_output =	neigh_resolve_output,
};
----
因此，不管neighbor是不是"已连接的"，或者邻居缓存代码是否怀疑连接"已关闭"，neigh_resolve_output最终都会被赋给neigh->output。当执行到n->output时就会调用它。

===== neigh_resolve_output()
int neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb):
https://elixir.bootlin.com/linux/latest/source/net/core/neighbour.c
最终也会调用dev_queue_xmit()。

==== 设备系统
===== dev_queue_xmit()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h
----
static inline int dev_queue_xmit(struct sk_buff *skb)
{
	return __dev_queue_xmit(skb, NULL);
}
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
----
/**
 * __dev_queue_xmit() - transmit a buffer
 * @skb:	buffer to transmit
 * @sb_dev:	suboordinate device used for L2 forwarding offload
 *
 * Queue a buffer for transmission to a network device. The caller must
 * have set the device and priority and built the buffer before calling
 * this function. The function can be called from an interrupt.
 *
 * When calling this method, interrupts MUST be enabled. This is because
 * the BH enable code must have IRQs enabled so that it will not deadlock.
 *
 * Regardless of the return value, the skb is consumed, so it is currently
 * difficult to retry a send to this method. (You can bump the ref count
 * before sending to hold a reference for retry if you are careful.)
 *
 * Return:
 * * 0				- buffer successfully transmitted
 * * positive qdisc return code	- NET_XMIT_DROP etc.
 * * negative errno		- other errors
 */
int __dev_queue_xmit(struct sk_buff *skb, struct net_device *sb_dev)
{
	struct net_device *dev = skb->dev;
	struct netdev_queue *txq = NULL;
	struct Qdisc *q;
	int rc = -ENOMEM;
	bool again = false;

	skb_reset_mac_header(skb);
	skb_assert_len(skb);

	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_SCHED_TSTAMP))
		__skb_tstamp_tx(skb, NULL, NULL, skb->sk, SCM_TSTAMP_SCHED);

	/* Disable soft irqs for various locks below. Also
	 * stops preemption for RCU.
	 */
	rcu_read_lock_bh();

	skb_update_prio(skb);

	qdisc_pkt_len_init(skb);
#ifdef CONFIG_NET_CLS_ACT
	skb->tc_at_ingress = 0;
#endif
#ifdef CONFIG_NET_EGRESS
	if (static_branch_unlikely(&egress_needed_key)) {
		if (nf_hook_egress_active()) {
			skb = nf_hook_egress(skb, &rc, dev);
			if (!skb)
				goto out;
		}

		netdev_xmit_skip_txqueue(false);

		nf_skip_egress(skb, true);
		skb = sch_handle_egress(skb, &rc, dev);
		if (!skb)
			goto out;
		nf_skip_egress(skb, false);

		if (netdev_xmit_txqueue_skipped())
			txq = netdev_tx_queue_mapping(dev, skb);
	}
#endif
	/* If device/qdisc don't need skb->dst, release it right now while
	 * its hot in this cpu cache.
	 */
	if (dev->priv_flags & IFF_XMIT_DST_RELEASE)
		skb_dst_drop(skb);
	else
		skb_dst_force(skb);

	if (!txq)
		txq = netdev_core_pick_tx(dev, skb, sb_dev);

	q = rcu_dereference_bh(txq->qdisc);

	trace_net_dev_queue(skb);
	if (q->enqueue) {
		rc = __dev_xmit_skb(skb, q, dev, txq);
		goto out;
	}

	/* The device has no queue. Common case for software devices:
	 * loopback, all the sorts of tunnels...

	 * Really, it is unlikely that netif_tx_lock protection is necessary
	 * here.  (f.e. loopback and IP tunnels are clean ignoring statistics
	 * counters.)
	 * However, it is possible, that they rely on protection
	 * made by us here.

	 * Check this and shot the lock. It is not prone from deadlocks.
	 *Either shot noqueue qdisc, it is even simpler 8)
	 */
	if (dev->flags & IFF_UP) {
		int cpu = smp_processor_id(); /* ok because BHs are off */

		/* Other cpus might concurrently change txq->xmit_lock_owner
		 * to -1 or to their cpu id, but not to our id.
		 */
		if (READ_ONCE(txq->xmit_lock_owner) != cpu) {
			if (dev_xmit_recursion())
				goto recursion_alert;

			skb = validate_xmit_skb(skb, dev, &again);
			if (!skb)
				goto out;

			HARD_TX_LOCK(dev, txq, cpu);

			if (!netif_xmit_stopped(txq)) {
				dev_xmit_recursion_inc();
				skb = dev_hard_start_xmit(skb, dev, txq, &rc);
				dev_xmit_recursion_dec();
				if (dev_xmit_complete(rc)) {
					HARD_TX_UNLOCK(dev, txq);
					goto out;
				}
			}
			HARD_TX_UNLOCK(dev, txq);
			net_crit_ratelimited("Virtual device %s asks to queue packet!\n",
					     dev->name);
		} else {
			/* Recursion is detected! It is possible,
			 * unfortunately
			 */
recursion_alert:
			net_crit_ratelimited("Dead loop on virtual device %s, fix it urgently!\n",
					     dev->name);
		}
	}

	rc = -ENETDOWN;
	rcu_read_unlock_bh();

	dev_core_stats_tx_dropped_inc(dev);
	kfree_skb_list(skb);
	return rc;
out:
	rcu_read_unlock_bh();
	return rc;
}
----
现代网卡是有多个发送队列的，首先要选择一个队列即struct netdev_queue *txq，之后调用__dev_xmit_skb():
(其实还有dev_hard_start_xmit()这条路径，后面会分析dev_hard_start_xmit()，此处先忽略)
[source, c]
.https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
----
static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
				 struct net_device *dev,
				 struct netdev_queue *txq)
{
	spinlock_t *root_lock = qdisc_lock(q);
	struct sk_buff *to_free = NULL;
	bool contended;
	int rc;

	qdisc_calculate_pkt_len(skb, q);

	if (q->flags & TCQ_F_NOLOCK) {
		if (q->flags & TCQ_F_CAN_BYPASS && nolock_qdisc_is_empty(q) &&
		    qdisc_run_begin(q)) {
			/* Retest nolock_qdisc_is_empty() within the protection
			 * of q->seqlock to protect from racing with requeuing.
			 */
			if (unlikely(!nolock_qdisc_is_empty(q))) {
				rc = dev_qdisc_enqueue(skb, q, &to_free, txq);
				__qdisc_run(q);
				qdisc_run_end(q);

				goto no_lock_out;
			}

			qdisc_bstats_cpu_update(q, skb);
			if (sch_direct_xmit(skb, q, dev, txq, NULL, true) &&
			    !nolock_qdisc_is_empty(q))
				__qdisc_run(q);

			qdisc_run_end(q);
			return NET_XMIT_SUCCESS;
		}

		rc = dev_qdisc_enqueue(skb, q, &to_free, txq);
		qdisc_run(q);

no_lock_out:
		if (unlikely(to_free))
			kfree_skb_list_reason(to_free,
					      SKB_DROP_REASON_QDISC_DROP);
		return rc;
	}

	/*
	 * Heuristic to force contended enqueues to serialize on a
	 * separate lock before trying to get qdisc main lock.
	 * This permits qdisc->running owner to get the lock more
	 * often and dequeue packets faster.
	 * On PREEMPT_RT it is possible to preempt the qdisc owner during xmit
	 * and then other tasks will only enqueue packets. The packets will be
	 * sent after the qdisc owner is scheduled again. To prevent this
	 * scenario the task always serialize on the lock.
	 */
	contended = qdisc_is_running(q) || IS_ENABLED(CONFIG_PREEMPT_RT);
	if (unlikely(contended))
		spin_lock(&q->busylock);

	spin_lock(root_lock);
	if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q->state))) {
		__qdisc_drop(skb, &to_free);
		rc = NET_XMIT_DROP;
	} else if ((q->flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&
		   qdisc_run_begin(q)) {
		/*
		 * This is a work-conserving queue; there are no old skbs
		 * waiting to be sent out; and the qdisc is not running -
		 * xmit the skb directly.
		 */

		qdisc_bstats_update(q, skb);

		if (sch_direct_xmit(skb, q, dev, txq, root_lock, true)) {
			if (unlikely(contended)) {
				spin_unlock(&q->busylock);
				contended = false;
			}
			__qdisc_run(q);
		}

		qdisc_run_end(q);
		rc = NET_XMIT_SUCCESS;
	} else {
		rc = dev_qdisc_enqueue(skb, q, &to_free, txq);
		if (qdisc_run_begin(q)) {
			if (unlikely(contended)) {
				spin_unlock(&q->busylock);
				contended = false;
			}
			__qdisc_run(q);
			qdisc_run_end(q);
		}
	}
	spin_unlock(root_lock);
	if (unlikely(to_free))
		kfree_skb_list_reason(to_free, SKB_DROP_REASON_QDISC_DROP);
	if (unlikely(contended))
		spin_unlock(&q->busylock);
	return rc;
}
----
关键函数是__qdisc_run()与sch_direct_xmit()。
而__qdisc_run()最终也会调用sch_direct_xmit(): https://elixir.bootlin.com/linux/latest/source/net/sched/sch_generic.c

    __qdisc_run()
        qdisc_restart()
            sch_direct_xmit()
                dev_hard_start_xmit()

可见，最终都会调用dev_hard_start_xmit(): https://elixir.bootlin.com/linux/latest/source/net/core/dev.c

    dev_hard_start_xmit()
        xmit_one()
            netdev_start_xmit()
                __netdev_start_xmit()

__netdev_start_xmit():
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h
----
static inline netdev_tx_t __netdev_start_xmit(const struct net_device_ops *ops,
					      struct sk_buff *skb, struct net_device *dev,
					      bool more)
{
	__this_cpu_write(softnet_data.xmit.more, more);
	return ops->ndo_start_xmit(skb, dev);
}
----
ops->ndo_start_xmit()即为网卡驱动的发送函数。

==== 网卡驱动
以intel e1000网卡为例，网卡驱动的发送函数即e1000_xmit_frame():
[source, c]
.https://elixir.bootlin.com/linux/latest/source/drivers/net/ethernet/intel/e1000/e1000_main.c
----
static const struct net_device_ops e1000_netdev_ops = {
	//...
	.ndo_start_xmit		= e1000_xmit_frame,
	//...
};
----

=== 参考
http://kerneltravel.net/blog/2020/network_ljr11/
http://kerneltravel.net/blog/2020/network_ljr12/
http://kerneltravel.net/blog/2020/network_ljr13/
http://kerneltravel.net/blog/2020/network_ljr14/
http://kerneltravel.net/blog/2020/network_ljr15/