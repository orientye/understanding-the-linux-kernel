:toc:
:toclevels: 5
:hardbreaks-option:

== 中断

=== 概念
▪ 中断的意义

    中断是为了并发

▪ 硬件中断(hardware interrupt)

    由系统自身和与之链接的外设自动产生
    例如PC上的8259A类似的硬件中断控制芯片发出的中断
    例如ARM中断控制器发出的中断
    Q: 鼠标/键盘如何响应的

▪ 软件中断(Software Interrupt)

    由软件中断指令产生

▪ 软中断(SoftIRQ)

    用于实现内核中的延期操作
    ps -aux | grep softirq
    cat /proc/softirqs | column -t | cut -c -160

▪ 同步中断和异常

    由CPU自身产生，针对当前执行的程序
    Intel微处理器将同步中断和异步中断称为分别称为异常(exceptions)和中断(interrupts)

▪ 异步中断

    由外部设备产生，可能发生在任何时间

▪ 中断VS.信号

    https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison

▪ 中断禁用

    Q: 中断禁用有什么影响
    Q: 哪些情况需要禁用中断

▪ 中断处理

    进入和退出任务
    中断处理程序

▪ 数据结构

    kernel/irq/handle.c
    中断处理程序

▪ 中断电流处理

    边沿触发  水平触发

▪ 初始化和分配IRQ

▪ 处理IRQ

.Q: 中断能嵌套吗?
[%collapsible]
====
    早期中断能嵌套, Linux2.6.35之后取消了中断的嵌套。
    老版本的内核可以在申请中断时设置标记IRQF_DISABLED以避免中断嵌套。
====

.Q: 中断处理函数注意事项?
[%collapsible]
====
    中断函数代码应尽量简洁。避免大量复杂冗长的代码
    尽量避免在中断函数内调用其他自定义函数，数学函数等
    中断函数不能进行参数传递
    中断函数没有返回值
    在任何情况下都不能直接调用中断函数
    在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算
    如果在中断函数中调用了其它函数，则被调用函数所使用的寄存器必须与中断函数相同，被调函数最好设置为可重入的
    中断函数最好写在文件的尾部，并且禁止使用extern存储类型说明。防止其它程序调用
====

▪ 相关命令

    cat /proc/interrupts
    ls /proc/irq
    cat /proc/softirqs

=== 软中断(SoftIRQ)
https://github.com/torvalds/linux/blob/master/include/linux/interrupt.h
https://github.com/torvalds/linux/blob/master/kernel/softirq.c

软中断类型
[source, c]
----
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
----

struct softirq_action

开启软中断处理

    do_softirq

软中断守护进程

    ksoftirqd

=== tasklet

interrupt.h   struct tasklet_struct

注册tasklet

    interrupt.h task_schedule

执行tasklet

    kernel/softirq.c  tasklet_action

=== 等待队列&完成量&工作队列

等待队列

    数据结构 wait.h __wait_queue
    使进程睡眠   wait.h  kernel/wait.c
    唤醒进程 wait.h v  kernel/sched.c

完成量

    与信号量相似，基于等待队列
    completion.h

工作队列

    kernel/workqueue.c

=== v0.12

硬件中断

    kernel/asm.s
    kernel/traps.c