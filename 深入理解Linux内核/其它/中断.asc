:toc:
:toclevels: 5
:hardbreaks-option:

== 中断

=== 概念
▪ 中断的意义

    中断是为了并发

▪ 硬件中断(hardware interrupt)

    由系统自身和与之链接的外设自动产生
    例如PC上的8259A类似的硬件中断控制芯片发出的中断
    例如ARM中断控制器发出的中断
    Q: 鼠标/键盘如何响应的

▪ 软件中断(Software Interrupt)

    由软件中断指令产生
    EFLAGS中的IF标志不能够屏蔽使用INT指令从软件中产生的中断

▪ 软中断(SoftIRQ)

    用于实现内核中的延期操作
    ps -aux | grep softirq
    cat /proc/softirqs | column -t | cut -c -160

▪ 同步中断

    由CPU自身产生，针对当前执行的程序
    Intel微处理器将同步中断和异步中断称为分别称为异常(exceptions)和中断(interrupts)

▪ 异步中断

    由外部设备产生，可能发生在任何时间

▪ 外部中断与内部中断

    内部和外部是相当于CPU来说的
    一般来说，外部中断又可以分为可屏蔽中断与不可屏蔽中断

▪ 可屏蔽中断与不可屏蔽中断

    不可屏蔽中断cpu必须无条件响应, 例如电源掉电, 不可恢复的硬件错误，调试等
    可屏蔽中断cpu可以响应，也可以不响应，例如打印机中断，网卡中断等
    CPU一般设置两根中断请求输入线: 可屏蔽中断请求INTR(interrupt require)和不可屏蔽中断请求NMI(non-maskable interrupt)

▪ 中断与异常

    狭义的中断通常指硬件中断，外部中断
    狭义的异常通常指软件中断，内部中断, 分为trap, fault, abort
    (参考Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3, 6.5)
    广义的异常通常包括interrupt, trap, fault, abort (参考CSAPP 3rd, 8.1)
    实际上，不同的语境下可能有不同的含义
    https://github.com/orientye/understand/blob/main/os/%E4%BA%86%E8%A7%A3Linux/%E5%85%B6%E5%AE%83.asc#exception-conrol-flow

▪ 中断VS.信号

    https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison

▪ BIOS中断 DOS中断 LINUX中断


▪ 中断控制器

    多个外部中断源共享中断资源，必须解决相应的一些问题:
    例如CPU芯片上只有一个INTR输入端，多个中断源如何与INTR连接、中断矢量如何区别、各中断源的优先级如何判定等。
    常见的中断控制器: Intel 8259A, ARM GIC(Generic Interrupt Controller)

▪ 相关命令

    cat /proc/interrupts
    ls /proc/irq
    cat /proc/softirqs

▪ 参考
Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A:System Programming Guide, Part 1 (CHAPTER 6, INTERRUPT AND EXCEPTION HANDLING and CHAPTER 10, ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)

=== 中断处理

==== 进入和退出任务
进入: 建立环境
退出: 还原状态
如果发生中断时位于用户态，则进入时需要从用户态切换到内核态，退出时需要从内核态切换到用户态
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S
    
==== 中断处理程序
中断处理程序则在核心态下执行

.Q: 中断能嵌套吗?
[%collapsible]
====
    早期中断能嵌套, Linux2.6.35之后取消了中断的嵌套。
    老版本的内核可以在申请中断时设置标记IRQF_DISABLED以避免中断嵌套
    IRQF_DISABLED在2010年已经作废: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc
====

.Q: 中断处理函数注意事项?
[%collapsible]
====
    中断函数代码应尽量简洁，避免大量复杂冗长的代码
    中断函数不能进行参数传递
    中断函数没有返回值
    在任何情况下都不能直接调用中断函数
    在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算
    尽量避免在中断函数内调用其他自定义函数，数学函数等
    如果在中断函数中调用了其它函数，则被调用函数所使用的寄存器必须与中断函数相同
    被调函数最好设置为可重入的
    中断函数最好写在文件的尾部，并且禁止使用extern存储类型说明，防止其它程序调用
====

==== 数据结构

    kernel/irq/handle.c
    中断处理程序

==== 中断电流处理

    边沿触发  水平触发

==== 初始化和分配IRQ

==== 处理IRQ

==== 中断禁用

    Q: 中断禁用有什么影响
    Q: 哪些情况需要禁用中断
    Q: 如何禁用中断

==== 中断向量
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h

=== 软中断(SoftIRQ)
https://github.com/torvalds/linux/blob/master/include/linux/interrupt.h
https://github.com/torvalds/linux/blob/master/kernel/softirq.c

软中断类型
[source, c]
----
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
----

struct softirq_action

开启软中断处理

    do_softirq

软中断守护进程

    ksoftirqd

=== tasklet

interrupt.h   struct tasklet_struct

注册tasklet

    interrupt.h task_schedule

执行tasklet

    kernel/softirq.c  tasklet_action

=== 等待队列&完成量&工作队列

等待队列

    数据结构 wait.h __wait_queue
    使进程睡眠   wait.h  kernel/wait.c
    唤醒进程 wait.h v  kernel/sched.c

完成量

    与信号量相似，基于等待队列
    completion.h

工作队列

    kernel/workqueue.c

=== v0.12

硬件中断

    kernel/asm.s
    kernel/traps.c