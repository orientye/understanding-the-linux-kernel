:toc:
:toclevels: 5
:hardbreaks-option:

== 时间管理

=== 概念
==== 时钟硬件
▪ 实时时钟(RTC, Real-Time Clock)
    
    通常是主板上的含电池供电的CMOS时钟芯片，掉电后依然能工作，提供所谓的绝对时间。
    命令: cat /proc/driver/rtc

▪ 系统时钟

    系统时钟提供相对相对时钟。

    PIT(programmable interval timer)
    https://en.wikipedia.org/wiki/Intel_8253
    https://en.wikipedia.org/wiki/Programmable_interval_timer

    TSC(Time Stamp Counter)
    https://en.wikipedia.org/wiki/Time_Stamp_Counter
    
    HPET(High Precision Event Timer)
    https://en.wikipedia.org/wiki/High_Precision_Event_Timer

▪ CPU本地时钟(Local APIC Timer)

    https://wiki.osdev.org/APIC_timer

实时时钟自带供电，关机后依然会工作，每次启动后，作为参照用来设置系统时钟。
系统时钟是系统的核心心跳，通常会根据主板设计从PIT，TSC以及HPET选择精度最高的时钟硬件来使用。
CPU本地时钟处理CPU本地相关的时间，例如进程调度所需要的时间支持。

==== 低分辨率定时器与高分辨率定时器
低分辨率定时器/经典定时器

	以jiffies为单位
	经典分辨率为4毫秒
	定时轮(timer wheel)实现

高分辨率定时器

	以纳秒为单位
	编译选项HIG_RES_TIMERS
	红黑树实现

==== 定时器实现原理
程序上的定时器最终依赖硬件定时器来实现, 内核在时钟中断发生后检测各定时器是否到期
时钟中断处理程序会唤起TIMER_SOFTIRQ软中断, 运行当前处理器上到期的所有定时器
到期后的定时器处理函数将作为软中断在底半部执行

=== 时间表示
▪ 时钟硬件的计数
PIT、TSC、HPET及Local APIC均维护一个硬件计数器，但自个的数值增长速度不同，且经过一段时间，计数器数值会回到0(字长有限)。这些计数只能表示相对时间，在开机时从RTC实时时钟获取绝对时间。

▪ 时钟频率 tick jiffies
时钟频率(HZ)表示每秒时钟中断的次数。
tick是HZ的倒数，即每发生一次中断的时间。例如HZ为250时，tick为4毫秒。
x86支持100 Hz, 250 Hz和1000 Hz，对应的tick/间隔分别是10ms, 4ms和1ms。通过grep CONFIG_HZ /boot/config-$(uname -r)命令可以查看这个数值。
系统开始启动后经过的ticks被记作"jiffies"，每发生一次时钟中断，jiffies的数值就加上1。

▪ tick mode
Status of Linux dynticks: https://blog.linuxplumbersconf.org/2013/ocw/system/presentations/1143/original/dynticks-lpc.pdf
https://github.com/torvalds/linux/blob/master/Documentation/timers/no_hz.rst
https://lwn.net/Kernel/Index/#Dynamic_tick

=== 时钟中断
对于linux这样的分时系统，时钟中断尤为重要，是"生命"之脉搏，因此也被称为heart beat(心跳)。

==== 系统时钟中断
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/time.c
----
/*
 * Default timer interrupt handler for PIT/HPET
 */
static irqreturn_t timer_interrupt(int irq, void *dev_id)
{
	global_clock_event->event_handler(global_clock_event);
	return IRQ_HANDLED;
}

static void __init setup_default_timer_irq(void)
{
	unsigned long flags = IRQF_NOBALANCING | IRQF_IRQPOLL | IRQF_TIMER;

	/*
	 * Unconditionally register the legacy timer interrupt; even
	 * without legacy PIC/PIT we need this for the HPET0 in legacy
	 * replacement mode.
	 */
	if (request_irq(0, timer_interrupt, flags, "timer", NULL))
		pr_info("Failed to register legacy timer interrupt\n");
}

/* Default timer init function */
void __init hpet_time_init(void)
{
	if (!hpet_enable()) {
		if (!pit_timer_init())
			return;
	}

	setup_default_timer_irq();
}
----

==== CPU本地时钟中断
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h
----
#define LOCAL_TIMER_VECTOR		0xec
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/apic/apic.c
----
/*
 * The guts of the apic timer interrupt
 */
static void local_apic_timer_interrupt(void)
{
	struct clock_event_device *evt = this_cpu_ptr(&lapic_events);

	/*
	 * Normally we should not be here till LAPIC has been initialized but
	 * in some cases like kdump, its possible that there is a pending LAPIC
	 * timer interrupt from previous kernel's context and is delivered in
	 * new kernel the moment interrupts are enabled.
	 *
	 * Interrupts are enabled early and LAPIC is setup much later, hence
	 * its possible that when we get here evt->event_handler is NULL.
	 * Check for event_handler being NULL and discard the interrupt as
	 * spurious.
	 */
	if (!evt->event_handler) {
		pr_warn("Spurious LAPIC timer interrupt on cpu %d\n",
			smp_processor_id());
		/* Switch it off */
		lapic_timer_shutdown(evt);
		return;
	}

	/*
	 * the NMI deadlock-detector uses this.
	 */
	inc_irq_stat(apic_timer_irqs);

	evt->event_handler(evt);
}

/*
 * Local APIC timer interrupt. This is the most natural way for doing
 * local interrupts, but local timer interrupts can be emulated by
 * broadcast interrupts too. [in case the hw doesn't support APIC timers]
 *
 * [ if a single-CPU system runs an SMP kernel then we call the local
 *   interrupt as well. Thus we cannot inline the local irq ... ]
 */
DEFINE_IDTENTRY_SYSVEC(sysvec_apic_timer_interrupt)
{
	struct pt_regs *old_regs = set_irq_regs(regs);

	ack_APIC_irq();
	trace_local_timer_entry(LOCAL_TIMER_VECTOR);
	local_apic_timer_interrupt();
	trace_local_timer_exit(LOCAL_TIMER_VECTOR);

	set_irq_regs(old_regs);
}
----

==== RTC时钟
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/mc146818rtc.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/rtc.c

=== 时间系统

==== 配置选项
以笔者服务器为例: Linux my-ubuntu 5.15.0-69-generic #76-Ubuntu SMP Fri Mar 17 17:19:29 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

    CONFIG_NO_HZ_COMMON=y
    # CONFIG_HZ_PERIODIC is not set
    CONFIG_NO_HZ_IDLE=y
    # CONFIG_NO_HZ_FULL is not set
    CONFIG_NO_HZ=y
    # CONFIG_HZ_100 is not set
    CONFIG_HZ_250=y
    # CONFIG_HZ_300 is not set
    # CONFIG_HZ_1000 is not set
    CONFIG_HZ=250

==== clocksource
时钟源是硬件时钟计数器的抽象。
不同的时钟源能够提供的精度可能也不一样，其精度取决于底层硬件的能力。
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/clocksource.h
----
/**
 * struct clocksource - hardware abstraction for a free running counter
 *	Provides mostly state-free accessors to the underlying hardware.
 *	This is the structure used for system time.
 *
 * @read:		Returns a cycle value, passes clocksource as argument
 * @mask:		Bitmask for two's complement
 *			subtraction of non 64 bit counters
 * @mult:		Cycle to nanosecond multiplier
 * @shift:		Cycle to nanosecond divisor (power of two)
 * @max_idle_ns:	Maximum idle time permitted by the clocksource (nsecs)
 * @maxadj:		Maximum adjustment value to mult (~11%)
 * @uncertainty_margin:	Maximum uncertainty in nanoseconds per half second.
 *			Zero says to use default WATCHDOG_THRESHOLD.
 * @archdata:		Optional arch-specific data
 * @max_cycles:		Maximum safe cycle value which won't overflow on
 *			multiplication
 * @name:		Pointer to clocksource name
 * @list:		List head for registration (internal)
 * @rating:		Rating value for selection (higher is better)
 *			To avoid rating inflation the following
 *			list should give you a guide as to how
 *			to assign your clocksource a rating
 *			1-99: Unfit for real use
 *				Only available for bootup and testing purposes.
 *			100-199: Base level usability.
 *				Functional for real use, but not desired.
 *			200-299: Good.
 *				A correct and usable clocksource.
 *			300-399: Desired.
 *				A reasonably fast and accurate clocksource.
 *			400-499: Perfect
 *				The ideal clocksource. A must-use where
 *				available.
 * @id:			Defaults to CSID_GENERIC. The id value is captured
 *			in certain snapshot functions to allow callers to
 *			validate the clocksource from which the snapshot was
 *			taken.
 * @flags:		Flags describing special properties
 * @enable:		Optional function to enable the clocksource
 * @disable:		Optional function to disable the clocksource
 * @suspend:		Optional suspend function for the clocksource
 * @resume:		Optional resume function for the clocksource
 * @mark_unstable:	Optional function to inform the clocksource driver that
 *			the watchdog marked the clocksource unstable
 * @tick_stable:        Optional function called periodically from the watchdog
 *			code to provide stable synchronization points
 * @wd_list:		List head to enqueue into the watchdog list (internal)
 * @cs_last:		Last clocksource value for clocksource watchdog
 * @wd_last:		Last watchdog value corresponding to @cs_last
 * @owner:		Module reference, must be set by clocksource in modules
 *
 * Note: This struct is not used in hotpathes of the timekeeping code
 * because the timekeeper caches the hot path fields in its own data
 * structure, so no cache line alignment is required,
 *
 * The pointer to the clocksource itself is handed to the read
 * callback. If you need extra information there you can wrap struct
 * clocksource into your own struct. Depending on the amount of
 * information you need you should consider to cache line align that
 * structure.
 */
struct clocksource {
	u64			(*read)(struct clocksource *cs);
	u64			mask;
	u32			mult;
	u32			shift;
	u64			max_idle_ns;
	u32			maxadj;
	u32			uncertainty_margin;
#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
	struct arch_clocksource_data archdata;
#endif
	u64			max_cycles;
	const char		*name;
	struct list_head	list;
	int			rating;
	enum clocksource_ids	id;
	enum vdso_clock_mode	vdso_clock_mode;
	unsigned long		flags;

	int			(*enable)(struct clocksource *cs);
	void			(*disable)(struct clocksource *cs);
	void			(*suspend)(struct clocksource *cs);
	void			(*resume)(struct clocksource *cs);
	void			(*mark_unstable)(struct clocksource *cs);
	void			(*tick_stable)(struct clocksource *cs);

	/* private: */
#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
	/* Watchdog related data, used by the framework */
	struct list_head	wd_list;
	u64			cs_last;
	u64			wd_last;
#endif
	struct module		*owner;
};
----

==== clock_event_device
时钟事件设备向时钟添加事件功能，在未来某个时刻发生，也称为时钟事件源。
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/clockchips.h
----
/**
 * struct clock_event_device - clock event device descriptor
 * @event_handler:	Assigned by the framework to be called by the low
 *			level handler of the event source
 * @set_next_event:	set next event function using a clocksource delta
 * @set_next_ktime:	set next event function using a direct ktime value
 * @next_event:		local storage for the next event in oneshot mode
 * @max_delta_ns:	maximum delta value in ns
 * @min_delta_ns:	minimum delta value in ns
 * @mult:		nanosecond to cycles multiplier
 * @shift:		nanoseconds to cycles divisor (power of two)
 * @state_use_accessors:current state of the device, assigned by the core code
 * @features:		features
 * @retries:		number of forced programming retries
 * @set_state_periodic:	switch state to periodic
 * @set_state_oneshot:	switch state to oneshot
 * @set_state_oneshot_stopped: switch state to oneshot_stopped
 * @set_state_shutdown:	switch state to shutdown
 * @tick_resume:	resume clkevt device
 * @broadcast:		function to broadcast events
 * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
 * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
 * @name:		ptr to clock event name
 * @rating:		variable to rate clock event devices
 * @irq:		IRQ number (only for non CPU local devices)
 * @bound_on:		Bound on CPU
 * @cpumask:		cpumask to indicate for which CPUs this device works
 * @list:		list head for the management code
 * @owner:		module reference
 */
struct clock_event_device {
	void			(*event_handler)(struct clock_event_device *);
	int			(*set_next_event)(unsigned long evt, struct clock_event_device *);
	int			(*set_next_ktime)(ktime_t expires, struct clock_event_device *);
	ktime_t			next_event;
	u64			max_delta_ns;
	u64			min_delta_ns;
	u32			mult;
	u32			shift;
	enum clock_event_state	state_use_accessors;
	unsigned int		features;
	unsigned long		retries;

	int			(*set_state_periodic)(struct clock_event_device *);
	int			(*set_state_oneshot)(struct clock_event_device *);
	int			(*set_state_oneshot_stopped)(struct clock_event_device *);
	int			(*set_state_shutdown)(struct clock_event_device *);
	int			(*tick_resume)(struct clock_event_device *);

	void			(*broadcast)(const struct cpumask *mask);
	void			(*suspend)(struct clock_event_device *);
	void			(*resume)(struct clock_event_device *);
	unsigned long		min_delta_ticks;
	unsigned long		max_delta_ticks;

	const char		*name;
	int			rating;
	int			irq;
	int			bound_on;
	const struct cpumask	*cpumask;
	struct list_head	list;
	struct module		*owner;
} ____cacheline_aligned;
----

struct clock_event_device i8253_clockevent: https://elixir.bootlin.com/linux/latest/source/drivers/clocksource/i8253.c
struct hpet_channel成员变量struct clock_event_device evt: https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/hpet.c

clock_event_device *global_clock_event,
在bool __init pit_timer_init(void)里，global_clock_event会被设置为i8253_clockevent；
有HPET时，在int __init hpet_enable(void)->hpet_legacy_clockevent_register()里，global_clock_event会被设置为hc->evt。

==== tick_device
tick设备扩展了clock_event_device(时钟事件源)的功能。
[source, c]
.https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-sched.h
----
enum tick_device_mode {
	TICKDEV_MODE_PERIODIC,
	TICKDEV_MODE_ONESHOT,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};
----

TICKDEV_MODE_PERIODIC: 周期模式
TICKDEV_MODE_ONESHOT: 单触发模式

DECLARE_PER_CPU(struct tick_device, tick_cpu_device): kernel/time/tick-internal.h
DECLARE_PER_CPU(struct tick_device, tick_cpu_device): include/linux/hrtimer.h

==== 定时与超时
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/time.h
----
#ifndef __KERNEL__
#ifndef _STRUCT_TIMESPEC
#define _STRUCT_TIMESPEC
struct timespec {
	__kernel_old_time_t	tv_sec;		/* seconds */
	long			tv_nsec;	/* nanoseconds */
};
#endif

struct timeval {
	__kernel_old_time_t	tv_sec;		/* seconds */
	__kernel_suseconds_t	tv_usec;	/* microseconds */
};

struct itimerspec {
	struct timespec it_interval;/* timer period */
	struct timespec it_value;	/* timer expiration */
};

struct itimerval {
	struct timeval it_interval;/* timer interval */
	struct timeval it_value;	/* current value */
};
#endif

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */
	int	tz_dsttime;	/* type of dst correction */
};
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/ktime.h
----
/* Nanosecond scalar representation for kernel time values */
typedef s64	ktime_t;
----

=== 低分辨率定时器

==== 数据结构
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/timer.h
----
struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct hlist_node	entry;
	unsigned long		expires;
	void			(*function)(struct timer_list *);
	u32			flags;

#ifdef CONFIG_LOCKDEP
	struct lockdep_map	lockdep_map;
#endif
};
----

=== 高分辨率定时器
==== 数据结构
===== hrtimer_cpu_base
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/timer.h
----
/**
 * struct hrtimer_cpu_base - the per cpu clock bases
 * @lock:		lock protecting the base and associated clock bases
 *			and timers
 * @cpu:		cpu number
 * @active_bases:	Bitfield to mark bases with active timers
 * @clock_was_set_seq:	Sequence counter of clock was set events
 * @hres_active:	State of high resolution mode
 * @in_hrtirq:		hrtimer_interrupt() is currently executing
 * @hang_detected:	The last hrtimer interrupt detected a hang
 * @softirq_activated:	displays, if the softirq is raised - update of softirq
 *			related settings is not required then.
 * @nr_events:		Total number of hrtimer interrupt events
 * @nr_retries:		Total number of hrtimer interrupt retries
 * @nr_hangs:		Total number of hrtimer interrupt hangs
 * @max_hang_time:	Maximum time spent in hrtimer_interrupt
 * @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are
 *			 expired
 * @timer_waiters:	A hrtimer_cancel() invocation waits for the timer
 *			callback to finish.
 * @expires_next:	absolute time of the next event, is required for remote
 *			hrtimer enqueue; it is the total first expiry time (hard
 *			and soft hrtimer are taken into account)
 * @next_timer:		Pointer to the first expiring timer
 * @softirq_expires_next: Time to check, if soft queues needs also to be expired
 * @softirq_next_timer: Pointer to the first expiring softirq based timer
 * @clock_base:		array of clock bases for this cpu
 *
 * Note: next_timer is just an optimization for __remove_hrtimer().
 *	 Do not dereference the pointer because it is not reliable on
 *	 cross cpu removals.
 */
struct hrtimer_cpu_base {
	raw_spinlock_t			lock;
	unsigned int			cpu;
	unsigned int			active_bases;
	unsigned int			clock_was_set_seq;
	unsigned int			hres_active		: 1,
					in_hrtirq		: 1,
					hang_detected		: 1,
					softirq_activated       : 1;
#ifdef CONFIG_HIGH_RES_TIMERS
	unsigned int			nr_events;
	unsigned short			nr_retries;
	unsigned short			nr_hangs;
	unsigned int			max_hang_time;
#endif
#ifdef CONFIG_PREEMPT_RT
	spinlock_t			softirq_expiry_lock;
	atomic_t			timer_waiters;
#endif
	ktime_t				expires_next;
	struct hrtimer			*next_timer;
	ktime_t				softirq_expires_next;
	struct hrtimer			*softirq_next_timer;
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
} ____cacheline_aligned;
----

DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases): https://elixir.bootlin.com/linux/latest/source/kernel/time/hrtimer.c

===== hrtimer_clock_base
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/timer.h
----
/**
 * struct hrtimer_clock_base - the timer base for a specific clock
 * @cpu_base:		per cpu clock base
 * @index:		clock type index for per_cpu support when moving a
 *			timer to a base on another cpu.
 * @clockid:		clock id for per_cpu support
 * @seq:		seqcount around __run_hrtimer
 * @running:		pointer to the currently running hrtimer
 * @active:		red black tree root node for the active timers
 * @get_time:		function to retrieve the current time of the clock
 * @offset:		offset of this clock to the monotonic base
 */
struct hrtimer_clock_base {
	struct hrtimer_cpu_base	*cpu_base;
	unsigned int		index;
	clockid_t		clockid;
	seqcount_raw_spinlock_t	seq;
	struct hrtimer		*running;
	struct timerqueue_head	active;
	ktime_t			(*get_time)(void);
	ktime_t			offset;
} __hrtimer_clock_base_align;
----

===== hrtimer
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/timer.h
----
/**
 * struct hrtimer - the basic hrtimer structure
 * @node:	timerqueue node, which also manages node.expires,
 *		the absolute expiry time in the hrtimers internal
 *		representation. The time is related to the clock on
 *		which the timer is based. Is setup by adding
 *		slack to the _softexpires value. For non range timers
 *		identical to _softexpires.
 * @_softexpires: the absolute earliest expiry time of the hrtimer.
 *		The time which was given as expiry time when the timer
 *		was armed.
 * @function:	timer expiry callback function
 * @base:	pointer to the timer base (per cpu and per clock)
 * @state:	state information (See bit values above)
 * @is_rel:	Set if the timer was armed relative
 * @is_soft:	Set if hrtimer will be expired in soft interrupt context.
 * @is_hard:	Set if hrtimer will be expired in hard interrupt context
 *		even on RT.
 *
 * The hrtimer structure must be initialized by hrtimer_init()
 */
struct hrtimer {
	struct timerqueue_node		node;
	ktime_t				_softexpires;
	enum hrtimer_restart		(*function)(struct hrtimer *);
	struct hrtimer_clock_base	*base;
	u8				state;
	u8				is_rel;
	u8				is_soft;
	u8				is_hard;
};
----

==== 参考
https://github.com/torvalds/linux/tree/master/Documentation/timers/hrtimers.rst
https://lwn.net/Kernel/Index/#hrtimer

=== 动态时钟
==== 思想
周期时钟要求系统处在一定的频率下，周期性地处于活动状态，这提升了系统的功耗。
动态时钟改善了这种情况，只有在有些任务需要实际执行时，才会激活周期时钟。

Q: 何时停用与激活周期时钟呢？
A: 当系统调度选择IDLE进程来运行时，动态时钟系统会禁用周期时钟，直到下一个定时器到期或者中断发生。

==== 实现
[source, c]
.https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-sched.h
----
enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE,
	NOHZ_MODE_LOWRES,
	NOHZ_MODE_HIGHRES,
};

/**
 * struct tick_sched - sched tick emulation and no idle tick control/stats
 * @sched_timer:	hrtimer to schedule the periodic tick in high
 *			resolution mode
 * @check_clocks:	Notification mechanism about clocksource changes
 * @nohz_mode:		Mode - one state of tick_nohz_mode
 * @inidle:		Indicator that the CPU is in the tick idle mode
 * @tick_stopped:	Indicator that the idle tick has been stopped
 * @idle_active:	Indicator that the CPU is actively in the tick idle mode;
 *			it is reset during irq handling phases.
 * @do_timer_lst:	CPU was the last one doing do_timer before going idle
 * @got_idle_tick:	Tick timer function has run with @inidle set
 * @last_tick:		Store the last tick expiry time when the tick
 *			timer is modified for nohz sleeps. This is necessary
 *			to resume the tick timer operation in the timeline
 *			when the CPU returns from nohz sleep.
 * @next_tick:		Next tick to be fired when in dynticks mode.
 * @idle_jiffies:	jiffies at the entry to idle for idle time accounting
 * @idle_calls:		Total number of idle calls
 * @idle_sleeps:	Number of idle calls, where the sched tick was stopped
 * @idle_entrytime:	Time when the idle call was entered
 * @idle_waketime:	Time when the idle was interrupted
 * @idle_exittime:	Time when the idle state was left
 * @idle_sleeptime:	Sum of the time slept in idle with sched tick stopped
 * @iowait_sleeptime:	Sum of the time slept in idle with sched tick stopped, with IO outstanding
 * @timer_expires:	Anticipated timer expiration time (in case sched tick is stopped)
 * @timer_expires_base:	Base time clock monotonic for @timer_expires
 * @next_timer:		Expiry time of next expiring timer for debugging purpose only
 * @tick_dep_mask:	Tick dependency mask - is set, if someone needs the tick
 * @last_tick_jiffies:	Value of jiffies seen on last tick
 * @stalled_jiffies:	Number of stalled jiffies detected across ticks
 */
struct tick_sched {
	struct hrtimer			sched_timer;
	unsigned long			check_clocks;
	enum tick_nohz_mode		nohz_mode;

	unsigned int			inidle		: 1;
	unsigned int			tick_stopped	: 1;
	unsigned int			idle_active	: 1;
	unsigned int			do_timer_last	: 1;
	unsigned int			got_idle_tick	: 1;

	ktime_t				last_tick;
	ktime_t				next_tick;
	unsigned long			idle_jiffies;
	unsigned long			idle_calls;
	unsigned long			idle_sleeps;
	ktime_t				idle_entrytime;
	ktime_t				idle_waketime;
	ktime_t				idle_exittime;
	ktime_t				idle_sleeptime;
	ktime_t				iowait_sleeptime;
	unsigned long			last_jiffies;
	u64				timer_expires;
	u64				timer_expires_base;
	u64				next_timer;
	ktime_t				idle_expires;
	atomic_t			tick_dep_mask;
	unsigned long			last_tick_jiffies;
	unsigned int			stalled_jiffies;
};
----

NOHZ_MODE_INACTIVE: 周期时钟处于活动状态
NOHZ_MODE_LOWRES:   基于低分辨率的动态时钟
NOHZ_MODE_HIGHRES:  基于高分辨率的动态时钟

=== 广播模式
在某些省电模式下，时钟事件设备会进入睡眠状态，此时一个全局的static struct tick_device tick_broadcast_device会替换停止的设备，进行tick广播。
https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-broadcast.c

=== 进程与时间
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h
----
struct task_struct {
	//...
	u64				utime;
	u64				stime;
#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
	u64				utimescaled;
	u64				stimescaled;
#endif
	u64				gtime;
	struct prev_cputime		prev_cputime;
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
	struct vtime			vtime;
#endif

#ifdef CONFIG_NO_HZ_FULL
	atomic_t			tick_dep_mask;
#endif
	//...
	/* Monotonic time in nsecs: */
	u64				start_time;

	/* Boot based time in nsecs: */
	u64				start_boottime;
	//...
	/* Empty if CONFIG_POSIX_CPUTIMERS=n */
	struct posix_cputimers		posix_cputimers;

#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK
	struct posix_cputimers_work	posix_cputimers_work;
#endif
	//...
----
u64				utime: 用户态消耗的CPU时间
u64				stime: 内核态消耗的CPU时间

update_process_times函数:
[source, c]
.https://github.com/torvalds/linux/tree/master/kernel/time/timer.c
----
/*
 * Called from the timer interrupt handler to charge one tick to the current
 * process.  user_tick is 1 if the tick is user time, 0 for system.
 */
void update_process_times(int user_tick)
{
	struct task_struct *p = current;

	/* Note: this timer irq context must be accounted for as well. */
	account_process_tick(p, user_tick);
	run_local_timers();
	rcu_sched_clock_irq(user_tick);
#ifdef CONFIG_IRQ_WORK
	if (in_irq())
		irq_work_tick();
#endif
	scheduler_tick();
	if (IS_ENABLED(CONFIG_POSIX_TIMERS))
		run_posix_cpu_timers();
}
----

=== 延迟
- delayed_work
    周期性任务也可以用struct delayed_work来完成
    delayed_work其实是封装了工作队列和定时器:
    https://elixir.bootlin.com/linux/latest/source/include/linux/workqueue.h
    使用:
    schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);
    cancel_delayed_work(struct delayed_work *dwork);等

- 内核延迟
    
    ▪ 忙等延迟
        短延迟: ndelay, udelay, mdelay
        长延迟: while
    ▪ sleep延迟
        schedule_timeout()可以使当前任务休眠至指定的jiffies之后再重新被调度执行
        msleep()和msleep_interruptible()是通过包含了schedule_timeout()的
        schedule_timeout_uninterruptible()和schedule_timeout_interruptible()来实现的

=== 系统调用
SYSCALL_DEFINE:
https://elixir.bootlin.com/linux/latest/source/kernel/time/time.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/hrtimer.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/itimer.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/posix-timers.c

有些时间系统调用通过vDSO机制实现了系统调用的加速。

=== 参考
https://github.com/torvalds/linux/tree/master/Documentation/timers
https://lwn.net/Kernel/Index/#Timekeeping
https://lwn.net/Kernel/Index/#timerfd
https://lwn.net/Kernel/Index/#Timer_frequency
https://lwn.net/Kernel/Index/#Timers
https://github.com/0xAX/linux-insides/tree/master/Timers
http://kernel-tour.org/#time
