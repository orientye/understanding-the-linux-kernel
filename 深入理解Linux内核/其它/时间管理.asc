:toc:
:toclevels: 5
:hardbreaks-option:

== 时间管理

=== 概述
▪ 硬件时钟

    程序上的定时器最终依赖硬件定时器来实现, 内核在时钟中断发生后检测各定时器是否到期
    时钟中断处理程序会唤起TIMER_SOFTIRQ软中断, 运行当前处理器上到期的所有定时器
    到期后的定时器处理函数将作为软中断在底半部执行

=== 类型
低分辨率定时器/经典定时器

    经典分辨率为4毫秒
    定时轮(timer wheel)实现

高分辨率定时器

    编译选项HIG_RES_TIMERS

参考: https://elixir.bootlin.com/linux/latest/source/Documentation/timers/hrtimers.rst

=== 配置
动态ticks
周期ticks

=== 低分辨率定时器

=== 通用时间子系统

=== 高分辨率定时器

=== 动态时钟

=== 广播模式

=== 管理进程时间
update_process_times函数: https://github.com/torvalds/linux/tree/master/kernel/time/timer.c

=== 时钟中断
https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-common.c
tick_periodic

https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/time.c
timer_interrupt

=== 初始化

    start_kernel(): https://elixir.bootlin.com/linux/latest/source/init/main.c
        time_init(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/time.c

=== 其它
- delayed_work
    周期性任务也可以用struct delayed_work来完成
    delayed_work其实是封装了工作队列和定时器:
    https://elixir.bootlin.com/linux/latest/source/include/linux/workqueue.h
    使用:
    schedule_delayed_work(struct delayed_work *dwork, unsigned long delay) 
    cancel_delayed_work(struct delayed_work *dwork);
    cancel_delayed_work_sync(struct delayed_work *dwork);

- 内核延迟
    
    ▪ 忙等延迟
        短延迟: ndelay, udelay, mdelay
        长延迟: while
    ▪ sleep延迟
        schedule_timeout()可以使当前任务休眠至指定的jiffies之后再重新被调度执行
        msleep()和msleep_interruptible()是通过包含了schedule_timeout()的
        schedule_timeout_uninterruptible()和schedule_timeout_interruptible()来实现的

=== 系统调用
https://elixir.bootlin.com/linux/latest/source/kernel/time/time.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/hrtimer.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/posix-timers.c

=== 参考
https://lwn.net/Kernel/Index/#hrtimer
https://lwn.net/Kernel/Index/#Timekeeping
https://lwn.net/Kernel/Index/#timerfd
https://lwn.net/Kernel/Index/#Timer_frequency
https://lwn.net/Kernel/Index/#Timers
