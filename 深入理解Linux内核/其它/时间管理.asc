:toc:
:toclevels: 5
:hardbreaks-option:

== 时间管理

=== 概念
==== 时钟硬件
▪ 实时时钟(RTC, Real-Time Clock)
    
    通常是主板上的含电池供电的CMOS时钟芯片，掉电后依然能工作，提供所谓的绝对时间。
    命令: cat /proc/driver/rtc

▪ 系统时钟

    系统时钟提供相对相对时钟。

    PIT(programmable interval timer)
    https://en.wikipedia.org/wiki/Intel_8253
    https://en.wikipedia.org/wiki/Programmable_interval_timer

    TSC(Time Stamp Counter)
    https://en.wikipedia.org/wiki/Time_Stamp_Counter
    
    HPET(High Precision Event Timer)
    https://en.wikipedia.org/wiki/High_Precision_Event_Timer

▪ CPU本地时钟(Local APIC Timer)

    https://wiki.osdev.org/APIC_timer

实时时钟自带供电，关机后依然会工作，每次启动后，作为参照用来设置系统时钟。
系统时钟是系统的核心心跳，通常会根据主板设计从PIT，TSC以及HPET选择精度最高的时钟硬件来使用。
CPU本地时钟处理CPU本地相关的时间，例如进程调度所需要的时间支持。

==== 低分辨率定时器与高分辨率定时器
低分辨率定时器/经典定时器

	以jiffies为单位
	经典分辨率为4毫秒
	定时轮(timer wheel)实现

高分辨率定时器

	以纳秒为单位
	编译选项HIG_RES_TIMERS
	红黑树实现

==== 定时器实现原理
程序上的定时器最终依赖硬件定时器来实现, 内核在时钟中断发生后检测各定时器是否到期
时钟中断处理程序会唤起TIMER_SOFTIRQ软中断, 运行当前处理器上到期的所有定时器
到期后的定时器处理函数将作为软中断在底半部执行

=== 时间表示
▪ 时钟硬件的计数
PIT、TSC、HPET及Local APIC均维护一个硬件计数器，但自个的数值增长速度不同，且经过一段时间，计数器数值会回到0(字长有限)。这些计数只能表示相对时间，在开机时从RTC实时时钟获取绝对时间。

▪ 时钟频率 tick jiffies
时钟频率(HZ)表示每秒时钟中断的次数。
tick是HZ的倒数，即每发生一次中断的时间。例如HZ为250时，tick为4毫秒。
x86支持100 Hz, 250 Hz和1000 Hz，对应的tick/间隔分别是10ms, 4ms和1ms。通过grep CONFIG_HZ /boot/config-$(uname -r)命令可以查看这个数值。
系统开始启动后经过的ticks被记作"jiffies"，每发生一次时钟中断，jiffies的数值就加上1。

▪ tick mode
Status of Linux dynticks: https://blog.linuxplumbersconf.org/2013/ocw/system/presentations/1143/original/dynticks-lpc.pdf
https://github.com/torvalds/linux/blob/master/Documentation/timers/no_hz.rst
https://lwn.net/Kernel/Index/#Dynamic_tick

=== 数据结构

struct clocksource: https://elixir.bootlin.com/linux/latest/source/include/linux/clocksource.h
时钟源是硬件时钟计数器的抽象。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/time.h
----
#ifndef __KERNEL__
#ifndef _STRUCT_TIMESPEC
#define _STRUCT_TIMESPEC
struct timespec {
	__kernel_old_time_t	tv_sec;		/* seconds */
	long			tv_nsec;	/* nanoseconds */
};
#endif

struct timeval {
	__kernel_old_time_t	tv_sec;		/* seconds */
	__kernel_suseconds_t	tv_usec;	/* microseconds */
};

struct itimerspec {
	struct timespec it_interval;/* timer period */
	struct timespec it_value;	/* timer expiration */
};

struct itimerval {
	struct timeval it_interval;/* timer interval */
	struct timeval it_value;	/* current value */
};
#endif

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */
	int	tz_dsttime;	/* type of dst correction */
};
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/ktime.h
----
/* Nanosecond scalar representation for kernel time values */
typedef s64	ktime_t;
----

=== 时钟中断
==== 系统时钟中断
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/time.c
----
/*
 * Default timer interrupt handler for PIT/HPET
 */
static irqreturn_t timer_interrupt(int irq, void *dev_id)
{
	global_clock_event->event_handler(global_clock_event);
	return IRQ_HANDLED;
}

static void __init setup_default_timer_irq(void)
{
	unsigned long flags = IRQF_NOBALANCING | IRQF_IRQPOLL | IRQF_TIMER;

	/*
	 * Unconditionally register the legacy timer interrupt; even
	 * without legacy PIC/PIT we need this for the HPET0 in legacy
	 * replacement mode.
	 */
	if (request_irq(0, timer_interrupt, flags, "timer", NULL))
		pr_info("Failed to register legacy timer interrupt\n");
}

/* Default timer init function */
void __init hpet_time_init(void)
{
	if (!hpet_enable()) {
		if (!pit_timer_init())
			return;
	}

	setup_default_timer_irq();
}
----

==== CPU本地时钟中断
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h
----
#define LOCAL_TIMER_VECTOR		0xec
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/apic/apic.c
----
/*
 * The guts of the apic timer interrupt
 */
static void local_apic_timer_interrupt(void)
{
	struct clock_event_device *evt = this_cpu_ptr(&lapic_events);

	/*
	 * Normally we should not be here till LAPIC has been initialized but
	 * in some cases like kdump, its possible that there is a pending LAPIC
	 * timer interrupt from previous kernel's context and is delivered in
	 * new kernel the moment interrupts are enabled.
	 *
	 * Interrupts are enabled early and LAPIC is setup much later, hence
	 * its possible that when we get here evt->event_handler is NULL.
	 * Check for event_handler being NULL and discard the interrupt as
	 * spurious.
	 */
	if (!evt->event_handler) {
		pr_warn("Spurious LAPIC timer interrupt on cpu %d\n",
			smp_processor_id());
		/* Switch it off */
		lapic_timer_shutdown(evt);
		return;
	}

	/*
	 * the NMI deadlock-detector uses this.
	 */
	inc_irq_stat(apic_timer_irqs);

	evt->event_handler(evt);
}

/*
 * Local APIC timer interrupt. This is the most natural way for doing
 * local interrupts, but local timer interrupts can be emulated by
 * broadcast interrupts too. [in case the hw doesn't support APIC timers]
 *
 * [ if a single-CPU system runs an SMP kernel then we call the local
 *   interrupt as well. Thus we cannot inline the local irq ... ]
 */
DEFINE_IDTENTRY_SYSVEC(sysvec_apic_timer_interrupt)
{
	struct pt_regs *old_regs = set_irq_regs(regs);

	ack_APIC_irq();
	trace_local_timer_entry(LOCAL_TIMER_VECTOR);
	local_apic_timer_interrupt();
	trace_local_timer_exit(LOCAL_TIMER_VECTOR);

	set_irq_regs(old_regs);
}
----

==== RTC时钟
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/mc146818rtc.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/rtc.c

==== clock_event_device与tick_device
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/clockchips.h
----
/**
 * struct clock_event_device - clock event device descriptor
 * @event_handler:	Assigned by the framework to be called by the low
 *			level handler of the event source
 * @set_next_event:	set next event function using a clocksource delta
 * @set_next_ktime:	set next event function using a direct ktime value
 * @next_event:		local storage for the next event in oneshot mode
 * @max_delta_ns:	maximum delta value in ns
 * @min_delta_ns:	minimum delta value in ns
 * @mult:		nanosecond to cycles multiplier
 * @shift:		nanoseconds to cycles divisor (power of two)
 * @state_use_accessors:current state of the device, assigned by the core code
 * @features:		features
 * @retries:		number of forced programming retries
 * @set_state_periodic:	switch state to periodic
 * @set_state_oneshot:	switch state to oneshot
 * @set_state_oneshot_stopped: switch state to oneshot_stopped
 * @set_state_shutdown:	switch state to shutdown
 * @tick_resume:	resume clkevt device
 * @broadcast:		function to broadcast events
 * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
 * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
 * @name:		ptr to clock event name
 * @rating:		variable to rate clock event devices
 * @irq:		IRQ number (only for non CPU local devices)
 * @bound_on:		Bound on CPU
 * @cpumask:		cpumask to indicate for which CPUs this device works
 * @list:		list head for the management code
 * @owner:		module reference
 */
struct clock_event_device {
	void			(*event_handler)(struct clock_event_device *);
	int			(*set_next_event)(unsigned long evt, struct clock_event_device *);
	int			(*set_next_ktime)(ktime_t expires, struct clock_event_device *);
	ktime_t			next_event;
	u64			max_delta_ns;
	u64			min_delta_ns;
	u32			mult;
	u32			shift;
	enum clock_event_state	state_use_accessors;
	unsigned int		features;
	unsigned long		retries;

	int			(*set_state_periodic)(struct clock_event_device *);
	int			(*set_state_oneshot)(struct clock_event_device *);
	int			(*set_state_oneshot_stopped)(struct clock_event_device *);
	int			(*set_state_shutdown)(struct clock_event_device *);
	int			(*tick_resume)(struct clock_event_device *);

	void			(*broadcast)(const struct cpumask *mask);
	void			(*suspend)(struct clock_event_device *);
	void			(*resume)(struct clock_event_device *);
	unsigned long		min_delta_ticks;
	unsigned long		max_delta_ticks;

	const char		*name;
	int			rating;
	int			irq;
	int			bound_on;
	const struct cpumask	*cpumask;
	struct list_head	list;
	struct module		*owner;
} ____cacheline_aligned;
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-sched.h
----
enum tick_device_mode {
	TICKDEV_MODE_PERIODIC,
	TICKDEV_MODE_ONESHOT,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};
----

kernel/time/tick-internal.h:16:DECLARE_PER_CPU(struct tick_device, tick_cpu_device);
include/linux/hrtimer.h:358:DECLARE_PER_CPU(struct tick_device, tick_cpu_device);

struct clock_event_device i8253_clockevent: https://elixir.bootlin.com/linux/latest/source/drivers/clocksource/i8253.c
struct hpet_channel成员变量struct clock_event_device evt: https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/hpet.c

clock_event_device *global_clock_event,
在bool __init pit_timer_init(void)里，global_clock_event会被设置为i8253_clockevent；
有HPET时，在int __init hpet_enable(void)->hpet_legacy_clockevent_register()里，global_clock_event会被设置为hc->evt。

=== 低分辨率定时器

=== 通用时间子系统

=== 高分辨率定时器

参考: https://github.com/torvalds/linux/tree/master/Documentation/timers/hrtimers.rst

=== 动态时钟
==== 思想
周期时钟要求系统处在一定的频率下，周期性地处于活动状态，这提升了系统的功耗。
动态时钟改善了这种情况，只有在有些任务需要实际执行时，才激活周期时钟。

==== 实现

[source, c]
.https://elixir.bootlin.com/linux/latest/source/kernel/time/tick-sched.h
----
enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE,
	NOHZ_MODE_LOWRES,
	NOHZ_MODE_HIGHRES,
};
----

=== 广播模式

=== 管理进程时间
update_process_times函数: https://github.com/torvalds/linux/tree/master/kernel/time/timer.c

=== 延迟
- delayed_work
    周期性任务也可以用struct delayed_work来完成
    delayed_work其实是封装了工作队列和定时器:
    https://elixir.bootlin.com/linux/latest/source/include/linux/workqueue.h
    使用:
    schedule_delayed_work(struct delayed_work *dwork, unsigned long delay) 
    cancel_delayed_work(struct delayed_work *dwork);
    cancel_delayed_work_sync(struct delayed_work *dwork);

- 内核延迟
    
    ▪ 忙等延迟
        短延迟: ndelay, udelay, mdelay
        长延迟: while
    ▪ sleep延迟
        schedule_timeout()可以使当前任务休眠至指定的jiffies之后再重新被调度执行
        msleep()和msleep_interruptible()是通过包含了schedule_timeout()的
        schedule_timeout_uninterruptible()和schedule_timeout_interruptible()来实现的

=== 系统调用
SYSCALL_DEFINE:
https://elixir.bootlin.com/linux/latest/source/kernel/time/time.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/hrtimer.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/itimer.c
https://elixir.bootlin.com/linux/latest/source/kernel/time/posix-timers.c

=== 参考
https://github.com/torvalds/linux/tree/master/Documentation/timers
https://lwn.net/Kernel/Index/#hrtimer
https://lwn.net/Kernel/Index/#Timekeeping
https://lwn.net/Kernel/Index/#timerfd
https://lwn.net/Kernel/Index/#Timer_frequency
https://lwn.net/Kernel/Index/#Timers
https://github.com/0xAX/linux-insides/tree/master/Timers
http://kernel-tour.org/#time
