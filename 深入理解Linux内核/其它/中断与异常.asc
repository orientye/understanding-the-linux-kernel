:toc:
:toclevels: 5
:hardbreaks-option:

== 中断与异常

=== 概念
▪ 中断

    CPU在执行指令时，收到某个中断信号后转而去执行另外一段代码(中断例程)，之后又返回到原执行流中继续执行的机制。

▪ 中断的意义

    中断是CPU对系统发生的某个事件作出的一种反应，
    这个事件可以是来自外设，例如网卡收到了网络包
    也可以来自CPU自身:运行过程中遇到了异常或某个中断指令，例如缺页异常
    也可以来自其它的CPU，例如SMP系统中一个CPU给另外一个CPU发送IPI(处理器间中断)
    在kernel2.5之前，系统调用也是通过中断来实现的

▪ 硬件中断(Hardware Interrupt)

    由系统自身和与之连接的外设自动产生
    例如PC上的8259A类似的硬件中断控制芯片、ARM中断控制器发出的中断
    Q: 鼠标/键盘如何响应的

▪ 软件中断(Software Interrupt)

    由软件中断指令产生
    EFLAGS中的IF标志不能够屏蔽使用INT指令从软件中产生的中断

▪ 软中断(SoftIRQ)

    用于实现内核中的延期操作
    ps -aux | grep softirq
    cat /proc/softirqs | column -t | cut -c -160

▪ 同步中断

    由CPU自身产生，针对当前执行的程序
    Intel微处理器将同步中断和异步中断称为分别称为异常(exceptions)和中断(interrupts)

▪ 异步中断

    由外部设备产生，可能发生在任何时间

▪ 外部中断与内部中断

    内部和外部是相当于CPU来说的
    一般来说，外部中断又可以分为可屏蔽中断与不可屏蔽中断

▪ 可屏蔽中断(maskable interrupt)与不可屏蔽中断(nomaskable interrupt)

    不可屏蔽中断cpu必须无条件响应, 例如电源掉电, 不可恢复的硬件错误，调试等
    可屏蔽中断cpu可以响应，也可以不响应，例如打印机中断，网卡中断等
    CPU一般设置两根中断请求输入线: 可屏蔽中断请求INTR(interrupt require)和不可屏蔽中断请求NMI(non-maskable interrupt)

▪ 中断与异常

    狭义的中断通常指硬件中断，外部中断
    狭义的异常通常指软件中断，内部中断, 分为trap, fault, abort
    (参考Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3, 6.5)
    广义的异常通常包括interrupt, trap, fault, abort (参考CSAPP 3rd, 8.1)
    
    类别         原因           异步/同步        返回行为                示例
    中断    来自IO设备的信号       异步      总是返回到下一条指令        键盘响应
    陷阱    有意的异常             同步      总是返回到下一条指令        系统调用
    故障    潜在可恢复的错误       同步      可能返回到当前指令          缺页异常
    终止    为不可恢复的错误       同步      不会返回                   硬件错误
    
    实际上，不同的语境下可能有不同的含义
    https://github.com/orientye/understand/blob/main/os/%E4%BA%86%E8%A7%A3Linux/%E5%85%B6%E5%AE%83.asc#exception-conrol-flow

▪ 中断与系统调用
    link:./系统调用.asc#概念[系统调用vs.中断]

▪ 中断与信号

    https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison

▪ BIOS中断 DOS中断 LINUX中断

▪ 中断控制器

    多个外部中断源共享中断资源，必须解决相应的一些问题:
    例如CPU芯片上只有一个INTR输入端，多个中断源如何与INTR连接、中断矢量如何区别、各中断源的优先级如何判定等。
    常见的中断控制器:
        Intel 8259A(适合单CPU, 未能充分挖掘SMP体系结构的并行性, 因此被intel新的APIC来取代)
        APIC: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
            APIC分为两个部分:
                Local APIC(NR_CPU个)，每个CPU都连接一个Local APIC；
                IO APIC(一个)，所有的外设都连接到这个IO APIC上，IO APIC连接到所有的Local APIC上。
                当外设向IO APIC发送中断时，IO APIC会把中断信号转发给某个Local APIC。
                有些Per CPU的设备是直接连接到Local APIC的，可以通过Local APIC直接给自己的CPU发送中断。
        ARM GIC(Generic Interrupt Controller)

▪ 相关命令

    cat /proc/interrupts
    ls /proc/irq
    cat /proc/softirqs

▪ 参考
Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A:System Programming Guide, Part 1 (CHAPTER 6, INTERRUPT AND EXCEPTION HANDLING and CHAPTER 10, ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)

=== 中断
==== 数据结构
struct irq_desc: https://elixir.bootlin.com/linux/latest/source/include/linux/irqdesc.h

struct irqaction: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

==== 状态
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

/*
 * Macros to retrieve the current execution context:
 *
 * in_nmi()		- We're in NMI context
 * in_hardirq()		- We're in hard IRQ context
 * in_serving_softirq()	- We're in softirq context
 * in_task()		- We're in task context
 */
#define in_nmi()		(nmi_count())
#define in_hardirq()		(hardirq_count())
#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
#define in_task()		(!(in_nmi() | in_hardirq() | in_serving_softirq()))

/*
 * The following macros are deprecated and should not be used in new code:
 * in_irq()       - Obsolete version of in_hardirq()
 * in_softirq()   - We have BH disabled, or are processing softirqs
 * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
 */
#define in_irq()		(hardirq_count())
#define in_softirq()		(softirq_count())
#define in_interrupt()		(irq_count())

----
==== 初始化

===== 中断向量表(IDT)初始化

    start_kernel(): https://elixir.bootlin.com/linux/latest/source/init/main.c
        trap_init(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/traps.c
            主要是对系统保留的中断向量的初始化
        init_IRQ(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/irqinit.c
            主要是用于外设的中断
        softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        arch_call_rest_init(): https://elixir.bootlin.com/linux/latest/source/init/main.c
            rest_init()
                kernel_init()
                    kernel_init_freeable()
                        do_basic_setup()
                            init_irq_proc(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/proc.c

===== 中断请求队列初始化
中断向量表内容从0~0x20均为CPU内部产生的中断，包括除0、页面错等。从0x20开始均为用于外部设备的通用中断（包括中断请求队列），但是0x80系统调用除外。这些表项的内容都是在中断向量表初始化的时候进行设置。

===== 用户中断请求注册
request_irq() -> request_threaded_irqz()
https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

===== 卸载中断
free_irq() -> __free_irq()
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

==== 中断处理

===== 进入和退出
进入: 建立环境
退出: 还原状态
如果发生中断时位于用户态，则进入时需要从用户态切换到内核态，退出时需要从内核态切换到用户态
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S

https://www.kernel.org/doc/html/v5.5/x86/entry_64.html

5.8之前:
ret_from_intr: https://elixir.bootlin.com/linux/v5.7.19/source/arch/x86/entry/entry_64.S

===== 中断处理程序
中断处理程序在核心态下执行

按照是否延迟处理分为两种方式:

1.立即完全执行:

    适用于简单时间消耗短的中断。

2.立即执行+延迟执行:

    适用于相对比较耗时的中断。
    中断的下半部不再屏蔽中断，因此提升了系统的整体性能。
    上半部: 屏蔽中断，叫做硬中断(https://elixir.bootlin.com/linux/latest/source/include/linux/hardirq.h?)，处理与硬件相关的紧急事物，立即执行。
    下半部: 不再屏蔽中断，叫做软中断，处理剩下的不太紧急的事物，延迟执行。
    下半部的处理方式: softirq(软中断)、tasklet(微任务)、workqueue(工作队列)、threaded_irq(中断线程)。

https://elixir.bootlin.com/linux/latest/source/kernel/irq/handle.c

.Q: 中断能嵌套吗?
[%collapsible]
====
    早期中断能嵌套, Linux2.6.35之后取消了中断的嵌套。
    老版本的内核可以在申请中断时设置标记IRQF_DISABLED以避免中断嵌套
    IRQF_DISABLED在2010年已经作废: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc
====

.Q: 中断处理函数注意事项?
[%collapsible]
====
    中断函数代码应尽量简洁，避免大量复杂冗长的代码
    中断函数不能进行参数传递
    中断函数没有返回值
    在任何情况下都不能直接调用中断函数
    在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器不允许在ISR中做浮点运算
    尽量避免在中断函数内调用其他自定义函数，数学函数等
    如果在中断函数中调用了其它函数，则被调用函数所使用的寄存器必须与中断函数相同
    被调函数最好设置为可重入的
    中断函数最好写在文件的尾部，并且禁止使用extern存储类型说明，防止其它程序调用
====

==== 中断电流处理
边沿触发
水平触发

==== 中断禁用
Q: 哪些情况需要禁用中断
A: 在某些临界区，必须禁用中断
https://www.quora.com/Why-do-you-need-software-to-disable-interrupt-Microcontrollers


Q: 如何禁用中断

Q: 中断禁用有什么影响

==== 中断向量
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h

==== 软中断(SoftIRQ)

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
   frequency threaded job scheduling. For almost all the purposes
   tasklets are more than enough. F.e. all serial device BHs et
   al. should be converted to tasklets, not to softirqs.
 */
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};

//...

struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

----

软中断注册

    open_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断处理

    raise_softirq() 软中断激活: https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
    
    __do_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断守护进程

    ksoftirqd内核线程: 检查没有被__do_softirq函数执行的softirq，每个CPU都有一个ksoftirqd线程
    static void run_ksoftirqd(unsigned int cpu): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        __do_softirq()

应用

    例如网络收发softirq:
    net_dev_init: https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
    open_softirq(NET_TX_SOFTIRQ, net_tx_action);
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    struct softnet_data: https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h

==== tasklet
tasklet VS. softirq
https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets

struct tasklet_struct: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

tasklet建立在HI_SOFTIRQ和TASKLET_SOFTIRQ两个softirq的基础之上:

    softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        open_softirq(TASKLET_SOFTIRQ, tasklet_action);
        open_softirq(HI_SOFTIRQ, tasklet_hi_action);

tasklet_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
tasklet_hi_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

==== 等待队列&完成量&工作队列
vs. tasklet
tasklet不允许睡眠，等待队列等机制则允许

===== 等待队列
- 数据结构
struct wait_queue_head: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 使进程睡眠
add_wait_queue系列函数: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h
___wait_event宏: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 唤醒进程
__wake_up系列函数: https://elixir.bootlin.com/linux/latest/source/kernel/sched/wait.c

===== 完成量
基于简单等待队列(swait_queue)

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/completion.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/completion.c

struct swait_queue_head {
	raw_spinlock_t		lock;
	struct list_head	task_list;
};
struct swait_queue {
	struct task_struct	*task;
	struct list_head	task_list;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/swait.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/swait.c

===== 工作队列
https://elixir.bootlin.com/linux/latest/source/kernel/workqueue.c
可延迟函数运行在中断上下文中，工作队列的函数运行在进程上下文中
工作队列的函数是有内核线程来执行的: static int worker_thread(void *__worker)

==== SMP
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/io_apic.h

setup_local_APIC(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/apic/apic.c

==== 亲和性
https://www.kernel.org/doc/Documentation/IRQ-affinity.txt

==== 参考
https://www.kernel.org/doc/html/v4.19/core-api/genericirq.html
https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
https://elixir.bootlin.com/linux/latest/source/Documentation/x86/entry_64.rst
https://www.zhihu.com/question/27923521
https://zhuanlan.zhihu.com/p/540897981

=== 异常及异常处理
==== 种类
https://wiki.osdev.org/Exceptions

==== 初始化
https://www.kernel.org/doc/html/latest/x86/exception-tables.html
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/extable.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/extable.c

==== 进入与退出
irqentry_enter_from_user_mode(struct pt_regs *regs)
irqentry_exit_to_user_mode(struct pt_regs *regs)
https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

irqentry_enter(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

在中断返回之前，内核会检查：
调度器是否应该选择一个新进程代替旧的进程
是否有信号必须投递到原进程

irqentry_exit(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c
例如arch/x86/kernel/traps.c  arch/x86/mm/fault.c会调用

5.5之前:
ret_from_exception: https://elixir.bootlin.com/linux/v5.4.215/source/arch/x86/entry/entry_32.S

==== 处理

=== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/asm.s
https://elixir.bootlin.com/linux/0.12/source/kernel/traps.c
asm.s实现了大部分硬件异常所引起的中断服务过程的汇编程序部分
traps.c实现了asm.s中断处理过程中调用的C函数部分
另外几个硬件中断处理程序在文件sys_call.s和mm/page.s中实现。

==== 参考
https://os.phil-opp.com/cpu-exceptions/
https://zhuanlan.zhihu.com/p/540897981
