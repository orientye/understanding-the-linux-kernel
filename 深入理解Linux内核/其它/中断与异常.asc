:toc:
:toclevels: 5
:hardbreaks-option:

== 中断与异常

=== 概念
▪ 中断

    CPU在执行指令时，收到某个中断信号后转而去执行另外一段代码(中断例程)，之后又返回到原执行流中继续执行的机制。

▪ 中断的意义

    中断是CPU对系统发生的某个事件作出的一种反应，
    这个事件可以是来自外设，例如网卡收到了网络包
    也可以来自CPU自身:运行过程中遇到了异常或某个中断指令，例如缺页异常
    也可以来自其它的CPU，例如SMP系统中一个CPU给另外一个CPU发送IPI(处理器间中断)
    在kernel2.5之前，系统调用也是通过中断来实现的

▪ 中断与异常

    狭义的中断通常指硬件中断，外部中断
    狭义的异常通常指软件中断，内部中断, 分为trap, fault, abort
    (参考Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3, 6.5)
    广义的异常通常包括interrupt, trap, fault, abort (参考CSAPP 3rd, 8.1)
    
    类别         原因           异步/同步        返回行为                示例
    中断    来自IO设备的信号       异步        总是返回到下一条指令        键盘响应
    陷阱    有意的异常            同步        总是返回到下一条指令        系统调用
    故障    潜在可恢复的错误       同步        可能返回到当前指令          缺页异常
    终止    为不可恢复的错误       同步        不会返回                  硬件错误
    
    实际上，不同的语境下可能有不同的含义

▪ 中断与系统调用
    link:./系统调用.asc#概念[系统调用vs.中断]

▪ 硬件中断(Hardware Interrupt)

    由系统自身和与之连接的外设自动产生
    例如PC上的8259A类似的硬件中断控制芯片、ARM中断控制器发出的中断
    Q: 键盘如何响应的
    A: https://wiki.osdev.org/Interrupt#From_the_keyboard.27s_perspective

	从处理模式上，可以将硬件中断分为三类:
		APIC/SMP Interrupt
		Normal Interrupt
		Spurious Interrupt
	
	处理器间中断(interprocessor interrupt): 
		一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。

	伪中断(spurious interrupt): 
		一类不希望被产生的硬件中断。如中断线路上电气信号异常或中断请求设备本身有问题。

▪ 软件中断(Software Interrupt)

    由软件中断指令产生
    EFLAGS中的IF标志不能够屏蔽使用INT指令从软件中产生的中断

▪ 软中断(SoftIRQ)

    用于实现内核中的延期操作
    ps -aux | grep softirq
    cat /proc/softirqs | column -t | cut -c -160

▪ 同步中断与异步中断

    同步中断由CPU自身产生，针对当前执行的程序
    异步中断由外部设备产生，可能发生在任何时间
    Intel微处理器将同步中断和异步中断称为分别称为异常(exceptions)和中断(interrupts)

▪ 外部中断与内部中断

    内部和外部是相当于CPU来说的
    一般来说，外部中断又可以分为可屏蔽中断与不可屏蔽中断

▪ 可屏蔽中断(maskable interrupt)与不可屏蔽中断(nomaskable interrupt)

    不可屏蔽中断cpu必须无条件响应, 例如电源掉电, 不可恢复的硬件错误，调试等
    可屏蔽中断cpu可以响应，也可以不响应，例如打印机中断，网卡中断等
    CPU一般设置两根中断请求输入线: 可屏蔽中断请求INTR(interrupt require)和不可屏蔽中断请求NMI(non-maskable interrupt)

▪ 中断与信号

    https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison

▪ BIOS中断 DOS中断 LINUX中断

▪ 中断控制器

    多个外部中断源共享中断资源，必须解决相应的一些问题:
    例如CPU芯片上只有一个INTR输入端，多个中断源如何与INTR连接、中断矢量如何区别、各中断源的优先级如何判定等。
    常见的中断控制器:
        Intel 8259A(适合单CPU, 未能充分挖掘SMP体系结构的并行性, 因此被intel新的APIC来取代)
        APIC: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
            APIC分为两个部分:
                Local APIC(NR_CPU个)，每个CPU都连接一个Local APIC；
                IO APIC(一个)，所有的外设都连接到这个IO APIC上，IO APIC连接到所有的Local APIC上。
                当外设向IO APIC发送中断时，IO APIC会把中断信号转发给某个Local APIC。
                有些Per CPU的设备是直接连接到Local APIC的，可以通过Local APIC直接给自己的CPU发送中断。
        ARM GIC(Generic Interrupt Controller)

▪ 相关命令

    cat /proc/interrupts
    ls /proc/irq
    cat /proc/softirqs

=== 数据结构

- 中断向量(interrupt vector)

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h
----
/*
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... LOCAL_TIMER_VECTOR-1
 *  Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */

#define NR_VECTORS			 256
----

- IDT(interrupt descriptor table)与IDTR(IDTR register)

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----
/* Must be page-aligned because the real IDT is used in the cpu entry area */
static gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/desc_defs.h
----
struct idt_bits {
	u16		ist	: 3,
			zero	: 5,
			type	: 5,
			dpl	: 2,
			p	: 1;
} __attribute__((packed));

struct idt_data {
	unsigned int	vector;
	unsigned int	segment;
	struct idt_bits	bits;
	const void	*addr;
};

struct gate_struct {
	u16		offset_low;
	u16		segment;
	struct idt_bits	bits;
	u16		offset_middle;
#ifdef CONFIG_X86_64
	u32		offset_high;
	u32		reserved;
#endif
} __attribute__((packed));

typedef struct gate_struct gate_desc;
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/segment.h
----
#define IDT_ENTRIES			256
----

中断向量表idt_table是门描述符gate_desc的数组，数组大小是IDT_ENTRIES即256。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----
static struct desc_ptr idt_descr __ro_after_init = {
	.size		= IDT_TABLE_SIZE - 1,
	.address	= (unsigned long) idt_table,
};

#define IDT_TABLE_SIZE		(IDT_ENTRIES * sizeof(gate_desc))
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/desc_defs.h
----
struct desc_ptr {
	unsigned short size;
	unsigned long address;
} __attribute__((packed)) ;
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/desc.h
----
#define load_idt(dtr)				native_load_idt(dtr)
//...
static __always_inline void native_load_idt(const struct desc_ptr *dtr)
{
	asm volatile("lidt %0"::"m" (*dtr));
}
----

注意: 有好几个idt中断向量表的项, 例如early_idts, def_idts, apic_idts, early_pf_idts, 定义在:
https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c

函数idt_setup_from_table()会定义一个gate_desc的临时变量，用idt_data来初始化这个gate_desc，之后把gate_desc复制到idt_table中对应的位置中去，由此，中断向量表中的此项(idt_data)就生效了:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----
static __init void
idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size > 0; t++, size--) {
		idt_init_desc(&desc, t);
		write_idt_entry(idt, t->vector, &desc);
		if (sys)
			set_bit(t->vector, system_vectors);
	}
}
----

=== 状态
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

/*
 * Macros to retrieve the current execution context:
 *
 * in_nmi()		- We're in NMI context
 * in_hardirq()		- We're in hard IRQ context
 * in_serving_softirq()	- We're in softirq context
 * in_task()		- We're in task context
 */
#define in_nmi()		(nmi_count())
#define in_hardirq()		(hardirq_count())
#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
#define in_task()		(!(in_nmi() | in_hardirq() | in_serving_softirq()))

/*
 * The following macros are deprecated and should not be used in new code:
 * in_irq()       - Obsolete version of in_hardirq()
 * in_softirq()   - We have BH disabled, or are processing softirqs
 * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
 */
#define in_irq()		(hardirq_count())
#define in_softirq()		(softirq_count())
#define in_interrupt()		(irq_count())

----

=== 初始化

    start_kernel(): https://elixir.bootlin.com/linux/latest/source/init/main.c
        trap_init(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/traps.c
            主要是对系统保留的中断向量的初始化
            idt_setup_traps(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
        init_IRQ(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/irqinit.c
            主要是用于外设的中断
            native_init_IRQ()
                idt_setup_apic_and_irq_gates(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
        softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        arch_call_rest_init(): https://elixir.bootlin.com/linux/latest/source/init/main.c
            rest_init()
                kernel_init()
                    kernel_init_freeable()
                        do_basic_setup()
                            init_irq_proc(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/proc.c

=== 中断处理

==== 概要与注意事项
中断处理程序在核心态下执行

关键操作必须在中断发生后立即执行，否则无法维持系统的稳定性与正确运作，在此期间，必须禁用其它中断。
非关键操作也应该尽快执行，但允许启用中断。
可延期操作不是特别重要，不必在中断处理程序中实现。

按照是否延迟处理分为两种方式:
1.立即完全执行:

    适用于简单时间消耗短的中断。

2.立即执行+延迟执行:

    适用于相对比较耗时的中断。
    中断的下半部不再屏蔽中断，因此提升了系统的整体性能。
    上半部: 硬中断(https://elixir.bootlin.com/linux/latest/source/include/linux/hardirq.h)，处理与硬件相关的紧急事物，立即执行。
    下半部: 软中断，处理剩下的不太紧急的事物，延迟执行。
    下半部的处理方式有: softirq(软中断)、tasklet(微任务)、threaded_irq(中断线程)、workqueue(工作队列)。

通常内核通过以下方式来响应中断:
1. 内核自动处理/修复，对用户进程不可见，如缺页异常。
2. 向当前进程发送一个信号，如除零发送SIGFPE信号。

.Q: 中断能嵌套吗?
[%collapsible]
====
早期中断能嵌套, Linux2.6.35之后取消了中断的嵌套。
老版本的内核可以在申请中断时设置标记IRQF_DISABLED以避免中断嵌套
IRQF_DISABLED在2010年已经作废: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc

硬件中断的前半部分是硬中断，后半部分是软中断，硬中断中不能再嵌套硬中断了，但是软中断中可以嵌套硬中断。

软中断是不能独立触发的，必须是硬中断触发软中断。如果第一个硬中断执行完成了，然后在软中断的执行过程中又发生了硬中断，第二个硬中断还没执行完的时候在执行过程中的时候又发生了NMI中断。这样就会发生四个不同等级的执行流一一嵌套的情况，这也是队列自旋锁的锁节点为啥要乘以4的原因。
====

.Q: 中断处理函数注意事项?
[%collapsible]
====
    中断函数代码应尽量简洁，避免大量复杂冗长的代码
    中断函数不能进行参数传递
    中断函数没有返回值
    在任何情况下都不能直接调用中断函数
    在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器不允许在ISR中做浮点运算
    尽量避免在中断函数内调用其他自定义函数，数学函数等
    如果在中断函数中调用了其它函数，则被调用函数所使用的寄存器必须与中断函数相同
    被调函数最好设置为可重入的
    中断函数最好写在文件的尾部，并且禁止使用extern存储类型说明，防止其它程序调用
====

==== 进入和退出
进入: 建立环境
退出: 还原状态
如果发生中断时位于用户态，则进入时需要从用户态切换到内核态，退出时需要从内核态切换到用户态

irqentry_enter(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c
irqentry_exit(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

irqentry_enter和irqentry_exit在哪里调用呢?
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/idtentry.h
比较重要的一些宏:
DEFINE_IDTENTRY与DEFINE_IDTENTRY_ERRORCODE
DEFINE_IDTENTRY_IRQ
DECLARE_IDTENTRY_IRQ
最终实现位于: https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S

在x86上，中断需通过IDT中的表项分发:
若通过Interrupt Gate进入中断处理例程，则EFLAGS的IF（Interrupt Flag）会被清零（相当于执行CLI指令），从而禁用中断，直到执行IRET指令从中断处理例程中返回时，才会重置IF;
若通过的是Trap Gate，则不会对IF作任何操作。

https://www.kernel.org/doc/html/v5.5/x86/entry_64.html

5.8之前:
ret_from_intr: https://elixir.bootlin.com/linux/v5.7.19/source/arch/x86/entry/entry_64.S
5.5之前:
ret_from_exception: https://elixir.bootlin.com/linux/v5.4.215/source/arch/x86/entry/entry_32.S

- irq_stack

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/processor.h
----
/* Per CPU interrupt stacks */
struct irq_stack {
	char		stack[IRQ_STACK_SIZE];
} __aligned(IRQ_STACK_SIZE);
//...
DECLARE_PER_CPU(struct irq_stack *, hardirq_stack_ptr);
DECLARE_PER_CPU(struct irq_stack *, softirq_stack_ptr);
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h
----
#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
#define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)
----

https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_stack.h

- exception statck

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/cpu_entry_area.h
----
#ifdef CONFIG_AMD_MEM_ENCRYPT
#define VC_EXCEPTION_STKSZ	EXCEPTION_STKSZ
#else
#define VC_EXCEPTION_STKSZ	0
#endif

/* Macro to enforce the same ordering and stack sizes */
#define ESTACKS_MEMBERS(guardsize, optional_stack_size)		\
	char	DF_stack_guard[guardsize];			\
	char	DF_stack[EXCEPTION_STKSZ];			\
	char	NMI_stack_guard[guardsize];			\
	char	NMI_stack[EXCEPTION_STKSZ];			\
	char	DB_stack_guard[guardsize];			\
	char	DB_stack[EXCEPTION_STKSZ];			\
	char	MCE_stack_guard[guardsize];			\
	char	MCE_stack[EXCEPTION_STKSZ];			\
	char	VC_stack_guard[guardsize];			\
	char	VC_stack[optional_stack_size];			\
	char	VC2_stack_guard[guardsize];			\
	char	VC2_stack[optional_stack_size];			\
	char	IST_top_guard[guardsize];			\

/* The exception stacks' physical storage. No guard pages required */
struct exception_stacks {
	ESTACKS_MEMBERS(0, VC_EXCEPTION_STKSZ)
};

/* The effective cpu entry area mapping with guard pages. */
struct cea_exception_stacks {
	ESTACKS_MEMBERS(PAGE_SIZE, EXCEPTION_STKSZ)
};

/*
 * The exception stack ordering in [cea_]exception_stacks
 */
enum exception_stack_ordering {
	ESTACK_DF,
	ESTACK_NMI,
	ESTACK_DB,
	ESTACK_MCE,
	ESTACK_VC,
	ESTACK_VC2,
	N_EXCEPTION_STACKS
};
//...
DECLARE_PER_CPU(struct cea_exception_stacks *, cea_exception_stacks);
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h
----
#define EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER)
#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
----

参考:https://zhuanlan.zhihu.com/p/121630145
参考:https://zhuanlan.zhihu.com/p/353767294
参考:https://01.org/linuxgraphics/gfx-docs/drm/x86/kernel-stacks.html

=== 异常
==== 种类
https://wiki.osdev.org/Exceptions
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/trapnr.h

==== 处理
与异常相关IDT项定义在early_idts, def_idts, early_pf_idts数组中:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----
/*
 * Early traps running on the DEFAULT_STACK because the other interrupt
 * stacks work only after cpu_init().
 */
static const __initconst struct idt_data early_idts[] = {
	INTG(X86_TRAP_DB,		asm_exc_debug),
	SYSG(X86_TRAP_BP,		asm_exc_int3),

#ifdef CONFIG_X86_32
	/*
	 * Not possible on 64-bit. See idt_setup_early_pf() for details.
	 */
	INTG(X86_TRAP_PF,		asm_exc_page_fault),
#endif
#ifdef CONFIG_INTEL_TDX_GUEST
	INTG(X86_TRAP_VE,		asm_exc_virtualization_exception),
#endif
};

/*
 * The default IDT entries which are set up in trap_init() before
 * cpu_init() is invoked. Interrupt stacks cannot be used at that point and
 * the traps which use them are reinitialized with IST after cpu_init() has
 * set up TSS.
 */
static const __initconst struct idt_data def_idts[] = {
	INTG(X86_TRAP_DE,		asm_exc_divide_error),
	ISTG(X86_TRAP_NMI,		asm_exc_nmi, IST_INDEX_NMI),
	INTG(X86_TRAP_BR,		asm_exc_bounds),
	INTG(X86_TRAP_UD,		asm_exc_invalid_op),
	INTG(X86_TRAP_NM,		asm_exc_device_not_available),
	INTG(X86_TRAP_OLD_MF,		asm_exc_coproc_segment_overrun),
	INTG(X86_TRAP_TS,		asm_exc_invalid_tss),
	INTG(X86_TRAP_NP,		asm_exc_segment_not_present),
	INTG(X86_TRAP_SS,		asm_exc_stack_segment),
	INTG(X86_TRAP_GP,		asm_exc_general_protection),
	INTG(X86_TRAP_SPURIOUS,		asm_exc_spurious_interrupt_bug),
	INTG(X86_TRAP_MF,		asm_exc_coprocessor_error),
	INTG(X86_TRAP_AC,		asm_exc_alignment_check),
	INTG(X86_TRAP_XF,		asm_exc_simd_coprocessor_error),

#ifdef CONFIG_X86_32
	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
#else
	ISTG(X86_TRAP_DF,		asm_exc_double_fault, IST_INDEX_DF),
#endif
	ISTG(X86_TRAP_DB,		asm_exc_debug, IST_INDEX_DB),

#ifdef CONFIG_X86_MCE
	ISTG(X86_TRAP_MC,		asm_exc_machine_check, IST_INDEX_MCE),
#endif

#ifdef CONFIG_X86_KERNEL_IBT
	INTG(X86_TRAP_CP,		asm_exc_control_protection),
#endif

#ifdef CONFIG_AMD_MEM_ENCRYPT
	ISTG(X86_TRAP_VC,		asm_exc_vmm_communication, IST_INDEX_VC),
#endif

	SYSG(X86_TRAP_OF,		asm_exc_overflow),
#if defined(CONFIG_IA32_EMULATION)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
#elif defined(CONFIG_X86_32)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
#endif
};

//...

/*
 * Early traps running on the DEFAULT_STACK because the other interrupt
 * stacks work only after cpu_init().
 */
static const __initconst struct idt_data early_pf_idts[] = {
	INTG(X86_TRAP_PF,		asm_exc_page_fault),
};
----

至于具体的实现，绝大部分异常处理的函数定义在https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/traps.c, 例如exc_debug(asm_exc_debug)；
缺页异常exc_page_fault则定义在https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/fault.c

=== 硬中断(HardIRQ)
对硬件中断的设置分为两个部分，一部分是从apic_idts数组设置的，设置的都是一些IPI和per CPU的中断。这部分与软件中断类似。
另一部分是把所有剩下的的硬件中断的处理函数都设置为irq_entries_start，irq_entries_start会调用common_interrupt函数。
common_interrupt()中会根据中断向量号去读取per CPU的数组变量vector_irq，得到一个irq_desc，handle_irq来处理这个中断。

- 通过apic_idts数组
与apic相关IDT项定义在apic_idts数组中:

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----
/*
 * The APIC and SMP idt entries
 */
static const __initconst struct idt_data apic_idts[] = {
#ifdef CONFIG_SMP
	INTG(RESCHEDULE_VECTOR,			asm_sysvec_reschedule_ipi),
	INTG(CALL_FUNCTION_VECTOR,		asm_sysvec_call_function),
	INTG(CALL_FUNCTION_SINGLE_VECTOR,	asm_sysvec_call_function_single),
	INTG(IRQ_MOVE_CLEANUP_VECTOR,		asm_sysvec_irq_move_cleanup),
	INTG(REBOOT_VECTOR,			asm_sysvec_reboot),
#endif

#ifdef CONFIG_X86_THERMAL_VECTOR
	INTG(THERMAL_APIC_VECTOR,		asm_sysvec_thermal),
#endif

#ifdef CONFIG_X86_MCE_THRESHOLD
	INTG(THRESHOLD_APIC_VECTOR,		asm_sysvec_threshold),
#endif

#ifdef CONFIG_X86_MCE_AMD
	INTG(DEFERRED_ERROR_VECTOR,		asm_sysvec_deferred_error),
#endif

#ifdef CONFIG_X86_LOCAL_APIC
	INTG(LOCAL_TIMER_VECTOR,		asm_sysvec_apic_timer_interrupt),
	INTG(X86_PLATFORM_IPI_VECTOR,		asm_sysvec_x86_platform_ipi),
# ifdef CONFIG_HAVE_KVM
	INTG(POSTED_INTR_VECTOR,		asm_sysvec_kvm_posted_intr_ipi),
	INTG(POSTED_INTR_WAKEUP_VECTOR,		asm_sysvec_kvm_posted_intr_wakeup_ipi),
	INTG(POSTED_INTR_NESTED_VECTOR,		asm_sysvec_kvm_posted_intr_nested_ipi),
# endif
# ifdef CONFIG_IRQ_WORK
	INTG(IRQ_WORK_VECTOR,			asm_sysvec_irq_work),
# endif
	INTG(SPURIOUS_APIC_VECTOR,		asm_sysvec_spurious_apic_interrupt),
	INTG(ERROR_APIC_VECTOR,			asm_sysvec_error_interrupt),
#endif
};

//...

/**
 * idt_setup_apic_and_irq_gates - Setup APIC/SMP and normal interrupt gates
 */
void __init idt_setup_apic_and_irq_gates(void)
{
	int i = FIRST_EXTERNAL_VECTOR;
	void *entry;

	idt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), true);

	for_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {
		entry = irq_entries_start + IDT_ALIGN * (i - FIRST_EXTERNAL_VECTOR);
		set_intr_gate(i, entry);
	}

#ifdef CONFIG_X86_LOCAL_APIC
	for_each_clear_bit_from(i, system_vectors, NR_VECTORS) {
		/*
		 * Don't set the non assigned system vectors in the
		 * system_vectors bitmap. Otherwise they show up in
		 * /proc/interrupts.
		 */
		entry = spurious_entries_start + IDT_ALIGN * (i - FIRST_SYSTEM_VECTOR);
		set_intr_gate(i, entry);
	}
#endif
	/* Map IDT into CPU entry area and reload it. */
	idt_map_in_cea();
	load_idt(&idt_descr);

	/* Make the IDT table read only */
	set_memory_ro((unsigned long)&idt_table, 1);

	idt_setup_done = true;
}
----

- 通过irq_entries_start

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/idtentry.h
----
SYM_CODE_START(irq_entries_start)
    vector=FIRST_EXTERNAL_VECTOR
    .rept NR_EXTERNAL_VECTORS
	UNWIND_HINT_IRET_REGS
0 :
	ENDBR
	.byte	0x6a, vector
	jmp	asm_common_interrupt
	/* Ensure that the above is IDT_ALIGN bytes max */
	.fill 0b + IDT_ALIGN - ., 1, 0xcc
	vector = vector+1
    .endr
SYM_CODE_END(irq_entries_start)

//...

/**
 * DEFINE_IDTENTRY_IRQ - Emit code for device interrupt IDT entry points
 * @func:	Function name of the entry point
 *
 * The vector number is pushed by the low level entry stub and handed
 * to the function as error_code argument which needs to be truncated
 * to an u8 because the push is sign extending.
 *
 * irq_enter/exit_rcu() are invoked before the function body and the
 * KVM L1D flush request is set. Stack switching to the interrupt stack
 * has to be done in the function body if necessary.
 */
#define DEFINE_IDTENTRY_IRQ(func)					\
static void __##func(struct pt_regs *regs, u32 vector);			\
									\
__visible noinstr void func(struct pt_regs *regs,			\
			    unsigned long error_code)			\
{									\
	irqentry_state_t state = irqentry_enter(regs);			\
	u32 vector = (u32)(u8)error_code;				\
									\
	instrumentation_begin();					\
	kvm_set_cpu_l1tf_flush_l1d();					\
	run_irq_on_irqstack_cond(__##func, regs, vector);		\
	instrumentation_end();						\
	irqentry_exit(regs, state);					\
}									\
									\
static noinline void __##func(struct pt_regs *regs, u32 vector)
----

对于外设中断为什么要采取这样的处理方式呢？有两个原因，1是因为外设中断和中断控制器相关联，这样可以统一处理与中断控制器相关的事物，2是因为外设中断的驱动执行比较晚，有些设备还是可以热插拔的，直接把它们放到中断向量表上比较麻烦。有个irq_desc这个中间层，设备驱动后面只需要调用函数request_irq来注册ISR，只处理与设备相关的业务就可以了，而不用考虑和中断控制器硬件相关的处理。

驱动程序使用request_irq接口来注册自己的ISR，ISR就是运行在硬中断的，参数handler代表的就是ISR。request_irq又调用request_threaded_irq来实现自己。request_threaded_irq是用来创建中断线程的函数接口，其中有两个参数handler、thread_fn，都是函数指针，handler代表的是ISR，是进行中断预处理的，thread_fn代表的是要创建的中断线程的入口函数，是进行中断后处理的。

- 注册中断
request_irq() -> request_threaded_irqz()
https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

- 卸载中断
free_irq() -> __free_irq()
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

- irq_desc
struct irq_desc: https://elixir.bootlin.com/linux/latest/source/include/linux/irqdesc.h

- irqaction
struct irqaction: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/hw_irq.h
----
extern char irq_entries_start[];
extern char spurious_entries_start[];
//...
typedef struct irq_desc* vector_irq_t[NR_VECTORS];
DECLARE_PER_CPU(vector_irq_t, vector_irq);
----

总结一下外设中断的处理方式:
外设中断的向量项都被统一设置到common_interrupt()函数。
common_interrupt()会根据irq参数去一个类型为irq_desc的vector_irq数组中寻找其对应的irq_desc，并用irq_desc的handle_irq来处理这个中断。
vector_irq数组是在系统启动时初始化的，每个irq_desc的handle_irq都是中断控制器初始化时设置的，handle_irq的处理是和中断控制器密切相关的。
具体的硬件驱动会通过request_irq接口来注册ISR，每个ISR都会生成一个irqaction，这个irqaction会挂在irq_desc的链表上, 当中断发生时handle_irq就可以去执行与irq相对应的每个ISR了。

=== 软中断(SoftIRQ)
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----
/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
   frequency threaded job scheduling. For almost all the purposes
   tasklets are more than enough. F.e. all serial device BHs et
   al. should be converted to tasklets, not to softirqs.
 */
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};

//...

struct softirq_action
{
	void	(*action)(struct softirq_action *);
};
----

软中断注册

    open_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断处理

    raise_softirq() 软中断激活: https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
    
    __do_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断守护进程

    ksoftirqd内核线程: 检查没有被__do_softirq函数执行的softirq，每个CPU都有一个ksoftirqd线程
    static void run_ksoftirqd(unsigned int cpu): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        __do_softirq()

应用

    例如网络收发softirq:
    net_dev_init: https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
    open_softirq(NET_TX_SOFTIRQ, net_tx_action);
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    struct softnet_data: https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h

=== tasklet
tasklet VS. softirq
https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets

struct tasklet_struct: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

tasklet建立在HI_SOFTIRQ和TASKLET_SOFTIRQ两个softirq的基础之上:

    softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        open_softirq(TASKLET_SOFTIRQ, tasklet_action);
        open_softirq(HI_SOFTIRQ, tasklet_hi_action);

tasklet_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
tasklet_hi_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

=== 中断线程(irq_thread)
softirq和tasklet虽然不会禁用中断，提高了系统对中断的响应性，但是softirq的执行优先级还是比进程的优先级高，其实一些不那么重要的任务完全可以放到进程里执行，和普通进程共同竞争CPU。而且软中断里不能调用会阻塞、休眠的函数，这不利于软中断函数的编写，因此可以把中断处理任务中的与硬件无关并且不太紧急的部分放到进程里面来做，中断线程和工作队列等方式正是基于这一思想。

request_threaded_irq(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c
setup_irq_thread(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

=== 等待队列&完成量&工作队列
vs. tasklet
tasklet不允许睡眠，等待队列等机制则允许

==== 等待队列
- 数据结构
struct wait_queue_head: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 使进程睡眠
add_wait_queue系列函数: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h
___wait_event宏: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 唤醒进程
__wake_up系列函数: https://elixir.bootlin.com/linux/latest/source/kernel/sched/wait.c

==== 完成量
基于简单等待队列(swait_queue)

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/completion.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/completion.c

struct swait_queue_head {
	raw_spinlock_t		lock;
	struct list_head	task_list;
};
struct swait_queue {
	struct task_struct	*task;
	struct list_head	task_list;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/swait.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/swait.c

==== 工作队列
https://elixir.bootlin.com/linux/latest/source/kernel/workqueue.c
可延迟函数运行在中断上下文中，工作队列的函数运行在进程上下文中
工作队列的函数是有内核线程来执行的: static int worker_thread(void *__worker)

=== 中断禁用
Q: 哪些情况需要禁用中断
A: 在某些临界区，必须禁用中断
https://www.quora.com/Why-do-you-need-software-to-disable-interrupt-Microcontrollers

- 禁用硬中断 

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/irqflags.h
----
#define local_irq_enable()	do { raw_local_irq_enable(); } while (0)
#define local_irq_disable()	do { raw_local_irq_disable(); } while (0)
#define local_irq_save(flags)	do { raw_local_irq_save(flags); } while (0)
#define local_irq_restore(flags) do { raw_local_irq_restore(flags); } while (0)
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irqflags.h
----
static __always_inline void native_irq_disable(void)
{
	asm volatile("cli": : :"memory");
}

static __always_inline void native_irq_enable(void)
{
	asm volatile("sti": : :"memory");
}
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----
extern void disable_irq_nosync(unsigned int irq);
extern bool disable_hardirq(unsigned int irq);
extern void disable_irq(unsigned int irq);
extern void disable_percpu_irq(unsigned int irq);
extern void enable_irq(unsigned int irq);
extern void enable_percpu_irq(unsigned int irq, unsigned int type);
extern bool irq_percpu_is_enabled(unsigned int irq);
extern void irq_wake_thread(unsigned int irq, void *dev_id);

extern void disable_nmi_nosync(unsigned int irq);
extern void disable_percpu_nmi(unsigned int irq);
extern void enable_nmi(unsigned int irq);
extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
extern int prepare_percpu_nmi(unsigned int irq);
extern void teardown_percpu_nmi(unsigned int irq);
----

- 禁用软中断

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/bottom_half.h
----
static inline void local_bh_disable(void)
{
	__local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
}

extern void _local_bh_enable(void);
extern void __local_bh_enable_ip(unsigned long ip, unsigned int cnt);

static inline void local_bh_enable_ip(unsigned long ip)
{
	__local_bh_enable_ip(ip, SOFTIRQ_DISABLE_OFFSET);
}

static inline void local_bh_enable(void)
{
	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
}
----

注意:
对于硬件中断，可以在一个CPU上禁用所有硬件中断，也可以在所有CPU上禁用某个硬件中断，但是不能在所有CPU上同时禁用所有硬件中断。
对于软中断，只能禁用本地CPU的软中断，而且是整体禁用，不能只禁用某一类型的软中断。不包括中断线程和工作队列。

=== 中断电流处理
边沿触发
水平触发

=== SMP
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/io_apic.h

setup_local_APIC(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/apic/apic.c

=== 亲和性
https://www.kernel.org/doc/Documentation/IRQ-affinity.txt

=== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/asm.s
https://elixir.bootlin.com/linux/0.12/source/kernel/traps.c
asm.s实现了大部分硬件异常所引起的中断服务过程的汇编程序部分
traps.c实现了asm.s中断处理过程中调用的C函数部分
另外几个硬件中断处理程序在文件sys_call.s和mm/page.s中实现。

=== 参考
Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A:System Programming Guide, Part 1 (CHAPTER 6, INTERRUPT AND EXCEPTION HANDLING and CHAPTER 10, ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)
https://wiki.osdev.org/Interrupt
https://www.kernel.org/doc/html/v4.19/core-api/genericirq.html
https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
https://elixir.bootlin.com/linux/latest/source/Documentation/x86/entry_64.rst
https://www.zhihu.com/question/27923521
https://zhuanlan.zhihu.com/p/540897981
https://os.phil-opp.com/cpu-exceptions/
http://www.wowotech.net/sort/irq_subsystem
https://www.binss.me/blog/interrupt-and-exception/
https://www.cnblogs.com/wsg1100/p/14055863.html
https://stackoverflow.com/questions/40583848/differences-among-various-interrupts-sci-smi-nmi-and-normal-interrupt
https://www.kernel.org/doc/Documentation/x86/kernel-stacks
