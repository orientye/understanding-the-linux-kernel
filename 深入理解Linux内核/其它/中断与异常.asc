:toc:
:toclevels: 5
:hardbreaks-option:

== 中断与异常

=== 概念
▪ 中断

    CPU在执行指令时，收到某个中断信号后转而去执行另外一段代码(中断例程)，之后又返回到原执行流中继续执行的机制。

▪ 中断的意义

    中断是CPU对系统发生的某个事件作出的一种反应，
    这个事件可以是来自外设，例如网卡收到了网络包
    也可以来自CPU自身:运行过程中遇到了异常或某个中断指令，例如缺页异常
    也可以来自其它的CPU，例如SMP系统中一个CPU给另外一个CPU发送IPI(处理器间中断)
    在kernel2.5之前，系统调用也是通过中断来实现的

▪ 中断与异常

    狭义的中断通常指硬件中断，外部中断
    狭义的异常通常指软件中断，内部中断, 分为trap, fault, abort
    (参考Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3, 6.5)
    广义的异常通常包括interrupt, trap, fault, abort (参考CSAPP 3rd, 8.1)
    
    类别         原因           异步/同步        返回行为                示例
    中断    来自IO设备的信号       异步        总是返回到下一条指令        键盘响应
    陷阱    有意的异常            同步        总是返回到下一条指令        系统调用
    故障    潜在可恢复的错误       同步        可能返回到当前指令          缺页异常
    终止    为不可恢复的错误       同步        不会返回                  硬件错误
    
    实际上，不同的语境下可能有不同的含义

▪ 中断与系统调用
    link:./系统调用.asc#概念[系统调用vs.中断]

▪ 硬件中断(Hardware Interrupt)

    由系统自身和与之连接的外设自动产生
    例如PC上的8259A类似的硬件中断控制芯片、ARM中断控制器发出的中断
    Q: 键盘如何响应的
    A: https://wiki.osdev.org/Interrupt#From_the_keyboard.27s_perspective

▪ 软件中断(Software Interrupt)

    由软件中断指令产生
    EFLAGS中的IF标志不能够屏蔽使用INT指令从软件中产生的中断

▪ 软中断(SoftIRQ)

    用于实现内核中的延期操作
    ps -aux | grep softirq
    cat /proc/softirqs | column -t | cut -c -160

▪ 同步中断

    由CPU自身产生，针对当前执行的程序
    Intel微处理器将同步中断和异步中断称为分别称为异常(exceptions)和中断(interrupts)

▪ 异步中断

    由外部设备产生，可能发生在任何时间

▪ 外部中断与内部中断

    内部和外部是相当于CPU来说的
    一般来说，外部中断又可以分为可屏蔽中断与不可屏蔽中断

▪ 可屏蔽中断(maskable interrupt)与不可屏蔽中断(nomaskable interrupt)

    不可屏蔽中断cpu必须无条件响应, 例如电源掉电, 不可恢复的硬件错误，调试等
    可屏蔽中断cpu可以响应，也可以不响应，例如打印机中断，网卡中断等
    CPU一般设置两根中断请求输入线: 可屏蔽中断请求INTR(interrupt require)和不可屏蔽中断请求NMI(non-maskable interrupt)

▪ 中断与信号

    https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison

▪ BIOS中断 DOS中断 LINUX中断

▪ 中断控制器

    多个外部中断源共享中断资源，必须解决相应的一些问题:
    例如CPU芯片上只有一个INTR输入端，多个中断源如何与INTR连接、中断矢量如何区别、各中断源的优先级如何判定等。
    常见的中断控制器:
        Intel 8259A(适合单CPU, 未能充分挖掘SMP体系结构的并行性, 因此被intel新的APIC来取代)
        APIC: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
            APIC分为两个部分:
                Local APIC(NR_CPU个)，每个CPU都连接一个Local APIC；
                IO APIC(一个)，所有的外设都连接到这个IO APIC上，IO APIC连接到所有的Local APIC上。
                当外设向IO APIC发送中断时，IO APIC会把中断信号转发给某个Local APIC。
                有些Per CPU的设备是直接连接到Local APIC的，可以通过Local APIC直接给自己的CPU发送中断。
        ARM GIC(Generic Interrupt Controller)

▪ 相关命令

    cat /proc/interrupts
    ls /proc/irq
    cat /proc/softirqs

=== 中断
==== 数据结构
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/processor.h
/* Per CPU interrupt stacks */
struct irq_stack {
	char		stack[IRQ_STACK_SIZE];
} __aligned(IRQ_STACK_SIZE);

https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h
#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
#define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)

struct irq_desc: https://elixir.bootlin.com/linux/latest/source/include/linux/irqdesc.h

struct irqaction: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

中断向量: https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irq_vectors.h

==== 状态
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

/*
 * Macros to retrieve the current execution context:
 *
 * in_nmi()		- We're in NMI context
 * in_hardirq()		- We're in hard IRQ context
 * in_serving_softirq()	- We're in softirq context
 * in_task()		- We're in task context
 */
#define in_nmi()		(nmi_count())
#define in_hardirq()		(hardirq_count())
#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
#define in_task()		(!(in_nmi() | in_hardirq() | in_serving_softirq()))

/*
 * The following macros are deprecated and should not be used in new code:
 * in_irq()       - Obsolete version of in_hardirq()
 * in_softirq()   - We have BH disabled, or are processing softirqs
 * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
 */
#define in_irq()		(hardirq_count())
#define in_softirq()		(softirq_count())
#define in_interrupt()		(irq_count())

----

==== 初始化

===== 中断向量表(IDT)初始化

    start_kernel(): https://elixir.bootlin.com/linux/latest/source/init/main.c
        trap_init(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/traps.c
            主要是对系统保留的中断向量的初始化
            idt_setup_traps(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
        init_IRQ(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/irqinit.c
            主要是用于外设的中断
        softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        arch_call_rest_init(): https://elixir.bootlin.com/linux/latest/source/init/main.c
            rest_init()
                kernel_init()
                    kernel_init_freeable()
                        do_basic_setup()
                            init_irq_proc(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/proc.c

===== 中断请求队列初始化
中断向量表内容从0~0x20均为CPU内部产生的中断，包括除0、页面错等。从0x20开始均为用于外部设备的通用中断（包括中断请求队列），但是0x80系统调用除外。这些表项的内容都是在中断向量表初始化的时候进行设置。

===== 用户中断请求注册
request_irq() -> request_threaded_irqz()
https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

===== 卸载中断
free_irq() -> __free_irq()
https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

==== 中断处理

===== 进入和退出
进入: 建立环境
退出: 还原状态
如果发生中断时位于用户态，则进入时需要从用户态切换到内核态，退出时需要从内核态切换到用户态
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S

在x86上，中断需通过IDT中的表项分发:
若通过Interrupt Gate进入中断处理例程，则EFLAGS的IF（Interrupt Flag）会被清零（相当于执行CLI指令），从而禁用中断，直到执行IRET指令从中断处理例程中返回时，才会重置IF;
若通过的是Trap Gate，则不会对IF作任何操作。

https://www.kernel.org/doc/html/v5.5/x86/entry_64.html

5.8之前:
ret_from_intr: https://elixir.bootlin.com/linux/v5.7.19/source/arch/x86/entry/entry_64.S

===== 中断处理程序
中断处理程序在核心态下执行

关键操作必须在中断发生后立即执行，否则无法维持系统的稳定性与正确运作，在此期间，必须禁用其它中断。
非关键操作也应该尽快执行，但允许启用中断。
可延期操作不是特别重要，不必在中断处理程序中实现。

按照是否延迟处理分为两种方式:

1.立即完全执行:

    适用于简单时间消耗短的中断。

2.立即执行+延迟执行:

    适用于相对比较耗时的中断。
    中断的下半部不再屏蔽中断，因此提升了系统的整体性能。
    上半部: 屏蔽中断，叫做硬中断(https://elixir.bootlin.com/linux/latest/source/include/linux/hardirq.h)，处理与硬件相关的紧急事物，立即执行。
    下半部: 不再屏蔽中断，叫做软中断，处理剩下的不太紧急的事物，延迟执行。
    下半部的处理方式: softirq(软中断)、tasklet(微任务)、workqueue(工作队列)、threaded_irq(中断线程)。

https://elixir.bootlin.com/linux/latest/source/kernel/irq/handle.c

.Q: 中断能嵌套吗?
[%collapsible]
====
早期中断能嵌套, Linux2.6.35之后取消了中断的嵌套。
老版本的内核可以在申请中断时设置标记IRQF_DISABLED以避免中断嵌套
IRQF_DISABLED在2010年已经作废: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc

硬件中断的前半部分是硬中断，后半部分是软中断，硬中断中不能再嵌套硬中断了，但是软中断中可以嵌套硬中断。

软中断是不能独立触发的，必须是硬中断触发软中断。如果第一个硬中断执行完成了，然后在软中断的执行过程中又发生了硬中断，第二个硬中断还没执行完的时候在执行过程中的时候又发生了NMI中断。这样就会发生四个不同等级的执行流一一嵌套的情况，这也是队列自旋锁的锁节点为啥要乘以4的原因。
====

.Q: 中断处理函数注意事项?
[%collapsible]
====
    中断函数代码应尽量简洁，避免大量复杂冗长的代码
    中断函数不能进行参数传递
    中断函数没有返回值
    在任何情况下都不能直接调用中断函数
    在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器不允许在ISR中做浮点运算
    尽量避免在中断函数内调用其他自定义函数，数学函数等
    如果在中断函数中调用了其它函数，则被调用函数所使用的寄存器必须与中断函数相同
    被调函数最好设置为可重入的
    中断函数最好写在文件的尾部，并且禁止使用extern存储类型说明，防止其它程序调用
====

==== 中断电流处理
边沿触发
水平触发

==== 中断禁用
Q: 哪些情况需要禁用中断
A: 在某些临界区，必须禁用中断
https://www.quora.com/Why-do-you-need-software-to-disable-interrupt-Microcontrollers

- 禁用硬中断 

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/irqflags.h
----

#define local_irq_enable()	do { raw_local_irq_enable(); } while (0)
#define local_irq_disable()	do { raw_local_irq_disable(); } while (0)
#define local_irq_save(flags)	do { raw_local_irq_save(flags); } while (0)
#define local_irq_restore(flags) do { raw_local_irq_restore(flags); } while (0)

----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/irqflags.h
----

static __always_inline void native_irq_disable(void)
{
	asm volatile("cli": : :"memory");
}

static __always_inline void native_irq_enable(void)
{
	asm volatile("sti": : :"memory");
}

----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

extern void disable_irq_nosync(unsigned int irq);
extern bool disable_hardirq(unsigned int irq);
extern void disable_irq(unsigned int irq);
extern void disable_percpu_irq(unsigned int irq);
extern void enable_irq(unsigned int irq);
extern void enable_percpu_irq(unsigned int irq, unsigned int type);
extern bool irq_percpu_is_enabled(unsigned int irq);
extern void irq_wake_thread(unsigned int irq, void *dev_id);

extern void disable_nmi_nosync(unsigned int irq);
extern void disable_percpu_nmi(unsigned int irq);
extern void enable_nmi(unsigned int irq);
extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
extern int prepare_percpu_nmi(unsigned int irq);
extern void teardown_percpu_nmi(unsigned int irq);

----

- 禁用软中断

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/bottom_half.h
----

static inline void local_bh_disable(void)
{
	__local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
}

extern void _local_bh_enable(void);
extern void __local_bh_enable_ip(unsigned long ip, unsigned int cnt);

static inline void local_bh_enable_ip(unsigned long ip)
{
	__local_bh_enable_ip(ip, SOFTIRQ_DISABLE_OFFSET);
}

static inline void local_bh_enable(void)
{
	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
}

----

注意:
对于硬件中断，可以在一个CPU上禁用所有硬件中断，也可以在所有CPU上禁用某个硬件中断，但是不能在所有CPU上同时禁用所有硬件中断。
对于软中断，只能禁用本地CPU的软中断，而且是整体禁用，不能只禁用某一类型的软中断。不包括中断线程和工作队列。

==== 硬中断(HardIRQ)

==== 软中断(SoftIRQ)

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h
----

/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
   frequency threaded job scheduling. For almost all the purposes
   tasklets are more than enough. F.e. all serial device BHs et
   al. should be converted to tasklets, not to softirqs.
 */
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	IRQ_POLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};

//...

struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

----

软中断注册

    open_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断处理

    raise_softirq() 软中断激活: https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
    
    __do_softirq(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

软中断守护进程

    ksoftirqd内核线程: 检查没有被__do_softirq函数执行的softirq，每个CPU都有一个ksoftirqd线程
    static void run_ksoftirqd(unsigned int cpu): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        __do_softirq()

应用

    例如网络收发softirq:
    net_dev_init: https://elixir.bootlin.com/linux/latest/source/net/core/dev.c
    open_softirq(NET_TX_SOFTIRQ, net_tx_action);
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    struct softnet_data: https://elixir.bootlin.com/linux/latest/source/include/linux/netdevice.h

==== tasklet
tasklet VS. softirq
https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets

struct tasklet_struct: https://elixir.bootlin.com/linux/latest/source/include/linux/interrupt.h

tasklet建立在HI_SOFTIRQ和TASKLET_SOFTIRQ两个softirq的基础之上:

    softirq_init(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
        open_softirq(TASKLET_SOFTIRQ, tasklet_action);
        open_softirq(HI_SOFTIRQ, tasklet_hi_action);

tasklet_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c
tasklet_hi_action(): https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

==== 中断线程(irq_thread)
softirq和tasklet虽然不会禁用中断，提高了系统对中断的响应性，但是softirq的执行优先级还是比进程的优先级高，其实一些不那么重要的任务完全可以放到进程里执行，和普通进程共同竞争CPU。而且软中断里不能调用会阻塞、休眠的函数，这不利于软中断函数的编写，因此可以把中断处理任务中的与硬件无关并且不太紧急的部分放到进程里面来做，中断线程和工作队列等方式正是基于这一思想。

request_threaded_irq(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c
setup_irq_thread(): https://elixir.bootlin.com/linux/latest/source/kernel/irq/manage.c

==== 等待队列&完成量&工作队列
vs. tasklet
tasklet不允许睡眠，等待队列等机制则允许

===== 等待队列
- 数据结构
struct wait_queue_head: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 使进程睡眠
add_wait_queue系列函数: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h
___wait_event宏: https://elixir.bootlin.com/linux/latest/source/include/linux/wait.h

- 唤醒进程
__wake_up系列函数: https://elixir.bootlin.com/linux/latest/source/kernel/sched/wait.c

===== 完成量
基于简单等待队列(swait_queue)

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/completion.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/completion.c

struct swait_queue_head {
	raw_spinlock_t		lock;
	struct list_head	task_list;
};
struct swait_queue {
	struct task_struct	*task;
	struct list_head	task_list;
};
https://elixir.bootlin.com/linux/latest/source/include/linux/swait.h
https://elixir.bootlin.com/linux/latest/source/kernel/sched/swait.c

===== 工作队列
https://elixir.bootlin.com/linux/latest/source/kernel/workqueue.c
可延迟函数运行在中断上下文中，工作队列的函数运行在进程上下文中
工作队列的函数是有内核线程来执行的: static int worker_thread(void *__worker)

==== SMP
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/io_apic.h

setup_local_APIC(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/apic/apic.c

==== 亲和性
https://www.kernel.org/doc/Documentation/IRQ-affinity.txt

==== 参考
https://www.kernel.org/doc/html/v4.19/core-api/genericirq.html
https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
https://elixir.bootlin.com/linux/latest/source/Documentation/x86/entry_64.rst
https://www.zhihu.com/question/27923521
https://zhuanlan.zhihu.com/p/540897981

=== 异常及异常处理
==== 种类
https://wiki.osdev.org/Exceptions

==== 初始化
https://www.kernel.org/doc/html/latest/x86/exception-tables.html
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/extable.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/extable.c

https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/cpu_entry_area.h

#define EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER)
#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h

==== 进入与退出

irqentry_enter_from_user_mode(struct pt_regs *regs)
irqentry_exit_to_user_mode(struct pt_regs *regs)
https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

irqentry_enter(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

在中断返回之前，内核会检查：
调度器是否应该选择一个新进程代替旧的进程
是否有信号必须投递到原进程

irqentry_exit(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c
例如arch/x86/kernel/traps.c  arch/x86/mm/fault.c会调用

5.5之前:
ret_from_exception: https://elixir.bootlin.com/linux/v5.4.215/source/arch/x86/entry/entry_32.S

==== 处理
idt_setup_from_table，并没有调用load_idt。主要是数组def_idts里面包含了大部分的CPU异常处理。
但是没缺页异常，缺页异常是单独设置: 
idt_setup_early_pf(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/idt.c
----

/*
 * Early traps running on the DEFAULT_STACK because the other interrupt
 * stacks work only after cpu_init().
 */
static const __initconst struct idt_data early_idts[] = {
	INTG(X86_TRAP_DB,		asm_exc_debug),
	SYSG(X86_TRAP_BP,		asm_exc_int3),

#ifdef CONFIG_X86_32
	/*
	 * Not possible on 64-bit. See idt_setup_early_pf() for details.
	 */
	INTG(X86_TRAP_PF,		asm_exc_page_fault),
#endif
#ifdef CONFIG_INTEL_TDX_GUEST
	INTG(X86_TRAP_VE,		asm_exc_virtualization_exception),
#endif
};

/*
 * The default IDT entries which are set up in trap_init() before
 * cpu_init() is invoked. Interrupt stacks cannot be used at that point and
 * the traps which use them are reinitialized with IST after cpu_init() has
 * set up TSS.
 */
static const __initconst struct idt_data def_idts[] = {
	INTG(X86_TRAP_DE,		asm_exc_divide_error),
	ISTG(X86_TRAP_NMI,		asm_exc_nmi, IST_INDEX_NMI),
	INTG(X86_TRAP_BR,		asm_exc_bounds),
	INTG(X86_TRAP_UD,		asm_exc_invalid_op),
	INTG(X86_TRAP_NM,		asm_exc_device_not_available),
	INTG(X86_TRAP_OLD_MF,		asm_exc_coproc_segment_overrun),
	INTG(X86_TRAP_TS,		asm_exc_invalid_tss),
	INTG(X86_TRAP_NP,		asm_exc_segment_not_present),
	INTG(X86_TRAP_SS,		asm_exc_stack_segment),
	INTG(X86_TRAP_GP,		asm_exc_general_protection),
	INTG(X86_TRAP_SPURIOUS,		asm_exc_spurious_interrupt_bug),
	INTG(X86_TRAP_MF,		asm_exc_coprocessor_error),
	INTG(X86_TRAP_AC,		asm_exc_alignment_check),
	INTG(X86_TRAP_XF,		asm_exc_simd_coprocessor_error),

#ifdef CONFIG_X86_32
	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
#else
	ISTG(X86_TRAP_DF,		asm_exc_double_fault, IST_INDEX_DF),
#endif
	ISTG(X86_TRAP_DB,		asm_exc_debug, IST_INDEX_DB),

#ifdef CONFIG_X86_MCE
	ISTG(X86_TRAP_MC,		asm_exc_machine_check, IST_INDEX_MCE),
#endif

#ifdef CONFIG_X86_KERNEL_IBT
	INTG(X86_TRAP_CP,		asm_exc_control_protection),
#endif

#ifdef CONFIG_AMD_MEM_ENCRYPT
	ISTG(X86_TRAP_VC,		asm_exc_vmm_communication, IST_INDEX_VC),
#endif

	SYSG(X86_TRAP_OF,		asm_exc_overflow),
#if defined(CONFIG_IA32_EMULATION)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
#elif defined(CONFIG_X86_32)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
#endif
};

//...

/*
 * Early traps running on the DEFAULT_STACK because the other interrupt
 * stacks work only after cpu_init().
 */
static const __initconst struct idt_data early_pf_idts[] = {
	INTG(X86_TRAP_PF,		asm_exc_page_fault),
};

----

=== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/asm.s
https://elixir.bootlin.com/linux/0.12/source/kernel/traps.c
asm.s实现了大部分硬件异常所引起的中断服务过程的汇编程序部分
traps.c实现了asm.s中断处理过程中调用的C函数部分
另外几个硬件中断处理程序在文件sys_call.s和mm/page.s中实现。

==== 参考
Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A:System Programming Guide, Part 1 (CHAPTER 6, INTERRUPT AND EXCEPTION HANDLING and CHAPTER 10, ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)
https://wiki.osdev.org/Interrupt
https://os.phil-opp.com/cpu-exceptions/
https://zhuanlan.zhihu.com/p/540897981
http://www.wowotech.net/sort/irq_subsystem
https://www.binss.me/blog/interrupt-and-exception/
https://www.cnblogs.com/wsg1100/p/14055863.html
https://stackoverflow.com/questions/40583848/differences-among-various-interrupts-sci-smi-nmi-and-normal-interrupt
https://www.kernel.org/doc/Documentation/x86/kernel-stacks
