:toc:
:toclevels: 5
:hardbreaks-option:

== 锁

=== 并发
内核中可能造成并发执行的原因:

    中断
    内核抢占
    睡眠及调度
    多处理器

=== 原子操作

参考: https://lwn.net/Kernel/Index/#Atomic_operations
参考: https://lwn.net/Kernel/Index/#atomic_t
参考: https://lwn.net/Kernel/Index/#C11_atomic_operations
参考: https://lwn.net/Kernel/Index/#Atomic_spinlocks
参考: https://lwn.net/Kernel/Index/#Atomic_IO_operations

=== 自旋锁

==== 概念
Q: 什么情况下使用

Q: 为什么要关闭中断?
A: https://stackoverflow.com/questions/37146637/why-is-interrupt-disabled-between-spin-lock-and-spin-unlock-in-linux

Q: 为什么要关闭抢占？

Q: 为什么自旋锁保护的代码不能进入睡眠状态？

spin_lock()与spin_unlock() — 禁止内核抢占
spin_lock_irq()与spin_unlock_irq() — 禁止内核抢占并屏蔽中断
spin_lock_irqsave()与spin_unlock_irqrestore() — 禁止内核抢占并屏蔽中断，事先保存中断屏蔽位并事后恢复原状

==== raw spinlock

==== ticket spinlock
https://en.wikipedia.org/wiki/Ticket_lock
主要解决公平性

==== mcs spinlock
per-CPU structure, 在cache-line上效率更高
https://lwn.net/Articles/590243/

==== queue spinlock
基于mcs spinlock的思想但解决了mcs spinlock占用空间大的问题
https://lwn.net/Articles/561775/
https://0xax.gitbooks.io/linux-insides/content/SyncPrim/linux-sync-2.html

=== 信号量

==== 实现
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/semaphore.h
----
/* Please don't access any members of this structure directly */
struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};

//...

extern void down(struct semaphore *sem); //acquire the semaphore
extern int __must_check down_interruptible(struct semaphore *sem);
extern int __must_check down_killable(struct semaphore *sem);
extern int __must_check down_trylock(struct semaphore *sem);
extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
extern void up(struct semaphore *sem); //release the semaphore
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/kernel/locking/semaphore.c
----
/**
 * down - acquire the semaphore
 * @sem: the semaphore to be acquired
 *
 * Acquires the semaphore.  If no more tasks are allowed to acquire the
 * semaphore, calling this function will put the task to sleep until the
 * semaphore is released.
 *
 * Use of this function is deprecated, please use down_interruptible() or
 * down_killable() instead.
 */
void down(struct semaphore *sem)
{
	unsigned long flags;

	might_sleep();
	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		__down(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}

/**
 * up - release the semaphore
 * @sem: the semaphore to release
 *
 * Release the semaphore.  Unlike mutexes, up() may be called from any
 * context and even by tasks which have never called down().
 */
void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}
----

==== 参考
https://lwn.net/Kernel/Index/#Semaphores

=== Seqlock顺序锁
v2.6引入, 对写友好, 写总能成功。

https://elixir.bootlin.com/linux/latest/source/include/linux/seqlock.h

sequence number的初始值是一个偶数。
writer持有spinlock时，sequence number的值将是一个奇数(sequence number+1), 释放后则又变成偶数(sequence number+1)。
reader在读取一个共享变量之前, 需要先读取一下sequence number的值，如果为奇数，说明有writer正在修改这个变量，需要等待，直到sequence number变为偶数，才可以开始读取变量。
reader可以随时读, 但可能需要多读几次。
writer只会被其他writer造成饥饿，不再被reader造成饥饿。

=== RCU
主要适用于下面的场景:

    ▪ RCU只能保护动态分配的数据结构, 并且必须是通过指针访问该数据结构
    ▪ 受RCU保护的临界区内不能sleep(SRCU?)
    ▪ 读写不对称，对writer的性能没有特别要求, 但是reader性能要求极高
    ▪ reader对新旧数据不敏感

==== 参考
https://www.kernel.org/doc/html/latest/RCU/index.html
https://lwn.net/Kernel/Index/#Read-copy-update
https://hackmd.io/@sysprog/linux-rcu?type=view

=== 内存屏障
https://elixir.bootlin.com/linux/latest/source/include/asm-generic/barrier.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/barrier.h
https://elixir.bootlin.com/linux/latest/source/arch/arm/include/asm/barrier.h

参考: https://lwn.net/Kernel/Index/#Memory_barriers
参考: https://mp.weixin.qq.com/s?__biz=MzAxMDM0NjExNA==&mid=2247487950&idx=1&sn=c6cb416efc2831c5666a5ae9a205dcf3&chksm=9b509a23ac2713352a6998b9ff34f29b02cc57a0cfe62bcc13a8aa3583c5e78d2d038aacf17c&mpshare=1&scene=1&srcid=0827lWWERv8vkNak5sANCSAc&sharer_sharetime=1667631485956&sharer_shareid=3d769dc0d221507247ffa710c89a2772&exportkey=n_ChQIAhIQ8I4w6FfIvqlzaen82GNKVxKZAgIE97dBBAEAAAAAAFWOLeiWGmcAAAAOpnltbLcz9gKNyK89dVj0hC%2FkJy43MLPqIOkmygOzvgdnTEDr65XdDo6dZ7SwCefoAImebvkCfI61eSTYahvaCP06FEy0n7UJvX9u%2FYIz1JS9%2BCCA7d5%2FKyMAjXkuHHt86AbasiIxztU5VUIa9lMcGL9zwaT6JlgIkO%2FIk6YccnxLN2UKLxcaBqJJeySCIuPYpjDSxg56oh3IgIsMMvIhwN96Lxu3LjEzNZIhOyr%2B88hqFYIZTFtAul%2BgftiyMUHcrW3Jhlg8obgZBYXDR1BC%2BgtBQQhATMXarg893oVKs7fJNkN69Ckjn23rqVgibQjnuMaNadco8Fw2bkVzDaCUkU2Z&acctmode=0&pass_ticket=QA7RhEsMegR3%2FRIcRqL6%2FVpdMlpaht0VwPJpMgvvdoPO%2FeAeWFcoxw0fS41vu6Qx&wx_header=0#rd

=== 读写锁
也叫读写自旋锁
写饥饿问题
现在的内核开发已经不建议再使用rwlock了, 之前使用到的rwlock也在逐渐被移除或者替换为普通的spinlock或者RCU

=== 大内核锁
BKL锁已经被淘汰(v2.6.39)

参考: https://lwn.net/Kernel/Index/#Big_kernel_lock
参考: https://en.wikipedia.org/wiki/Giant_lock

=== 互斥量
当无法获得锁的时候，spinlock原地自旋，mutex挂起当前线程，进入阻塞状态。因此，mutex无法在中断上下文中使用。

可以看作是0-1信号量

https://elixir.bootlin.com/linux/latest/source/include/linux/mutex.h

实时互斥锁:
https://elixir.bootlin.com/linux/latest/source/include/linux/rtmutex.h

参考: https://github.com/torvalds/linux/blob/master/Documentation/locking/rt-mutex.rst
参考: https://github.com/torvalds/linux/blob/master/Documentation/locking/rt-mutex-design.rst

=== per-cpu变量
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/percpu.h

参考: https://lwn.net/Kernel/Index/#Per-CPU_variables

=== volatile

参考: https://lwn.net/Kernel/Index/#volatile

=== 参考
https://github.com/torvalds/linux/tree/master/Documentation/locking
https://docs.kernel.org/locking/index.html
https://lwn.net/Kernel/Index/#Locking_mechanisms
https://lwn.net/Kernel/Index/#lock_kernel
https://lwn.net/Kernel/Index/#Lockless_algorithms
https://lwn.net/Kernel/Index/#Race_conditions