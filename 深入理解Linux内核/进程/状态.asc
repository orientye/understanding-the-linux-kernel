:toc:
:toclevels: 5
:hardbreaks-option:

== 状态

=== 种类
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h
----

/* Used in tsk->state: */
#define TASK_RUNNING			0x0000
#define TASK_INTERRUPTIBLE		0x0001
#define TASK_UNINTERRUPTIBLE		0x0002
#define __TASK_STOPPED			0x0004
#define __TASK_TRACED			0x0008
/* Used in tsk->exit_state: */
#define EXIT_DEAD			0x0010
#define EXIT_ZOMBIE			0x0020
#define EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)
/* Used in tsk->state again: */
#define TASK_PARKED			0x0040
#define TASK_DEAD			0x0080
#define TASK_WAKEKILL			0x0100
#define TASK_WAKING			0x0200
#define TASK_NOLOAD			0x0400
#define TASK_NEW			0x0800
#define TASK_STATE_MAX			0x1000

----

=== 内核态与用户态
- 作用: 稳定性
- 切换
  
    ▪ 系统调用
    ▪ 中断
    ▪ 异常

- 每个处理器在任何指定时间上的活动必然为以下之一:

    ▪ 运行在用户空间, 执行用户进程
    ▪ 运行在内核空间, 处于进程上下文, 代表某个特定的进程执行
    ▪ 运行在内核空间, 处于中断上下文, 与任何进程无关, 处理某个特定的中断

=== 切换
context_switch函数:
https://elixir.bootlin.com/linux/latest/source/kernel/sched/core.c

=== ARCH
==== X86
tss(task state segment 任务状态段)
Intel的原意是通过TSS来实现任务切换，但由于性能问题，linux并没有使用硬件提供的任务切换机制。
只是由于硬件的要求，内核走过场地设置了TR以及TSS。对于内核来说，TSS中有意义的就是0级(3级不需要切换堆栈)的堆栈指针。
改变TSS中的SS0和ESP0的开销比通过装入TR以及更换一个TSS要小得多，因此，在Linux内核中，TSS并不是属于某个进程的资源，而是全局的公共资源。
多处理器中，每个CPU仍旧只有一个TSS，加载后就不再改变了。
https://en.wikipedia.org/wiki/Task_state_segment


tss_struct:
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/processor.h
