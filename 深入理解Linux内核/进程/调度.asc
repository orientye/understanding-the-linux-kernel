:toc:
:toclevels: 5
:hardbreaks-option:

== 调度

=== 演进
▪ 抢占(preemptive)
Prior to Linux kernel version 2.5.4, Linux Kernel was not preemptive which means a process running in kernel mode cannot be moved out of processor until it itself leaves the processor or it starts waiting for some input output operation to get complete.
参考: https://stackoverflow.com/questions/5283501/what-does-it-mean-to-say-linux-kernel-is-preemptive

▪ 普通进程调度器(SCHED_OTHER)
O(1)调度器 -> CFS调度器(Completely Fair Scheduler)
具体来说:
基于时间片轮询调度算法O(n)(2.6之前的版本)
O(1)调度算法(2.6.23之前的版本)
完全公平调度算法(2.6.23以及之后的版本)

▪ 调度域(scheduling domains)
2.6.7
主要解决NUMA架构上的调度问题
https://lwn.net/Articles/80911/#:~:text=A%20scheduling%20domain%20(struct%20sched_domain,have%20multiple%20levels%20of%20domains.
https://www.kernel.org/doc/html/latest/scheduler/sched-domains.html

▪ SCHED_BATCH
Since 2.6.16
适合非交互性, CPU密集型的任务

▪ SCHED_IDLE
Since 2.6.23
系统在空闲时，每个CPU都有一个idle线程在跑，它什么也不做，就是把CPU放入硬件睡眠状态以节能(需要特定CPU的driver支持), 并等待新的任务到来，以将CPU从睡眠状态中唤醒。

▪ 普通进程的组调度支持(Fair Group Scheduling)
2.6.24
假设有两个用户，一个用户跑了9个进程，另一个用户只跑了一个进程，这将导致用户2的体验可能会比较差。
Group Scheduling解决了这一问题，它为每个用户建立一个组，组里放该用户所有进程，从而保证用户间的公平性。

▪ 实时进程的组调度支持(RT Group Scheduling)
2.6.25
类似普通进程的组调度，只不过针对实时进程

▪ 更精确的调度时钟(HRTICK)
2.6.25
CPU的周期性调度和基于时间片的调度，都是基于时钟中断来触发的。
High Resolution Tick能够提供更精确的调度时钟中断, 它基于高精度时钟(High Resolution Timer)，即可以提供纳秒级别精度的硬件时钟。

▪ 自动组调度(Auto Group Scheduling)
2.6.38
跟某一项任务相关的所有进程可以放在一个会话里，把这些不同会话自动分成不同的调度组，从而利用组调度的优势

▪ SCHED_DEADLINE
Since version 3.14
Deadline scheduling is thus useful for realtime tasks, where completion by a deadline is a key requirement. It is also applicable to periodic tasks like streaming media processing.
In order to fulfill the guarantees that are made when a thread is admitted to the SCHED_DEADLINE policy, SCHED_DEADLINE threads are
the highest priority (user controllable) threads in the system; if any SCHED_DEADLINE thread is runnable, it will preempt any thread scheduled under one of the other policies.
https://lwn.net/Articles/575497/

▪ 组调度带宽控制(CFS bandwidth control)
3.2
让管理员控制在一段时间内一个组可以使用CPU的最长时间

▪ 自动NUMA均衡(Automatic NUMA balancing)
3.8
https://lwn.net/Articles/524977/

▪ CPU调度与节能
https://lwn.net/Articles/655479/

参考: 
https://www.zhihu.com/question/35484429
https://www.kernel.org/doc/html/latest/scheduler/index.html
https://man7.org/linux/man-pages/man7/sched.7.html

=== 目的
调度器的任务是分配CPU资源，同时，linux作为通用操作系统，需要兼顾效率，公平。
效率主要体现在让CPU都忙碌起来，并具有较高的吞吐量和较低的延迟。（吞吐量和延迟通常是一对相互矛盾的指标，有两种比较典型的任务: 强调吞吐量对延迟不敏感的CPU密集型如批处理进程，以及延迟敏感不太在意吞吐量的IO密集型如交互式进程，此外还有一种任务是实时任务，它注重对程序执行的可预测性。）。
公平是让每个任务都有机会获得调度，保证每个进程得到合理的CPU时间。

=== 数据结构

=== 策略与优先级
ps -eLfc可以在CLS查看调度策略
cls         CLS       scheduling class of the process.(alias policy, cls). 
Field's possible values are:
    -   not reported
    TS  SCHED_OTHER
    FF  SCHED_FIFO
    RR  SCHED_RR
    B   SCHED_BATCH
    ISO SCHED_ISO
    IDL SCHED_IDLE
    DLN SCHED_DEADLINE
    ?   unknown value

- SCHED_FIFO
- SCHED_RR
这两个调度策略定义了对实时任务，即对延时和限定性的完成时间的高敏感度的任务。
前者提供FIFO语义，相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务；
后者提供Round-Robin语义，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。不同要求的实时任务可以根据需要用sched_setscheduler()API设置策略。

- SCHED_OTHER此调度策略包含除上述实时进程之外的其他进程，亦称普通进程。采用分时策略，根据动态优先级(可用nice()API设置），分配CPU运算资源。
注意：这类进程比上述两类实时进程优先级低，换言之，在有实时进程存在时，实时进程优先调度。

Linux除了实现上述策略，还额外支持以下策略：
- SCHED_IDLE优先级最低，在系统空闲时才跑这类进程
- SCHED_BATCH是SCHED_OTHER策略的分化，与SCHED_OTHER策略一样，但针对吞吐量优化
- SCHED_DEADLINE是新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高度敏感的任务适用。

除了完成以上基本任务外，Linux调度器还应提供高性能保障，对吞吐量和延时的均衡要有好的优化；要提供高可扩展性(scalability)保障，保障上千节点的性能稳定；对于广泛作为服务器领域操作系统来说，它还提供丰富的组策略调度和节能调度的支持。

参考: https://www.zhihu.com/question/35484429/answer/62964898

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/sched.h
----
/*
 * Scheduling policies
 */
#define SCHED_NORMAL    0
#define SCHED_FIFO		1
#define SCHED_RR		2
#define SCHED_BATCH		3
/* SCHED_ISO: reserved but not implemented yet */
#define SCHED_IDLE		5
#define SCHED_DEADLINE  6
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h
----
extern long schedule_timeout(long timeout);
extern long schedule_timeout_interruptible(long timeout);
extern long schedule_timeout_killable(long timeout);
extern long schedule_timeout_uninterruptible(long timeout);
extern long schedule_timeout_idle(long timeout);
asmlinkage void schedule(void);
extern void schedule_preempt_disabled(void);
asmlinkage void preempt_schedule_irq(void);
#ifdef CONFIG_PREEMPT_RT
 extern void schedule_rtlock(void);
#endif

extern int __must_check io_schedule_prepare(void);
extern void io_schedule_finish(int token);
extern long io_schedule_timeout(long timeout);
extern void io_schedule(void);
----

__schedule函数: https://elixir.bootlin.com/linux/latest/source/kernel/sched/core.c

==== 调度的时机
▪ 自愿调度/主动调度
    
    内核空间:
        schedule()相关调用
        或调用schedule前设置进程状态为TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE
    用户空间:
        nanosleep()
        pause()
        几乎所有涉及外设系统调用函数，如open/read/write/select等

▪ 非自愿调度/被动调度/强制性调度

    每次从系统调用返回的前夕
    每次从中断或异常处理返回到用户空间的前夕

==== 调度的对象

==== 完全公平调度
https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt

==== 实时调度

==== 调度增强

=== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/sched.c

=== 参考
https://www.cnblogs.com/linhaostudy/p/9847909.html
https://oska874.github.io/%E8%AF%BB%E6%A0%B8/%E7%BF%BB%E8%AF%91-linux-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.html