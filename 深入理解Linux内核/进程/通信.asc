:toc:
:toclevels: 5
:hardbreaks-option:

== 通信

=== 共享内存

=== 消息队列

=== 信号量

=== 信号
对信号的检测和响应发生在系统空间，一般来说有以下时机：
进程由于发生系统调用，中断和异常进入系统空间，从系统空间返回到用户空间前；
进程进入睡眠刚被唤醒的时候，由于信号的存在提前返回到用户空间。

==== 系统调用
https://elixir.bootlin.com/linux/latest/source/kernel/signal.c

=== 管道

==== 系统调用
[source,c]
.https://elixir.bootlin.com/linux/latest/source/fs/pipe.c
----
/*
 * sys_pipe() is the normal C calling standard for creating
 * a pipe. It's not the way Unix traditionally does this, though.
 */
static int do_pipe2(int __user *fildes, int flags)
{
	struct file *files[2];
	int fd[2];
	int error;

	error = __do_pipe_flags(fd, files, flags);
	if (!error) {
		if (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {
			fput(files[0]);
			fput(files[1]);
			put_unused_fd(fd[0]);
			put_unused_fd(fd[1]);
			error = -EFAULT;
		} else {
			fd_install(fd[0], files[0]);
			fd_install(fd[1], files[1]);
		}
	}
	return error;
}

SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
{
	return do_pipe2(fildes, flags);
}

SYSCALL_DEFINE1(pipe, int __user *, fildes)
{
	return do_pipe2(fildes, 0);
}
----

=== 套接字
