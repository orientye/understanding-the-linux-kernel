:toc:
:toclevels: 5
:hardbreaks-option:

== 相关系统调用

=== 管理
==== clone
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    clone():
        SYSCALL_DEFINE5(clone
        SYSCALL_DEFINE6(clone
    clone3():
        SYSCALL_DEFINE2(clone3, struct clone_args __user *, uargs, size_t, size)

最终都是调用kernel_clone()

==== execve
https://elixir.bootlin.com/linux/latest/source/fs/exec.c
do_execveat_common()

==== exit
https://elixir.bootlin.com/linux/latest/source/kernel/exit.c

    SYSCALL_DEFINE1(exit, int, error_code)
        do_exit()

==== fork
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    SYSCALL_DEFINE0(fork)
        kernel_clone()

==== vfork
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    SYSCALL_DEFINE0(vfork)
        kernel_clone()

==== nanosleep
https://elixir.bootlin.com/linux/latest/source/kernel/time/hrtimer.c

    SYSCALL_DEFINE2(nanosleep
        do_nanosleep()
            freezable_schedule() https://elixir.bootlin.com/linux/latest/source/include/linux/freezer.h

==== pause
https://elixir.bootlin.com/linux/latest/source/kernel/signal.c
SYSCALL_DEFINE0(pause)

=== 调度
https://elixir.bootlin.com/linux/latest/source/kernel/sched/core.c
SYSCALL_DEFINE XYZ


亲和性:
https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html
int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);
int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);

    SYSCALL_DEFINE3(sched_setaffinity: https://elixir.bootlin.com/linux/latest/source/kernel/sched/core.c
        sched_setaffinity(pid, new_mask)
            __sched_setaffinity()
                __set_cpus_allowed_ptr()
                    __set_cpus_allowed_ptr_locked()

=== 其它
==== set_tid_address
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
SYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)

==== unshare
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)

参考: https://lwn.net/Articles/135266/
