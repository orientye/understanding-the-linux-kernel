:toc:
:toclevels: 5
:hardbreaks-option:

== 管理

=== 创建/复制
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    struct task_struct * __init fork_idle(int cpu) //smpboot
    struct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)//for io_uring
    pid_t kernel_clone(struct kernel_clone_args *args)//main
        copy_process

old:

    fork copy-on-write(COW)
    vfork 效率较慢, 避免使用
    clone 产生线程

    三个函数最后都会调用do_fork, 参数不同而已
    fork/vfork/clone
        sys_fork/sys_vfork/sys_clone
            kernel/fork.c
                do_fork
                    copy_process

==== 0号进程
也称idle进程, 或swapper进程(历史原因)
创建1号进程和2号进程
pstree -ap 0
https://elixir.bootlin.com/linux/latest/source/include/linux/init_task.h

==== 1号进程
也叫init进程
1号进程是所有用户态进程的祖先
pstree -ap 1
systemd https://man7.org/linux/man-pages/man1/systemd.1.html

==== 2号进程
2号进程是所有内核线程的祖先
内核线程: ps -aux 名称带[]的
pstree -ap 2
kthreadd

==== v0.12
    fork
        sys_fork
            sys_call.s
                kernel/fork.c

=== 启动新程序
https://elixir.bootlin.com/linux/latest/source/fs/exec.c

    do_execve
        do_execveat_common
            bprm_execve
                exec_binprm
                    search_binary_handler
                        load_binary

=== 退出
SYSCALL_DEFINE1(exit, int, error_code):
    do_exit()
https://elixir.bootlin.com/linux/latest/source/kernel/exit.c

SYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr, int, options, struct rusage __user *, ru):
    kernel_wait4()
https://elixir.bootlin.com/linux/latest/source/kernel/exit.c

=== 内核线程
内核线程是内核启动的进程，实际上就是将内核函数委托给独立的进程。

https://elixir.bootlin.com/linux/latest/source/include/linux/kthread.h
https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c

    struct kthread

    create_kthread()
        kernel_thread() https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
            kernel_clone() https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    kthread_stop()

内核线程在ps命令的输出中由中括号包围，以与普通进程区分。
如果内核线程绑定到特定的CPU，CPU的编号会在斜线后给出。

=== 命名空间
https://elixir.bootlin.com/linux/latest/source/include/linux/nsproxy.h

=== 进程ID
https://elixir.bootlin.com/linux/latest/source/include/linux/pid.h

enum pid_type
{
	PIDTYPE_PID,  //进程ID
	PIDTYPE_TGID, //线程组ID
	PIDTYPE_PGID, //进程组ID
	PIDTYPE_SID,  //会话ID
	PIDTYPE_MAX,
};

struct upid
struct pid

进程的PID和TGID位于task_struct,
PGID和SID则位于task_struct->signal:
struct signal_struct {
    ...
	/* PID/PID hash table linkage. */
	struct pid *pids[PIDTYPE_MAX];
    ...
}

全局ID:

    struct task_struct {
        ...
        pid_t   pid;
        pid_t   tgid;
        ...
    }

局部ID:

    属于某个特定的命名空间，不具备全局有效性

struct pid_namespace:
https://elixir.bootlin.com/linux/latest/source/include/linux/pid_namespace.h

创建与销毁:
alloc_pid()
free_pid()