:toc:
:toclevels: 5
:hardbreaks-option:

== 管理

=== 创建/复制
https://github.com/torvalds/linux/blob/master/kernel/fork.c

    struct task_struct * __init fork_idle(int cpu) //smpboot
    struct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)//for io_uring
    pid_t kernel_clone(struct kernel_clone_args *args)//main
        copy_process

old:

    fork copy-on-write(COW)
    vfork 效率较慢, 避免使用
    clone 产生线程

    三个函数最后都会调用do_fork, 参数不同而已
    fork/vfork/clone
        sys_fork/sys_vfork/sys_clone
            kernel/fork.c
                do_fork
                    copy_process

==== 0号进程
也称idle进程, 或swapper进程(历史原因)
创建1号进程
pstree -ap 0

==== 1号进程
也叫init进程
1号进程是所有用户态进程的祖先
pstree -ap 1
systemd https://man7.org/linux/man-pages/man1/systemd.1.html

==== 2号进程
2号进程是所有内核线程的祖先
内核线程: ps -aux 名称带[]的
pstree -ap 2
kthreadd

==== task_struct
task_struct存储位置:
https://stackoverflow.com/questions/10604632/where-is-task-struct-stored

获取当前进程的task_struct:
struct task_struct *get_current(void)

==== v0.12
    fork
        sys_fork
            sys_call.s
                kernel/fork.c

=== 启动新程序
https://elixir.bootlin.com/linux/latest/source/fs/exec.c
do_execve
    do_execveat_common
        bprm_execve
            exec_binprm
                search_binary_handler

=== 退出
kernel/exit.c
sys_exit

=== 内核线程
https://github.com/torvalds/linux/blob/master/include/linux/kthread.h
https://github.com/torvalds/linux/blob/master/kernel/kthread.c