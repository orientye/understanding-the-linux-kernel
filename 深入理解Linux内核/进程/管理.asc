:toc:
:toclevels: 5
:hardbreaks-option:

== 管理

=== 创建/复制
- old

    fork copy-on-write(COW)
    vfork 效率较慢, 避免使用
    clone 产生线程

    三个函数最后都会调用do_fork, 参数不同而已
    fork/vfork/clone
        sys_fork/sys_vfork/sys_clone
            kernel/fork.c
                do_fork
                    copy_process

- now
https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

    struct task_struct * __init fork_idle(int cpu) //smpboot
    struct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)//for io_uring
    pid_t kernel_clone(struct kernel_clone_args *args)//main
        三个函数最终都会调用: copy_process(struct pid *pid, int trace, int node, struct kernel_clone_args *args)

==== copy_process

===== clone flags

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/sched.h
----

/*
 * cloning flags:
 */
#define CSIGNAL		0x000000ff	/* signal mask to be sent at exit */
#define CLONE_VM	0x00000100	/* set if VM shared between processes */
#define CLONE_FS	0x00000200	/* set if fs info shared between processes */
#define CLONE_FILES	0x00000400	/* set if open files shared between processes */
#define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
#define CLONE_PIDFD	0x00001000	/* set if a pidfd should be placed in parent */
#define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */
#define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
#define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
#define CLONE_THREAD	0x00010000	/* Same thread group? */
#define CLONE_NEWNS	0x00020000	/* New mount namespace group */
#define CLONE_SYSVSEM	0x00040000	/* share system V SEM_UNDO semantics */
#define CLONE_SETTLS	0x00080000	/* create a new TLS for the child */
#define CLONE_PARENT_SETTID	0x00100000	/* set the TID in the parent */
#define CLONE_CHILD_CLEARTID	0x00200000	/* clear the TID in the child */
#define CLONE_DETACHED		0x00400000	/* Unused, ignored */
#define CLONE_UNTRACED		0x00800000	/* set if the tracing process can't force CLONE_PTRACE on this clone */
#define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
#define CLONE_NEWCGROUP		0x02000000	/* New cgroup namespace */
#define CLONE_NEWUTS		0x04000000	/* New utsname namespace */
#define CLONE_NEWIPC		0x08000000	/* New ipc namespace */
#define CLONE_NEWUSER		0x10000000	/* New user namespace */
#define CLONE_NEWPID		0x20000000	/* New pid namespace */
#define CLONE_NEWNET		0x40000000	/* New network namespace */
#define CLONE_IO		0x80000000	/* Clone io context */

/* Flags for the clone3() syscall. */
#define CLONE_CLEAR_SIGHAND 0x100000000ULL /* Clear any signal handler and reset to SIG_DFL. */
#define CLONE_INTO_CGROUP 0x200000000ULL /* Clone into a specific cgroup given the right permissions. */

/*
 * cloning flags intersect with CSIGNAL so can be used with unshare and clone3
 * syscalls only:
 */
#define CLONE_NEWTIME	0x00000080	/* New time namespace */

----

===== clone args

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/sched.h
----

#ifndef __ASSEMBLY__
/**
 * struct clone_args - arguments for the clone3 syscall
 * @flags:        Flags for the new process as listed above.
 *                All flags are valid except for CSIGNAL and
 *                CLONE_DETACHED.
 * @pidfd:        If CLONE_PIDFD is set, a pidfd will be
 *                returned in this argument.
 * @child_tid:    If CLONE_CHILD_SETTID is set, the TID of the
 *                child process will be returned in the child's
 *                memory.
 * @parent_tid:   If CLONE_PARENT_SETTID is set, the TID of
 *                the child process will be returned in the
 *                parent's memory.
 * @exit_signal:  The exit_signal the parent process will be
 *                sent when the child exits.
 * @stack:        Specify the location of the stack for the
 *                child process.
 *                Note, @stack is expected to point to the
 *                lowest address. The stack direction will be
 *                determined by the kernel and set up
 *                appropriately based on @stack_size.
 * @stack_size:   The size of the stack for the child process.
 * @tls:          If CLONE_SETTLS is set, the tls descriptor
 *                is set to tls.
 * @set_tid:      Pointer to an array of type *pid_t. The size
 *                of the array is defined using @set_tid_size.
 *                This array is used to select PIDs/TIDs for
 *                newly created processes. The first element in
 *                this defines the PID in the most nested PID
 *                namespace. Each additional element in the array
 *                defines the PID in the parent PID namespace of
 *                the original PID namespace. If the array has
 *                less entries than the number of currently
 *                nested PID namespaces only the PIDs in the
 *                corresponding namespaces are set.
 * @set_tid_size: This defines the size of the array referenced
 *                in @set_tid. This cannot be larger than the
 *                kernel's limit of nested PID namespaces.
 * @cgroup:       If CLONE_INTO_CGROUP is specified set this to
 *                a file descriptor for the cgroup.
 *
 * The structure is versioned by size and thus extensible.
 * New struct members must go at the end of the struct and
 * must be properly 64bit aligned.
 */
struct clone_args {
	__aligned_u64 flags;
	__aligned_u64 pidfd;
	__aligned_u64 child_tid;
	__aligned_u64 parent_tid;
	__aligned_u64 exit_signal;
	__aligned_u64 stack;
	__aligned_u64 stack_size;
	__aligned_u64 tls;
	__aligned_u64 set_tid;
	__aligned_u64 set_tid_size;
	__aligned_u64 cgroup;
};
#endif

----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/sched/task.h
----

struct kernel_clone_args {
	u64 flags;
	int __user *pidfd;
	int __user *child_tid;
	int __user *parent_tid;
	int exit_signal;
	unsigned long stack;
	unsigned long stack_size;
	unsigned long tls;
	pid_t *set_tid;
	/* Number of elements in *set_tid */
	size_t set_tid_size;
	int cgroup;
	int io_thread;
	int kthread;
	int idle;
	int (*fn)(void *);
	void *fn_arg;
	struct cgroup *cgrp;
	struct css_set *cset;
};

----

===== 主流程
copy_process(struct pid *pid, int trace, int node, struct kernel_clone_args *args)
[source,c]
.https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
----

/*
 * This creates a new process as a copy of the old one,
 * but does not actually start it yet.
 *
 * It copies the registers, and all the appropriate
 * parts of the process environment (as per the clone
 * flags). The actual kick-off is left to the caller.
 */
static __latent_entropy struct task_struct *copy_process(
					struct pid *pid,
					int trace,
					int node,
					struct kernel_clone_args *args)
{
	int pidfd = -1, retval;
	struct task_struct *p;
	struct multiprocess_signals delayed;
	struct file *pidfile = NULL;
	const u64 clone_flags = args->flags;
	struct nsproxy *nsp = current->nsproxy;

	//clone_flags检查

	//信号处理相关

	//dup_task_struct
	p = dup_task_struct(current, node);

	//task_struct一些变量赋值
	p->flags 
	p->blocked
	p->set_child_tid
	p->clear_child_tid

	//init task_struct
	ftrace_graph_init_task(p);
	rt_mutex_init_task(p);

	copy_creds(p, clone_flags);

	delayacct_tsk_init(p);
	p->flags
	p->children
	p->sibling
	rcu_copy_process(p);
	p->vfork_done
	spin_lock_init(&p->alloc_lock);

	init_sigpending(&p->pending);

	p->utime p->stime p->gtime
	p->utimescaled p->stimescaled
	p->prev_cputime
	p->vtime.seqcount
	p->vtime.starttime
	p->vtime.state

	p->io_uring
	
	p->rss_stat
	p->default_timer_slack_ns

	p->psi_flags

	task_io_accounting_init(&p->ioac);
	acct_clear_integrals(p);

	posix_cputimers_init(&p->posix_cputimers);

	p->io_context;
	audit_set_context(p, NULL);
	cgroup_fork(p);
	set_kthread_struct(p))
	
	p->mempolicy

	p->cpuset_mem_spread_rotor
	p->cpuset_slab_spread_rotor
	p->mems_allowed_seq, p->alloc_lock

	p->irqtrace.hardirq_disable_ip
	p->irqtrace.softirq_enable_ip
	p->softirqs_enabled
	p->softirq_context

	p->pagefault_disabled

	lockdep_init_task(p);

	p->blocked_on
	p->sequential_io
	p->sequential_io_avg
	p->bpf_storage
	p->bpf_ctx

	/* Perform scheduler related setup. Assign this task to a CPU. */
	sched_fork(clone_flags, p);

	perf_event_init_task(p, clone_flags);
	audit_alloc(p);
	shm_init_task(p);
	security_task_alloc(p, clone_flags);

	copy_semundo(clone_flags, p);
	copy_files(clone_flags, p);
	copy_fs(clone_flags, p);
	copy_sighand(clone_flags, p);
	copy_signal(clone_flags, p);
	copy_mm(clone_flags, p);
	copy_namespaces(clone_flags, p);
	copy_io(clone_flags, p);
	copy_thread(p, args);

	stackleak_task_init(p);

	//pid相关

	p->plug

	futex_init_task(p);

	//sigaltstack should be cleared when sharing the same VM
	sas_ss_reset(p);

	user_disable_single_step(p);
	clear_task_syscall_work(p, SYSCALL_TRACE);
	clear_task_syscall_work(p, SYSCALL_EMU);
    
	clear_tsk_latency_tracing(p);

	p->pid
	p->group_leader
	p->tgid

	p->nr_dirtied
	p->nr_dirtied_pause
	p->dirty_paused_when

	p->pdeath_signal
	INIT_LIST_HEAD(&p->thread_group);
	p->task_works
	clear_posix_cputimers_work(p);

	p->kretprobe_instances.first

	p->rethooks.first

	//cgroup相关

	p->start_time
	p->start_boottime

	write_lock_irq(&tasklist_lock);

	p->real_parent
	p->parent_exec_id
	p->exit_signal

	klp_copy_process(p);

	sched_core_fork(p);

	copy_seccomp(p);

	rseq_fork(p, clone_flags);

	/* Don't start children in a dying pid namespace */
	if (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {

	/* Let kill terminate clone/fork in the middle */
	fatal_signal_pending(current)

	//pid, thread_group相关
	
	hlist_del_init(&delayed.node);
	spin_unlock(&current->sighand->siglock);
	syscall_tracepoint_update(p);
	write_unlock_irq(&tasklist_lock);

	fd_install(pidfd, pidfile);

	proc_fork_connector(p);
	sched_post_fork(p);
	cgroup_post_fork(p, args);
	perf_event_fork(p);

	trace_task_newtask(p, clone_flags);
	uprobe_copy_process(p, clone_flags);

	copy_oom_score_adj(clone_flags, p);

	return p;

	//错误处理
}

----

===== fork与内存

[source,c]
.https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
----

static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)
{
	struct mm_struct *mm, *oldmm;

	tsk->min_flt = tsk->maj_flt = 0;
	tsk->nvcsw = tsk->nivcsw = 0;
#ifdef CONFIG_DETECT_HUNG_TASK
	tsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;
	tsk->last_switch_time = 0;
#endif

	tsk->mm = NULL;
	tsk->active_mm = NULL;

	/*
	 * Are we cloning a kernel thread?
	 *
	 * We need to steal a active VM for that..
	 */
	oldmm = current->mm;
	if (!oldmm)
		return 0;

	/* initialize the new vmacache entries */
	vmacache_flush(tsk);

	if (clone_flags & CLONE_VM) {
		mmget(oldmm);
		mm = oldmm;
	} else {
		mm = dup_mm(tsk, current->mm);
		if (!mm)
			return -ENOMEM;
	}

	tsk->mm = mm;
	tsk->active_mm = mm;
	return 0;
}

----

===== fork与进程

https://zhuanlan.zhihu.com/p/373954153
https://zhuanlan.zhihu.com/p/373958196

==== 0号进程的创建


0号进程对应init_task(注意，与1号进程即init进程区分)
之后演变成idle进程: 在smp系统中，每个处理器单元有独立的一个运行队列，每个运行队列上又有一个idle进程，因此有多少处理器单元，就有多少idle进程。 

0号进程结构体: struct task_struct init_task  https://elixir.bootlin.com/linux/latest/source/include/linux/init_task.h

0号进程堆栈: union thread_union  https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h

0号进程地址空间: struct mm_struct init_mm  https://elixir.bootlin.com/linux/latest/source/mm/init-mm.c

0号进程演进:

    start_kernel: https://elixir.bootlin.com/linux/latest/source/init/main.c
        arch_call_rest_init()
            rest_init()

[source,c]
.rest_init(): https://elixir.bootlin.com/linux/latest/source/init/main.c
----

noinline void __ref rest_init(void)
{
	struct task_struct *tsk;
	int pid;

	rcu_scheduler_starting();
	/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
	pid = user_mode_thread(kernel_init, NULL, CLONE_FS); //创建1号进程
	/*
	 * Pin init on the boot CPU. Task migration is not properly working
	 * until sched_init_smp() has been run. It will set the allowed
	 * CPUs for init to the non isolated CPUs.
	 */
	rcu_read_lock();
	tsk = find_task_by_pid_ns(pid, &init_pid_ns);
	tsk->flags |= PF_NO_SETAFFINITY;
	set_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id()));
	rcu_read_unlock();

	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); //创建2号进程
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();

	/*
	 * Enable might_sleep() and smp_processor_id() checks.
	 * They cannot be enabled earlier because with CONFIG_PREEMPTION=y
	 * kernel_thread() would trigger might_sleep() splats. With
	 * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled
	 * already, but it's stuck on the kthreadd_done completion.
	 */
	system_state = SYSTEM_SCHEDULING;

	complete(&kthreadd_done);

	/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
	schedule_preempt_disabled();
	/* Call into cpu_idle with preempt disabled */
	cpu_startup_entry(CPUHP_ONLINE); //循环调用do_idle()
}

----

==== 1号进程的创建
init进程的创建:

    start_kernel()  https://elixir.bootlin.com/linux/latest/source/init/main.c
        arch_call_rest_init()
            rest_init()
                pid = user_mode_thread(kernel_init, NULL, CLONE_FS);

注意，kernel_init内核进程会演变成用户进程

==== 2号进程的创建
kthreadd的创建:

    start_kernel()  https://elixir.bootlin.com/linux/latest/source/init/main.c
        arch_call_rest_init()
            rest_init()
                pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);

==== v0.12
fork

    fork()  https://elixir.bootlin.com/linux/0.12/source/include/unistd.h
        sys_fork()  https://elixir.bootlin.com/linux/0.12/source/kernel/sys_call.s
            copy_process()  https://elixir.bootlin.com/linux/0.12/source/kernel/fork.c

=== 启动新程序
https://elixir.bootlin.com/linux/latest/source/fs/exec.c

    do_execve
        do_execveat_common
            bprm_execve
                exec_binprm
                    search_binary_handler
                        load_binary

=== 退出
https://elixir.bootlin.com/linux/latest/source/kernel/exit.c

SYSCALL_DEFINE1(exit, int, error_code):
    do_exit()

SYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr, int, options, struct rusage __user *, ru):
    kernel_wait4()

=== 内核线程

==== 结构
struct kthread:  https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c

==== 操作
copy_thread():  https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/process.c
    
    PF_KTHREAD

除了初始化阶段0号内核线程和kthreadd，其它所有内核线程都是由kthreadd内核线程来创建的

    int kthreadd(void *unused)  https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c
        create_kthread()  https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c
            kernel_thread()  https://elixir.bootlin.com/linux/latest/source/kernel/fork.c
                kernel_clone()  https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

kthread_run():  https://elixir.bootlin.com/linux/latest/source/include/linux/kthread.h

		kthread_create()
		wake_up_process()

kthread_stop():  https://elixir.bootlin.com/linux/latest/source/kernel/kthread.c

==== 内核线程虚拟地址转换
https://zhuanlan.zhihu.com/p/373959024
https://mp.weixin.qq.com/s/pmWuGS6thCj6GNwwjh0bRw

==== 示例
- kswapd
kswapd_run()  https://elixir.bootlin.com/linux/latest/source/mm/vmscan.c

- ksoftirqd
https://elixir.bootlin.com/linux/latest/source/kernel/softirq.c

static struct smp_hotplug_thread softirq_threads = {
        .store                  = &ksoftirqd,
        .thread_should_run      = ksoftirqd_should_run,
        .thread_fn              = run_ksoftirqd,
        .thread_comm            = "ksoftirqd/%u",
};  

=== 命名空间
==== 概念与作用
隔离资源
https://en.wikipedia.org/wiki/Linux_namespaces

==== 演进
2.4: mount
2.6: IPC Network PID UTS
2.6-3.8: User
4.6: Cgroup

==== 结构

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/nsproxy.h
----

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;                //CLONE_NEWUTS
	struct ipc_namespace *ipc_ns;                //CLONE_NEWIPC
	struct mnt_namespace *mnt_ns;                //CLONE_NEWNS
	struct pid_namespace *pid_ns_for_children;   //CLONE_NEWPID
	struct net 	     *net_ns;                    //CLONE_NEWNET
	struct time_namespace *time_ns;              //CLONE_NEWTIME
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;          //CLONE_NEWCGROUP
};

----

=== 进程ID

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/pid.h
----

enum pid_type
{
	PIDTYPE_PID,
	PIDTYPE_TGID,
	PIDTYPE_PGID,
	PIDTYPE_SID,
	PIDTYPE_MAX,
};

/*
 * What is struct pid?
 *
 * A struct pid is the kernel's internal notion of a process identifier.
 * It refers to individual tasks, process groups, and sessions.  While
 * there are processes attached to it the struct pid lives in a hash
 * table, so it and then the processes that it refers to can be found
 * quickly from the numeric pid value.  The attached processes may be
 * quickly accessed by following pointers from struct pid.
 *
 * Storing pid_t values in the kernel and referring to them later has a
 * problem.  The process originally with that pid may have exited and the
 * pid allocator wrapped, and another process could have come along
 * and been assigned that pid.
 *
 * Referring to user space processes by holding a reference to struct
 * task_struct has a problem.  When the user space process exits
 * the now useless task_struct is still kept.  A task_struct plus a
 * stack consumes around 10K of low kernel memory.  More precisely
 * this is THREAD_SIZE + sizeof(struct task_struct).  By comparison
 * a struct pid is about 64 bytes.
 *
 * Holding a reference to struct pid solves both of these problems.
 * It is small so holding a reference does not consume a lot of
 * resources, and since a new struct pid is allocated when the numeric pid
 * value is reused (when pids wrap around) we don't mistakenly refer to new
 * processes.
 */


/*
 * struct upid is used to get the id of the struct pid, as it is
 * seen in particular namespace. Later the struct pid is found with
 * find_pid_ns() using the int nr and struct pid_namespace *ns.
 */

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid
{
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	/* lists of tasks that use this pid */
	struct hlist_head tasks[PIDTYPE_MAX];
	struct hlist_head inodes;
	/* wait queue for pidfd notifications */
	wait_queue_head_t wait_pidfd;
	struct rcu_head rcu;
	struct upid numbers[1];
};

----

进程的PID和TGID位于task_struct,
PGID和SID则位于task_struct->signal:
struct signal_struct {
    ...
	/* PID/PID hash table linkage. */
	struct pid *pids[PIDTYPE_MAX];
    ...
}

全局ID:

    struct task_struct {
        ...
        pid_t   pid;  //可以理解为线程ID或任务ID
        pid_t   tgid; //可以理解为进程ID或线程组ID
        ...
    }

局部ID:

    属于某个特定的命名空间，不具备全局有效性

struct pid_namespace:  https://elixir.bootlin.com/linux/latest/source/include/linux/pid_namespace.h

创建:
alloc_pid()
    调用时机: copy_process()

销毁:
free_pid()
    调用时机: __change_pid()

大小:
int pid_max = PID_MAX_DEFAULT;  https://elixir.bootlin.com/linux/latest/source/kernel/pid.c
#define PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)  https://elixir.bootlin.com/linux/latest/source/include/linux/threads.h