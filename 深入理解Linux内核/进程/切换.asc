:toc:
:toclevels: 5
:hardbreaks-option:

== 切换

=== 过程
[source,c]
.https://elixir.bootlin.com/linux/latest/source/kernel/sched/core.c
----
/*
 * context_switch - switch to the new MM and the new thread's register state.
 */
static __always_inline struct rq *
context_switch(struct rq *rq, struct task_struct *prev,
	       struct task_struct *next, struct rq_flags *rf)
{
	prepare_task_switch(rq, prev, next);

	/*
	 * For paravirt, this is coupled with an exit in switch_to to
	 * combine the page table reload and the switch backend into
	 * one hypercall.
	 */
	arch_start_context_switch(prev);

	/*
	 * kernel -> kernel   lazy + transfer active
	 *   user -> kernel   lazy + mmgrab() active
	 *
	 * kernel ->   user   switch + mmdrop() active
	 *   user ->   user   switch
	 */
	if (!next->mm) {                                // to kernel
		enter_lazy_tlb(prev->active_mm, next);

		next->active_mm = prev->active_mm;
		if (prev->mm)                           // from user
			mmgrab(prev->active_mm);
		else
			prev->active_mm = NULL;
	} else {                                        // to user
		membarrier_switch_mm(rq, prev->active_mm, next->mm);
		/*
		 * sys_membarrier() requires an smp_mb() between setting
		 * rq->curr / membarrier_switch_mm() and returning to userspace.
		 *
		 * The below provides this either through switch_mm(), or in
		 * case 'prev->active_mm == next->mm' through
		 * finish_task_switch()'s mmdrop().
		 */
		switch_mm_irqs_off(prev->active_mm, next->mm, next);

		if (!prev->mm) {                        // from kernel
			/* will mmdrop() in finish_task_switch(). */
			rq->prev_mm = prev->active_mm;
			prev->active_mm = NULL;
		}
	}

	rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);

	prepare_lock_switch(rq, next, rf);

	/* Here we just switch the register state and the stack. */
	switch_to(prev, next, prev);
	barrier();

	return finish_task_switch(prev);
}
----

=== ARCH
==== X86
tss(task state segment 任务状态段)

    Intel的原意是通过TSS来实现任务切换，但由于性能问题，linux并没有使用硬件提供的任务切换机制。
    只是由于硬件的要求，内核走过场地设置了TR以及TSS。对于内核来说，TSS中有意义的就是0级(3级不需要切换堆栈)的堆栈指针。
    改变TSS中的SS0和ESP0的开销比通过装入TR以及更换一个TSS要小得多，因此，在Linux内核中，TSS并不是属于某个进程的资源，而是全局的公共资源。
    多处理器中，每个CPU仍旧只有一个TSS，加载后就不再改变了。
    https://en.wikipedia.org/wiki/Task_state_segment

tss_struct: https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/processor.h
