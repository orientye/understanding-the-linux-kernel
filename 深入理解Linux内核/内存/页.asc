:toc:
:toclevels: 5
:hardbreaks-option:

== 页

=== 概念
==== 为什么需要分页
对内存管理的几大需求: 隔离 效率 便利

分段没有解决效率的问题，也不够灵活便利:
分段大小更大，容易产生碎片
分段大小不固定，不利于磁盘的换入换出
分页则用大小相同的更小的页取代了大小不同的更大的段。

虚拟页(Vitual Page): 虚拟空间中的页
物理页(Physical Page): 物理内存中的页
磁盘页(Disk Page): 磁盘上的页

==== 为什么需要分级
多级分页节省了物理内存，其代价是寻址的时候需要多次转换，会稍微慢一点。

==== 需要几级分页
linux内核最开始是2级分页，之后为了支持PAE(Physical Address Extention, 2.3.23, 32bit扩展为36bit支持64G物理内存)扩展为3级，再之后为了更好的支持64位CPU, 2.6.11扩展为四级的通用页表。

=== 演进
==== 页表管理
▪ 四级页表
2.6.11
https://lwn.net/Articles/106177/

▪ 延迟页表缓存冲刷(Lazy-TLB flushing)

==== 页面预读
▪ 原始预读
内核发现可能在进行顺序读操作时, 把后面的128KB的页面也读进来。

▪ 按需预读(On-demand Readahead)
2.6.23

如果内存紧张, 预读其实是浪费预读的页面可能还没被访问就被踢出去了。
如果进程频繁且内存也足够宽裕, 128KB显得不够。
按需预读要考虑这些情况，它采用一种启发式的算法，决定预读窗口的大小和哪一页做为异步预读的开始。
对于两个进程在同一个文件上的交替预读, 2.6.24增强了该算法, 使其能很好地侦测这一行为。

==== 页面回收
▪ 改进的LRU算法
2.6前
经典的LRU算法没能体现页面的使用频率。
为此Linux引入了两个链表: active list和inactive list

▪ active与inactive链表拆分
2.6.28

▪ 拆分出被锁页的链表
2.6.28

▪ 代码文件缓存页优化
2.6.31

▪ 工作集大小探测
3.15

==== 页面写回

==== 大内存页(Huge Page)
▪ 作用

    减少页表(Page Table)大小
    由于页表数量的减少，使得CPU中的TLB(可理解为CPU对页表的CACHE)的命中率大大提高
    Huge Page内存只能锁定在物理内存中，不能被交换到交换区，这样避免了交换引起的性能影响

▪ HUGETLB
https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html
https://lwn.net/Articles/375098/

▪ 透明大页(Transparent Huge Pages)
2.6.38
缺页中断发生时, 内核会尝试分配一个大页。

=== 分配页
▪ 分配掩码: ___GFP_DMA等  gfp(GFP)代表get_free_pages
▪ alloc_page函数

    __alloc_pages: https://elixir.bootlin.com/linux/latest/source/mm/page_alloc.c
            get_page_from_freelist: https://elixir.bootlin.com/linux/latest/source/mm/page_alloc.c

▪ https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h
▪ 进程中也有影响分配的一些标志: 例如PF_MEMALLOC等 https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h

==== 不连续页的分配
▪ vmalloc
▪ https://elixir.bootlin.com/linux/latest/source/include/linux/vmalloc.h
▪ struct vm_struct

▪ vmalloc_32
▪ vmap
▪ ioremap 特定于处理器, 体系结构相关

=== 释放页
▪ free_page函数
▪ https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h

=== 内核映射
▪ 持久内核映射
kmap函数: https://elixir.bootlin.com/linux/latest/source/include/linux/highmem-internal.h
kmap函数不能用于中断处理程序, 因为它可能进入睡眠状态
▪ 固定内存映射
kmap_atomic函数: https://elixir.bootlin.com/linux/latest/source/include/linux/highmem-internal.h
kmap_atomic函数不能用于可能进入睡眠的代码
▪ 没有高端内存的计算机上的映射函数
许多体系结构不支持高端内存, 例如64位体系结构: 内核提供了兼容宏CONFIG_HIGHMEM

=== 交换
利用磁盘空间作为扩展内存，从而增大了可用的内存。缺页异常机制。

=== 回收
用于将内存映射被修改的内容与底层的块设备同步，也称为数据回写。

=== 页表
▪ 页表用于建立用户进程的虚拟地址空间和物理内存之间的关联
▪ 内核内存管理总是假定使用四级页表，而不管底层处理器是否如此。例如IA-32默认情况下只使用两级分页系统(在不使用PAE扩展的情况下), 此时第三和第四级页表必须由特定于体系结构的代码模拟

https://elixir.bootlin.com/linux/latest/source/include/asm-generic/page.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64.h

https://cs61.seas.harvard.edu/site/2018/Kernel3/

▪ PGD PUD PMD PTE OFFSET:
▪ pgd_t用于全局页目录项
▪ pud_t用于上层页目录项
▪ pmd_t用于中间页目录项
▪ pte_t用于直接页表项
▪ PTE的相关信息: 例如_PAGE_DIRTY等
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_types.h

▪ 创建与释放
例如pgd_alloc
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgalloc.h

▪ TLB: The process of address translation must be integrated with the operation of any hardware caches in the system. Most page table entries are located in the L1 cache, but the cost of accessing page table entries from L1 is usually eliminated by an on-chip cache of page table entries called a TLB.
