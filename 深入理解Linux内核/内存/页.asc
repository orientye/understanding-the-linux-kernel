:toc:
:toclevels: 6
:hardbreaks-option:

== 页

=== 概念
==== 页面种类
▪ 虚拟页(Vitual Page): 虚拟空间中的页
▪ 物理页(Physical Page): 物理内存中的页
▪ 磁盘页(Disk Page): 磁盘上的页
注意: 磁盘页也可以认为是一种物理页，实际上除了磁盘页，其它的物理介质也可能存在物理页。

在交换或映射时发生转换。

==== 页面大小
一般来说4K
4M大小: https://en.wikipedia.org/wiki/Page_Size_Extension

==== 为什么需要分页
对内存管理的几大需求: 隔离 效率 便利

分段没有解决效率的问题，也不够灵活便利:
▪ 分段大小更大，容易产生碎片
▪ 分段大小不固定，不利于磁盘的换入换出
▪ 分页则用大小相同的更小的页取代了大小不同的更大的段

==== 为什么需要分级
多级分页是为了节省物理内存，其代价是寻址的时候需要多次转换，会稍微慢一点

==== 需要几级分页
linux内核最开始是2级分页，之后为了支持PAE(Physical Address Extention, 2.3.23, 32bit扩展为36bit支持64G物理内存)扩展为3级，再之后为了更好的支持64位CPU, 2.6.11扩展为四级的通用页表。

=== 演进
==== 页表管理
▪ 四级页表
2.6.11
https://lwn.net/Articles/106177/

▪ 延迟页表缓存冲刷(Lazy-TLB flushing)

==== 页面预读
▪ 原始预读
内核发现可能在进行顺序读操作时, 把后面的128KB的页面也读进来。

▪ 按需预读(On-demand Readahead)
2.6.23

如果内存紧张, 预读其实是浪费预读的页面可能还没被访问就被踢出去了。
如果进程频繁且内存也足够宽裕, 128KB显得不够。
按需预读要考虑这些情况，它采用一种启发式的算法，决定预读窗口的大小和哪一页做为异步预读的开始。
对于两个进程在同一个文件上的交替预读, 2.6.24增强了该算法, 使其能很好地侦测这一行为。

==== 页面回收
▪ 改进的LRU算法
2.6前
经典的LRU算法没能体现页面的使用频率。
为此Linux引入了两个链表: active list和inactive list

▪ active与inactive链表拆分
2.6.28

▪ 拆分出被锁页的链表
2.6.28

▪ 代码文件缓存页优化
2.6.31

▪ 工作集大小探测
3.15

==== 页面写回

==== 大内存页(Huge Page)
▪ 作用

    减少页表(Page Table)大小
    由于页表数量的减少，使得CPU中的TLB(可理解为CPU对页表的CACHE)的命中率大大提高
    Huge Page内存只能锁定在物理内存中，不能被交换到交换区，这样避免了交换引起的性能影响

▪ HUGETLB
https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html
https://lwn.net/Articles/375098/

▪ 透明大页(Transparent Huge Pages)
2.6.38
缺页中断发生时, 内核会尝试分配一个大页。

=== 页表
▪ 页表用于建立用户进程的虚拟地址空间和物理内存之间的关联
▪ 内核内存管理总是假定使用四级页表，而不管底层处理器是否如此。例如IA-32默认情况下只使用两级分页系统(在不使用PAE扩展的情况下), 此时第三和第四级页表必须由特定于体系结构的代码模拟

https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html

https://elixir.bootlin.com/linux/latest/source/include/asm-generic/page.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64.h

https://cs61.seas.harvard.edu/site/2018/Kernel3/

▪ PGD PUD PMD PTE OFFSET:

    ▪ pgd_t用于全局页目录项(Page Global Directory)
    ▪ pud_t用于上层页目录项(Page Upper Directory)
    ▪ pmd_t用于中间页目录项(Page Middle Directory)
    ▪ pte_t用于直接页表项(Page Table Entry)
    ▪ PTE的相关信息: 例如_PAGE_DIRTY等
    https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_types.h

▪ 创建与释放
例如pgd_alloc
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgalloc.h

▪ TLB
The process of address translation must be integrated with the operation of any hardware caches in the system. Most page table entries are located in the L1 cache, but the cost of accessing page table entries from L1 is usually eliminated by an on-chip cache of page table entries called a TLB.

==== swapper_pg_dir

=== 分配页
▪ alloc_pages(): struct page *alloc_pages(gfp_t gfp, unsigned order)
https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h
https://elixir.bootlin.com/linux/latest/source/mm/mempolicy.c

    __alloc_pages(): https://elixir.bootlin.com/linux/latest/source/mm/page_alloc.c  伙伴分配算法核心函数
        get_page_from_freelist(): https://elixir.bootlin.com/linux/latest/source/mm/page_alloc.c

▪ 分配掩码: ___GFP_DMA等  gfp(GFP)代表get_free_pages

▪ https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h
▪ 进程中也有影响分配的一些标志: 例如PF_MEMALLOC等 https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h

==== 不连续页的分配
▪ vmalloc
▪ https://elixir.bootlin.com/linux/latest/source/include/linux/vmalloc.h
▪ struct vm_struct

▪ vmalloc_32
▪ vmap
▪ ioremap特定于处理器, 体系结构相关

=== 释放页
▪ free_page函数
▪ https://elixir.bootlin.com/linux/latest/source/include/linux/gfp.h

=== 交换
利用磁盘空间作为扩展内存，从而增大了可用的内存。

注意，不是所有的内存页面都是可以交换出去的:
只有映射到用户空间的页面才会被换出，内核即系统空间的页面则不会。

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/swap.h
----

/*
 * The in-memory structure used to track swap areas.
 */
struct swap_info_struct {
	struct percpu_ref users;	/* indicate and keep swap device valid. */
	unsigned long	flags;		/* SWP_USED etc: see above */
	signed short	prio;		/* swap priority of this type */
	struct plist_node list;		/* entry in swap_active_head */
	signed char	type;		/* strange name for an index */
	unsigned int	max;		/* extent of the swap_map */
	unsigned char *swap_map;	/* vmalloc'ed array of usage counts */
	struct swap_cluster_info *cluster_info; /* cluster info. Only for SSD */
	struct swap_cluster_list free_clusters; /* free clusters list */
	unsigned int lowest_bit;	/* index of first free in swap_map */
	unsigned int highest_bit;	/* index of last free in swap_map */
	unsigned int pages;		/* total of usable pages of swap */
	unsigned int inuse_pages;	/* number of those currently in use */
	unsigned int cluster_next;	/* likely index for next allocation */
	unsigned int cluster_nr;	/* countdown to next cluster search */
	unsigned int __percpu *cluster_next_cpu; /*percpu index for next allocation */
	struct percpu_cluster __percpu *percpu_cluster; /* per cpu's swap location */
	struct rb_root swap_extent_root;/* root of the swap extent rbtree */
	struct block_device *bdev;	/* swap device or bdev of swap file */
	struct file *swap_file;		/* seldom referenced */
	unsigned int old_block_size;	/* seldom referenced */
	struct completion comp;		/* seldom referenced */
#ifdef CONFIG_FRONTSWAP
	unsigned long *frontswap_map;	/* frontswap in-use, one bit per page */
	atomic_t frontswap_pages;	/* frontswap pages in-use counter */
#endif
	spinlock_t lock;		/*
					 * protect map scan related fields like
					 * swap_map, lowest_bit, highest_bit,
					 * inuse_pages, cluster_next,
					 * cluster_nr, lowest_alloc,
					 * highest_alloc, free/discard cluster
					 * list. other fields are only changed
					 * at swapon/swapoff, so are protected
					 * by swap_lock. changing flags need
					 * hold this lock and swap_lock. If
					 * both locks need hold, hold swap_lock
					 * first.
					 */
	spinlock_t cont_lock;		/*
					 * protect swap count continuation page
					 * list.
					 */
	struct work_struct discard_work; /* discard worker */
	struct swap_cluster_list discard_clusters; /* discard clusters list */
	struct plist_node avail_lists[]; /*
					   * entries in swap_avail_heads, one
					   * entry per node.
					   * Must be last as the number of the
					   * array is nr_node_ids, which is not
					   * a fixed value so have to allocate
					   * dynamically.
					   * And it has to be an array so that
					   * plist_for_each_* can work.
					   */
};

----

https://elixir.bootlin.com/linux/latest/source/mm/swap.h
https://elixir.bootlin.com/linux/latest/source/mm/swap.c

struct swap_info_struct *swap_info[MAX_SWAPFILES]; //https://elixir.bootlin.com/linux/latest/source/mm/swapfile.c

==== 定期换出
https://elixir.bootlin.com/linux/latest/source/mm/vmscan.c
kswapd_init()

==== 换入

===== page falut(缺页异常)
▪ 发生page falut(缺页异常)的时机

    ▪ page table中找不到对应的PTE
        ▪ 无效地址(通过地址的addr来找vma，如果没找到说明地址无效，段错误，内核panic掉/相应的页面目录或页表项为空即线性地址与物理地址尚未建立映射关系，或者已经撤销)
        ▪ 有效地址但是没有载入主存(对应的页面不在内存中)
            ▪ 首次访问，发生调页。
            ▪ 如果当前page的present=0，说明不在主存中被swap out了，需要从外存调入主存。
            ▪ COW时访问语义冲突，比如PTE不可写，但是做了写操作，会触发COW机制，在copy page中write
    ▪ 对应虚拟地址的PTE拒绝访问(页面权限不符，例如试图写一个只读页面)

参考: https://bbs.pediy.com/thread-269149.htm

====== x86
DEFINE_IDTENTRY_RAW_ERRORCODE(exc_page_fault): https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/fault.c

	handle_page_fault(regs, error_code, address);
        do_kern_addr_fault(regs, error_code, address);
		do_user_addr_fault(regs, error_code, address);

    do_kern_addr_fault: https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/fault.c

    do_user_addr_fault(): https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/fault.c
        handle_mm_fault(): https://elixir.bootlin.com/linux/latest/source/mm/memory.c
            __handle_mm_fault()
                handle_pte_fault()

=== 内核映射
▪ 持久内核映射
kmap(): https://elixir.bootlin.com/linux/latest/source/include/linux/highmem-internal.h
kmap函数不能用于中断处理程序, 因为它可能进入睡眠状态

▪ 固定内存映射/临时内核映射
kmap_atomic(): https://elixir.bootlin.com/linux/latest/source/include/linux/highmem-internal.h
kmap_atomic函数不能用于可能进入睡眠的代码

▪ 没有高端内存的计算机上的映射函数
许多体系结构不支持高端内存, 例如64位体系结构: 内核提供了兼容宏CONFIG_HIGHMEM

init_memory_mapping()

=== 回收
用于将内存映射被修改的内容与底层的块设备同步，也称为数据回写。
参考: https://zhuanlan.zhihu.com/p/480428225

=== 大页
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable.h
pte_mkhuge(): 4M
pmd_mkhuge(): 1G
参考: https://zhuanlan.zhihu.com/p/503738975
