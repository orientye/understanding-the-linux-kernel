:toc:
:toclevels: 5
:hardbreaks-option:

== 页

=== 概念
==== 为什么需要分页
对内存管理的几大需求:
隔离
效率
便利

分段没有解决效率的问题，分页解决了:
分段认为线性地址等于物理地址，程序需要的线性地址是连续的，因而分段需要的物理地址也需要连续，这就带来了效率的问题。
而有了分页机制，物理地址不再需要连续。
此外，分页用大小相同的更小的页取代了大小不同的更大的段。

虚拟页(Vitual Page): 虚拟空间中的页
物理页(Physical Page): 物理内存中的页
磁盘页(Disk Page): 磁盘上的页

==== 为什么需要分级

==== 需要几级分页

=== 演进
==== 页表管理
▪ 四级页表
2.6.11

▪ 延迟页表缓存冲刷(Lazy-TLB flushing)

==== 页面预读
▪ 原始预读
内核发现可能在进行顺序读操作时, 把后面的128KB的页面也读进来。

▪ 按需预读(On-demand Readahead)
2.6.23

如果内存紧张, 预读其实是浪费预读的页面可能还没被访问就被踢出去了。
如果进程频繁且内存也足够宽裕, 128KB显得不够。
按需预读要考虑这些情况，它采用一种启发式的算法，决定预读窗口的大小和哪一页做为异步预读的开始。
对于两个进程在同一个文件上的交替预读, 2.6.24增强了该算法, 使其能很好地侦测这一行为。

==== 页面回收

==== 页面写回

==== 大内存页
▪ HUGETLB
https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html

▪ 透明大页(Transparent Huge Pages)
2.6.38

=== 分配页
▪ 分配掩码: ___GFP_DMA等  gfp(GFP)代表get_free_pages
▪ alloc_page函数

    __alloc_pages: https://github.com/torvalds/linux/blob/master/mm/page_alloc.c
            get_page_from_freelist: https://github.com/torvalds/linux/blob/master/mm/page_alloc.c

▪ https://github.com/torvalds/linux/blob/master/include/linux/gfp.h
▪ 进程中也有影响分配的一些标志: 例如PF_MEMALLOC等 https://github.com/torvalds/linux/blob/master/include/linux/sched.h

==== 不连续页的分配
▪ vmalloc
▪ https://github.com/torvalds/linux/blob/master/include/linux/vmalloc.h
▪ struct vm_struct

▪ vmalloc_32
▪ vmap
▪ ioremap 特定于处理器, 体系结构相关

=== 释放页
▪ free_page函数
▪ https://github.com/torvalds/linux/blob/master/include/linux/gfp.h

=== 内核映射
▪ 持久内核映射
kmap函数: https://github.com/torvalds/linux/blob/master/include/linux/highmem-internal.h
kmap函数不能用于中断处理程序, 因为它可能进入睡眠状态
▪ 固定内存映射
kmap_atomic函数: https://github.com/torvalds/linux/blob/master/include/linux/highmem-internal.h
kmap_atomic函数不能用于可能进入睡眠的代码
▪ 没有高端内存的计算机上的映射函数
许多体系结构不支持高端内存, 例如64位体系结构: 内核提供了兼容宏CONFIG_HIGHMEM

=== 交换
利用磁盘空间作为扩展内存，从而增大了可用的内存。缺页异常机制。

=== 回收
用于将内存映射被修改的内容与底层的块设备同步，也称为数据回写。

=== 页表
▪ 页表用于建立用户进程的虚拟地址空间和物理内存之间的关联
▪ 内核内存管理总是假定使用四级页表，而不管底层处理器是否如此。例如IA-32默认情况下只使用两级分页系统(在不使用PAE扩展的情况下), 此时第三和第四级页表必须由特定于体系结构的代码模拟

https://github.com/torvalds/linux/blob/master/include/asm-generic/page.h
https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgtable_64.h

▪ PGD PUD PMD PTE OFFSET:
▪ pgd_t用于全局页目录项
▪ pud_t用于上层页目录项
▪ pmd_t用于中间页目录项
▪ pte_t用于直接页表项
▪ PTE的相关信息: 例如_PAGE_DIRTY等
https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgtable_types.h

▪ 创建与释放
例如pgd_alloc
https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgalloc.h

▪ TLB: The process of address translation must be integrated with the operation of any hardware caches in the system. Most page table entries are located in the L1 cache, but the cost of accessing page table entries from L1 is usually eliminated by an on-chip cache of page table entries called a TLB.