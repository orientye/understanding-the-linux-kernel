:toc:
:toclevels: 5
:hardbreaks-option:

== 概念
▪ 线性/虚拟/逻辑地址

    可以认为, 线性地址=虚拟地址
    逻辑地址是32位下的selector:offset形式，x86-64已废弃

▪ 物理地址

    放到地址总线上物理上存在着具体的内存单元的地址
    由于线性地址是连续的，内存中可能没有这么大的一块连续空间, 因此CPU采用了分页内存管理机制, 默认每页4KB
    有了分页机制，线性地址必须通过转换才能变成物理地址

▪ 内核/系统空间与用户空间

    内核空间位于虚拟空间的高处, 物理空间的低处
    用户空间位于虚拟空间的低处, 物理空间的高处
    32位系统:
    虚拟地址0xC0000000-0xFFFFFFFF(1G)为内核空间，较低的3G为用户空间;
    内核空间在物理中的内存则从最低地址0开始
    x86-64只用了48bit:
    0x0000000000000000-0x00007FFFFFFFFFFF表示用户空间(128T)
    0xFFFF800000000000-0xFFFFFFFFFFFFFFFF表示内核空间(128T)

▪ 分段

    intel8086-80286
    GDT
        https://en.wikipedia.org/wiki/Global_Descriptor_Table
        arch/x86/kernel/head*.*
        每个CPU一个GDT
        v0.12: include/linux/head.h: struct desc_struct
    LDT
        https://en.wikipedia.org/wiki/Global_Descriptor_Table#Local_Descriptor_Table
    实际上现在X86架构的OS, 只是象征性地初始化GDT, 之后就不再使用分段而是分页了
    ARM不支持分段
    https://www.zhihu.com/question/50796850
    https://stackoverflow.com/questions/56213569/linux-memory-segmentation

▪ 分页

    intel80386起

▪ 页表

    用来将虚拟地址空间映射到物理地址空间的数据结构称为页表
    各体系结构间接层数目可能不同

▪ 页与页帧

    页可以分为虚拟页，物理页，磁盘页
    页帧通常用来描述物理页
    https://stackoverflow.com/questions/42258337/difference-between-virtual-page-and-page-frame 
    
▪ MMU(memory management unit)

    有时也称作分页内存管理单元(paged memory management unit，即PMMU)
    是一种负责处理CPU的内存访问请求的计算机硬件
    其功能包括虚拟地址到物理地址的转换、内存保护、中央处理器高速缓存的控制、
    在较为简单的计算机体系结构中，还负责总线的仲裁以及存储体切换(bank switching尤其8位的系统上）。
    https://en.wikipedia.org/wiki/Memory_management_unit
    现代的处理器一般都具有MMU, 有些嵌入式处理器没有MMU, 有些MMU会集成在CPU里
    
▪ TLB

    TLB(translation lookaside buffer)是MMU的重要组成部分
    https://en.wikipedia.org/wiki/Translation_lookaside_buffer

▪ IOMMU(input output memory management unit)

    https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit
    IOMMU(Input/Output Memory Management Unit)是一个内存管理单元(Memory Management Unit)，
    作用是连接DMA-capable I/O总线(Direct Memory Access-capable I/O Bus)和主存(main memory)。
    传统的内存管理单元会把CPU访问的虚拟地址转化成实际的物理地址，
    IOMMU则是把设备访问的虚拟地址转化成物理地址。
    为了防止设备错误地访问内存，有些IOMMU还提供了访问内存保护机制。
    应用示例:
    the graphics address remapping table (GART) used by AGP and PCI Express graphics cards on Intel Architecture and AMD computers.
    https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit#Virtualization
    https://lwn.net/Articles/747230/

▪ DMA

    DMA(direct memory access)允许某些硬件无需通过CPU而直接访问主存
    https://en.wikipedia.org/wiki/Direct_memory_access
    vs. IOMMU: https://stackoverflow.com/questions/56834833/what-is-the-difference-between-dma-and-iommu

▪ UMA与NUMA

    CONFIG_NUMA
    2.4.0开始提供了对NUMA的支持

▪ buffer与cache

    buffer: 针对直接访问裸分区，/dev/sdaN，文件系统的metadata
    cache:  针对文件系统中的文件
    https://stackoverflow.com/questions/6345020/what-is-the-difference-between-buffer-and-cache-memory-in-linux

▪ VSS RSS PSS USS

    VSS: Virtual Set Size 虚拟内存(包含共享库占用的内存)
    单个进程全部可访问的地址空间，其大小可能包括还尚未在内存中驻留的部分。
    对于确定单个进程实际内存使用大小，VSS用处不大。
    
    RSS: Resident Set Size 实际使用物理内存(包含共享库占用的内存)
    单个进程实际占用的内存大小，RSS不太准确的地方在于它包括该进程所使用共享库全部内存大小。
    对于一个共享库，可能被多个进程使用，实际该共享库只会被装入内存一次。
    
    PSS: Proportional Set Size 实际使物理内存(比例分配共享库占用的内存)
    PSS相对于RSS计算共享库内存大小是按比例的。N个进程共享，该库对PSS大小的贡献只有1/N。
    
    USS: Unique Set Size 独自占用物理内存(不包含共享库占用的内存)
    单个进程私有的内存大小，即该进程独占的内存部分。
    USS揭示了运行一个特定进程在的真实内存增量大小。
    进程终止，USS就是实际被返还给系统的内存大小。

    一般情况下：VSS >= RSS >= PSS >= USS。

    https://serverfault.com/questions/48582/how-is-memory-usage-reported-in-linux
    https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate

▪ RAM DRAM SRAM ROM

    RAM，即随机存储器或者易失性存储器，断电后会丢失数据。
        RAM可以分为:
            DRAM，即动态随机存储器，一般用于内存，需要不断地刷新电路，否则数据就消失了。
            SRAM，即静态随机存储器，一般用于CPU中的cache，不需要不停地刷新电路来保存数据。
    ROM，即只读存储器或者叫非易失性存储器，断电后不会丢失数据。
