:toc:
:toclevels: 5
:hardbreaks-option:

== 数据结构

=== mem_map page数组
struct page *mem_map;
unsigned long max_mapnr;

https://elixir.bootlin.com/linux/latest/source/mm/memory.c
https://elixir.bootlin.com/linux/latest/source/mm/nommu.c

mem_map是一个struct page数组，管理着系统中所有的物理内存页面

=== pglist_data

[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/mmzone.h
----

/*
 * On NUMA machines, each NUMA node would have a pg_data_t to describe
 * it's memory layout. On UMA machines there is a single pglist_data which
 * describes the whole memory.
 *
 * Memory statistics and page replacement data structures are maintained on a
 * per-zone basis.
 */
typedef struct pglist_data {
	/*
	 * node_zones contains just the zones for THIS node. Not all of the
	 * zones may be populated, but it is the full list. It is referenced by
	 * this node's node_zonelists as well as other node's node_zonelists.
	 */
	struct zone node_zones[MAX_NR_ZONES];

	/*
	 * node_zonelists contains references to all zones in all nodes.
	 * Generally the first zones will be references to this node's
	 * node_zones.
	 */
	struct zonelist node_zonelists[MAX_ZONELISTS];

	int nr_zones; /* number of populated zones in this node */
#ifdef CONFIG_FLATMEM	/* means !SPARSEMEM */
	struct page *node_mem_map;
#ifdef CONFIG_PAGE_EXTENSION
	struct page_ext *node_page_ext;
#endif
#endif
#if defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)
	/*
	 * Must be held any time you expect node_start_pfn,
	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.
	 * Also synchronizes pgdat->first_deferred_pfn during deferred page
	 * init.
	 *
	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to
	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG
	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.
	 *
	 * Nests above zone->lock and zone->span_seqlock
	 */
	spinlock_t node_size_lock;
#endif
	unsigned long node_start_pfn;
	unsigned long node_present_pages; /* total number of physical pages */
	unsigned long node_spanned_pages; /* total size of physical page
					     range, including holes */
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;

	/* workqueues for throttling reclaim for different reasons. */
	wait_queue_head_t reclaim_wait[NR_VMSCAN_THROTTLE];

	atomic_t nr_writeback_throttled;/* nr of writeback-throttled tasks */
	unsigned long nr_reclaim_start;	/* nr pages written while throttled
					 * when throttling started. */
	struct task_struct *kswapd;	/* Protected by
					   mem_hotplug_begin/end() */
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;

	int kswapd_failures;		/* Number of 'reclaimed == 0' runs */

#ifdef CONFIG_COMPACTION
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
#endif
	/*
	 * This is a per-node reserve of pages that are not available
	 * to userspace allocations.
	 */
	unsigned long		totalreserve_pages;

#ifdef CONFIG_NUMA
	/*
	 * node reclaim becomes active if more unmapped pages exist.
	 */
	unsigned long		min_unmapped_pages;
	unsigned long		min_slab_pages;
#endif /* CONFIG_NUMA */

	/* Write-intensive fields used by page reclaim */
	ZONE_PADDING(_pad1_)

#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
	/*
	 * If memory initialisation on large machines is deferred then this
	 * is the first PFN that needs to be initialised.
	 */
	unsigned long first_deferred_pfn;
#endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */

#ifdef CONFIG_TRANSPARENT_HUGEPAGE
	struct deferred_split deferred_split_queue;
#endif

	/* Fields commonly accessed by the page reclaim scanner */

	/*
	 * NOTE: THIS IS UNUSED IF MEMCG IS ENABLED.
	 *
	 * Use mem_cgroup_lruvec() to look up lruvecs.
	 */
	struct lruvec		__lruvec;

	unsigned long		flags;

	ZONE_PADDING(_pad2_)

	/* Per-node vmstats */
	struct per_cpu_nodestat __percpu *per_cpu_nodestats;
	atomic_long_t		vm_stat[NR_VM_NODE_STAT_ITEMS];
} pg_data_t;

----

▪ NUMA系统上每个NUMA节点拥有一个pglist_data结构来描述内存布局
▪ UMA系统用一个pglist_data结构来描述整个内存布局
▪ pglist_data划分为zone
▪ node_states: https://elixir.bootlin.com/linux/latest/source/include/linux/nodemask.h

=== zone
https://elixir.bootlin.com/linux/latest/source/include/linux/mmzone.h
▪ 由于硬件的限制，需要把页划分成区

    ▪ 某些硬件只能通过某些特定的内存地址来执行直接内存访问
    ▪ 一些体系结构的内存物理寻址范围比虚拟寻址范围大，于是某些内存就不能永久地映射到内核空间上

▪ 不是所有体系结构都定义了全部区, 如X86-64没有ZONE_HIGHMEM
▪ enum zone_type: https://elixir.bootlin.com/linux/latest/source/include/linux/mmzone.h
▪ zone_names: https://elixir.bootlin.com/linux/latest/source/mm/page_alloc.c

Q: 如何理解高端内存(high memory)?
A: https://www.zhihu.com/question/280526042

=== page
https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h
https://elixir.bootlin.com/linux/latest/source/include/asm-generic/page.h
https://elixir.bootlin.com/linux/latest/source/include/linux/page-flags.h

=== vm_area_struct
https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h

=== mm_struct
进程整个用户空间的抽象:  task_struct ◆――――――――> mm_struct ◆――――――――> vm_area_struct
https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h
