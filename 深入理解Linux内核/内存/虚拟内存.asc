:toc:
:toclevels: 5
:hardbreaks-option:

== 虚拟内存

=== 作用
▪ It uses mainmemory efficiently by treating it as a cache for an address space stored on disk, keeping only the active areas in main memory and transferring data back and forth between disk and memory as needed. 
▪ It simplifies memory management by providing each process with a uniform address space.
▪ It protects the address space of each process from corruption by other processes.

VM as a tool for Caching 
VM as a tool for Memory Management 简化: 链接, 加载, 共享, 内存分配
VM as a Tool for Memory Protection 

=== Address Translation
▪ Early PCs used physical addressing, and systems such as digital signal processors, embedded microcontrollers, and Cray supercomputers continue to do so. However, modern processors use a form of addressing known as virtual addressing.

▪ 虚拟地址: |PGD|PUD|PMD|PTE|OFFSET|

▪ Q&A
https://www.quora.com/Is-there-a-way-to-see-a-process-physical-memory-address-in-Linux

==== x86
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page.h

    __pa(x)
    __va(x)


https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/segment.h

    #define __KERNEL_CS			(GDT_ENTRY_KERNEL_CS*8)
    #define __KERNEL_DS			(GDT_ENTRY_KERNEL_DS*8)
    #define __USER_DS			(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
    #define __USER_CS			(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)


https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/tlb.c
    
    switch_mm()
        switch_mm_irqs_off()


=== 大小
用户虚拟空间大小: TASK_SIZE
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_32_types.h

=== 布局
struct mm_struct: https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h
系统中每个进程拥有一个mm_struct
当前运行代码的二进制代码，即text段
程序使用的动态库代码
存储全局变量和动态产生的数据的堆
保存局部变量和实现函数/过程调用的栈
环境变量和命令行参数的段
将文件内容映射到虚拟地址空间中的内存映射

Q: 环境变量和命令行参数存在哪里？
https://unix.stackexchange.com/questions/75939/where-is-the-environment-string-actual-stored

布局的建立: load_elf_binary()(exex系统调用使用了此函数)

▪ 32位X86系统: 
image:img/32-x86-linux-vm-pm.png[]
直接进行映射的896MB物理内存其实又分为两个区域, 在低于16MB的区域, ISA设备可以做DMA, 所以该区域为DMA区域(内核为了保证ISA驱动在申请DMA缓冲区的时候, 通过GFP_DMA标记可以确保申请到16MB以内的内存, 所以必须把这个区域列为一个单独的区域管理); 16MB~896MB之间的为常规区域。 
参考: 《linux设备驱动开发详解》

=== vmalloc/vfree
vmalloc提供了内核虚拟地址连续但物理地址不一定连续的区域。
vmalloc从内核的虚存空间分配一块虚存以及相应的物理内存，vmalloc分配的空间不会被kswapd换出，kswapd只扫描各个进程的用户空间，通过vmalloc分配的页面表项对其不可见。

https://elixir.bootlin.com/linux/latest/source/include/linux/vmalloc.h

VMALLOC_START与VMALLOC_END:
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_32_areas.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64_types.h

=== 区域

=== 内存映射
▪ 作用与原理
Linux initializes the contents of a virtual memory area by associating it with an object on disk, a process known as memory mapping. 
Areas can be mapped to one of two types of objects:

1. Regular file in the Linux file system: An area can be mapped to a contiguous section of a regular disk file, such as an executable object file. The file section is divided into page-size pieces, with each piece containing the initial contents of a virtual page. Because of demand paging, none of these virtual pages is actually swapped into physical memory until the CPU first touches the page (i.e., issues a virtual address that falls within that page’s region of the address space). If the area is larger than the file section, then the area is padded with zeros. 适合于很大的文件

2. Anonymous file: An area can also be mapped to an anonymous file, created by the kernel, that contains all binary zeros. The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, overwrites the victim page with binary zeros, and updates the page table to mark the page as resident. Notice that no data are actually transferred between disk and memory. For this reason, pages in areas that are mapped to anonymous files are sometimes called demand-zero pages. 适合于创建进程间通信的共享内存。

In either case, once a virtual page is initialized, it is swapped back and forthbetween a special swap file maintained by the kernel. The swap file is also known as the swap space or the swap area. An important point to realize is that at any point in time, the swap space bounds the total amount of virtual pages that can be allocated by the currently running processes.

内存映射是一种重要的抽象手段，在内核中大量使用，也用于用户应用程序。映射方法可以任意来源的数据传输到进程的虚拟地址空间中。作为映射目标的地址空间区域，可以像普通内存那样用通常的方法访问。但任何修改都会自动传输到原数据源。例如，文件的内容映射到内存中，处理只需要读取相应的内存即可访问文件内容，或向内存写入数据来修改文件的内容，内核保证任何修改都会自动同步到文件中。内核在实现设备驱动程序时直接使用了内存映射。外设的输入/输出可以映射到虚拟地址空间的区域中。对相关内存区域的都写会由系统重定向到设备，因而大大简化了驱动程序的实现。

▪ 问题

内存映射文件需要在进程上占用一块很大的连续逻辑地址空间。对于Intel的IA-32的4G逻辑地址空间，可用的连续地址空间远远小于2-3G。
相关联的文件的I/O错误（如可拔出驱动器或光驱被弹出，磁盘满时写操作等）的内存映射文件会向应用程序报告SIGSEGV/SIGBUS信号（POSIX环境）或EXECUTE_IN_PAGE_ERROR结构化异常（Windows环境）。通常的内存操作是无需考虑这些异常的。
有内存管理单元（MMU）才支持内存映射文件。

▪ copy on write

▪ fork

▪ execve
    
    execve("a.out", NULL, NULL);

=== 反向映射

=== 外部设备存储空间的地址映射

=== 动态内存分配

▪ malloc

    $ strace ./malloc 1
    ...
    brk(NULL)                               = 0x5585209f2000
    brk(0x558520a13000)                     = 0x558520a13000
    exit_group(0)                           = ?
    
    $ strace ./malloc 100000
    ...
    brk(NULL)                               = 0x55b45a386000
    brk(0x55b45a3bf000)                     = 0x55b45a3bf000
    exit_group(0)                           = ?
    
    $ strace ./malloc 1000000
    ...
    mmap(NULL, 1003520, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f05f7cbf000
    exit_group(0)                           = ?

    glibc: https://github.com/bminor/glibc/blob/master/malloc/malloc.c brk/sbrk   mmap  128K?

▪ 动态内存分配要考虑的问题

=== 缺页异常

=== v0.12
v0.12默认最多支持64M逻辑地址空间