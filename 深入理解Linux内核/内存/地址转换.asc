:toc:
:toclevels: 5
:hardbreaks-option:

== 地址转换

=== 历史与现状
Early PCs used physical addressing, and systems such as digital signal processors, embedded microcontrollers, and Cray supercomputers continue to do so. However, modern processors use a form of addressing known as virtual addressing.

=== 流程

.Image source: CSAPP chapter9
image::img/adress-translation.png[]

==== MMU

==== TLB

=== 用户空间
▪ x86_64:
虚拟地址: |PGD|PUD|PMD|PTE|OFFSET|
48bit: |9bit|9bit|9bit|9bit|12bit|
https://github.com/torvalds/linux/blob/master/Documentation/x86/x86_64/mm.rst
5级页表: https://en.wikipedia.org/wiki/Intel_5-level_paging

=== 内核空间

按照连续的虚拟空间对应的物理内存是否连续，将内核空间分成两个部分。
一部分其物理内存也是连续的，另一部分则物理内存不连续。
在这里，我们称前者为线性映射/一致性映射/，后者称为非线性映射或非一致性映射。

显然线性映射不需要按照多级页表path walk去查找，地址转换效率高。

Q: 线性映射这么好，那为什么不全部使用线性映射呢?
在32位处理器下，按照经典用户态与内核3:1的划分比例，内核能够使用的虚拟地址只有1G，按照固定offset的映射方式，这意味着内核能够使用的物理地址大小也只有1G。但随着内核越来越复杂，内存技术的发展使得高于4G的内存变得十分常见，受限于32位系统与这种线性映射，内核可用的物理内存大小限制在1G。
这也正是high memory出现的原因。"high memory"要解决的是32位下虚拟地址空间不足带来的问题(显然64位系统这个问题就不存在了)。实际上在很早以前这个问题就在lwn上讨论过了 ，在当时已经有一些临时的方法去规避这个问题，比如重新划分用户/内核的地址空间比例，变为2.5:1.5等等，但在特定场景下(比如用户态使用的内存非常非常多)会使得用户态运行效率降低，因此也不是一个很好的办法。怎么解决呢可以把这1G，划分成两部分，一部分用来线性映射，一部分用来非线性映射。以x86为例，实际中的做法是，0xC0000000-0xF7FFFFFF的896MB用作线性映射，0xF8000000-0xFFFFFFFF的128MB用作非线性映射，前者仍然对应于物理地址的0x00000000-0x37FFFFFF(只不过部分要优先分配给DMA)；后者就是所谓的high memory。当然，high memory也有自己的缺点，就是效率比较低(既然是动态的，就绕不开重映射、pte操作等等)。实际上high memory还被划分为了3个区域，一部分用于vmalloc分配虚拟地址上连续的内存，一部分用于较长期的动态映射(persistent kernel mappings)，还有一部分用于编译时可以直接分配物理地址的高端固定映射(fixmaps)。
参考: https://www.zhihu.com/question/280526042

Q: 64位内核虚拟地址空间足够使用，为什么不全部使用线性映射呢？
像vmalloc这些有可能物理上不连续的需求依然是存在的，用线性映射显然不合适。

Q: 32位下如果物理内存比896M还小呢？
[source,c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/init_32.c
----
#ifdef CONFIG_HIGHMEM
	highstart_pfn = highend_pfn = max_pfn;
	if (max_pfn > max_low_pfn)
		highstart_pfn = max_low_pfn;
	printk(KERN_NOTICE "%ldMB HIGHMEM available.\n",
		pages_to_mb(highend_pfn - highstart_pfn));
	high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1;
#else
	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1;
#endif
----

一致性映射之地址转换: __pa(x)与__va(x)
[source,c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page.h
----
#ifndef __pa
#define __pa(x)		__phys_addr((unsigned long)(x))
#endif

#ifndef __va
#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
#endif
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64.h
----
static __always_inline unsigned long __phys_addr_nodebug(unsigned long x)
{
	unsigned long y = x - __START_KERNEL_map;

	/* use the carry flag to determine if x was < __START_KERNEL_map */
	x = y + ((x > y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));

	return x;
}

#ifdef CONFIG_DEBUG_VIRTUAL
extern unsigned long __phys_addr(unsigned long);
extern unsigned long __phys_addr_symbol(unsigned long);
#else
#define __phys_addr(x)		__phys_addr_nodebug(x)
#define __phys_addr_symbol(x) \
	((unsigned long)(x) - __START_KERNEL_map + phys_base)
#endif
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/page_64_types.h
----
#define __START_KERNEL_map	_AC(0xffffffff80000000, UL)
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/segment.h
----
    #define __KERNEL_CS			(GDT_ENTRY_KERNEL_CS*8)
    #define __KERNEL_DS			(GDT_ENTRY_KERNEL_DS*8)
    #define __USER_DS			(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
    #define __USER_CS			(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)
----

内核线程虚拟地址转换:
对于arm64架构来说，有两个页表基址寄存器ttbr0_el1和ttbr1_el1, ttbr0_el1用来存放用户地址空间的页表基地址，在每次调度上下文切换的时候从tsk->mm->pgd加载，ttbr1_el1是内核地址空间的页表基地址，内核初始化完成之后存放swapper_pg_dir的地址。
内核线程共享内核地址空间，也只能访问内核地址空间，使用swapper_pg_dir去查询页表就可以，而对于arm64来说swapper_pg_dir在内核初始化的时候被加载到ttbr1_le1中，一旦内核线程访问内核虚拟地址，则mmu就会从ttbr1_le1指向的页表基地址开始查询各级页表，进行正常的虚实地址转换。当然，上面是arm64这种架构的处理，它有两个页表基地址寄存器，其他很多处理器如x86, riscv处理器架构都只有一个页表基址寄存器，如x86的cr3，那么这个时候怎么办呢？答案是：使用内核线程借用的prev->active_mm来做，实际上前一个用户任务（记住：不一定是上一个，有可能上上个任务才是用户任务）的active_mm=mm,当切换到前一个用户任务的时候就会将tsk->mm->pgd放到cr3, 对于x86这样的只有一个页表基址寄存器的处理器架构来说，tsk->mm->pgd存放的是整个虚拟地址空间的页表基地址，在fork的时候会将主内核页表的pgd表项拷贝到tsk->mm->pgd对于表项中（有兴趣可以查看fork的copy_mm相关代码，对于arm64这样的架构没有做内核页表同步）。
参考: https://zhuanlan.zhihu.com/p/373959024
参考: https://mp.weixin.qq.com/s/pmWuGS6thCj6GNwwjh0bRw
