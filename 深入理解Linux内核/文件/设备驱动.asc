:toc:
:toclevels: 5
:hardbreaks-option:

== 设备驱动

=== I/O体系结构
与外设的通信通常称之为输入输出, 一般成为I/O

扩展硬件:
1 总线系统
2 与外设的交互

    I/O端口
    I/O内存映射
    轮询和中断

3 通过总线控制设备


外设可处于CPU的内存空间和I/O空间,除x86外,嵌入式处理器一般只存在内存空间。
在Linux系统中,为I/O内存和I/O端口的访问提高了一套统一的方法
访问流程一般为: 申请资源→映射→访问→去映射→释放资源

对于有MMU的处理器而言,Linux系统的内部布局比较复杂,可直接映射的物理内存称为常规内存,超出部分为高端内存。
kmalloc()和__get_free_pages()申请的内存在物理上连续
vmalloc()申请的内存在物理上不连续
DMA操作可能导致Cache的不一致性问题
对于DMA缓冲, 应该使用dma_alloc_coherent()等方法申请
在DMA操作中涉及总线地址, 物理地址和虚拟地址等概念, 区分这几类地址非常重要

=== 访问设备

=== Device Tree
3.x开始引入设备树的概念, 用于实现驱动代码与设备信息相分离。
设备树出现以前, 关于设备的具体信息都要写在驱动里, 一旦外围设备变化,驱动代码就要重写。
设备树出现之后, 驱动代码只负责处理驱动的逻辑, 设备的具体信息存放到设备树文件中。
因此, 如果设备信息发生变化, 但驱动逻辑没有发生变化, 只需要修改设备树信息, 不需要改动驱动代码。

=== 与文件系统关联

=== 字符设备
https://github.com/torvalds/linux/blob/master/include/linux/cdev.h

[source,c]
----
struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
} __randomize_layout;
----

/dev/null:  struct file_operations null_fops
https://elixir.bootlin.com/linux/latest/source/drivers/char/mem.c

=== 块设备
https://github.com/torvalds/linux/blob/master/include/linux/blkdev.h
struct block_device_operations

=== 资源分配

=== 总线系统

=== 系统调用mknod

=== 可安装模块
▪ 可加载内核模块(LKM)是Linux内核运行时加载和移除代码的机制

▪ https://github.com/torvalds/linux/blob/master/include/linux/module.h
▪ https://github.com/torvalds/linux/blob/master/kernel/module.c

▪ 内核模块编写示例
http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/
http://derekmolloy.ie/writing-a-linux-kernel-module-part-2-a-character-device/
http://derekmolloy.ie/kernel-gpio-programming-buttons-and-leds/

=== 系统调用select及异步输入输出

=== devtmpfs与udev
devfs已经被淘汰

=== 网络设备
示例: https://github.com/torvalds/linux/blob/master/drivers/net/ethernet/davicom/dm9000.c
