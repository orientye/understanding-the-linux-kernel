:toc:
:toclevels: 5
:hardbreaks-option:

== 读文件流程

=== 过程概述

=== read()系统调用
[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/read_write.c
----
ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)
{
	struct fd f = fdget_pos(fd);
	ssize_t ret = -EBADF;

	if (f.file) {
		loff_t pos, *ppos = file_ppos(f.file);
		if (ppos) {
			pos = *ppos;
			ppos = &pos;
		}
		ret = vfs_read(f.file, buf, count, ppos);
		if (ret >= 0 && ppos)
			f.file->f_pos = pos;
		fdput_pos(f);
	}
	return ret;
}

SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
{
	return ksys_read(fd, buf, count);
}
----
可见，read()最终调用vfs_read():

=== vfs_read()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/read_write.c
----
ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
	//...
	if (file->f_op->read)
		ret = file->f_op->read(file, buf, count, pos);
	else if (file->f_op->read_iter)
		ret = new_sync_read(file, buf, count, pos);
	else
		ret = -EINVAL;
	//...
}
----
如果file->f_op->read函数存在，调用file->f_op->read();
否则如果file->f_op->read_iter存在，调用new_sync_read()。

目前大多数文件系统都是使用新的file->f_op->read_iter函数。
read_iter和read的区别是，read_iter一次性可以读取多个文件片段:
read_iter使用了(struct kiocb *, struct iov_iter *)参数。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/read_write.c
----
static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
{
	struct kiocb kiocb;
	struct iov_iter iter;
	ssize_t ret;

	init_sync_kiocb(&kiocb, filp);
	kiocb.ki_pos = (ppos ? *ppos : 0);
	iov_iter_ubuf(&iter, ITER_DEST, buf, len);

	ret = call_read_iter(filp, &kiocb, &iter);
	BUG_ON(ret == -EIOCBQUEUED);
	if (ppos)
		*ppos = kiocb.ki_pos;
	return ret;
}
----

[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h
----
static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,
				     struct iov_iter *iter)
{
	return file->f_op->read_iter(kio, iter);
}
----
可见，new_sync_read()调用call_read_iter函数, 最终调用struct file_operations里的:
ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);

对于ext4文件系统，这个file_operations即为ext4_file_operations，这个read_iter函数指针指向ext4_file_write_iter函数():

=== ext4_file_operations
[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
const struct file_operations ext4_file_operations = {
	.llseek		= ext4_llseek,
	.read_iter	= ext4_file_read_iter,
	.write_iter	= ext4_file_write_iter,
	.iopoll		= iocb_bio_iopoll,
	.unlocked_ioctl = ext4_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= ext4_compat_ioctl,
#endif
	.mmap		= ext4_file_mmap,
	.mmap_supported_flags = MAP_SYNC,
	.open		= ext4_file_open,
	.release	= ext4_release_file,
	.fsync		= ext4_sync_file,
	.get_unmapped_area = thp_get_unmapped_area,
	.splice_read	= ext4_file_splice_read,
	.splice_write	= iter_file_splice_write,
	.fallocate	= ext4_fallocate,
};
----

=== ext4_file_read_iter()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
static ssize_t ext4_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct inode *inode = file_inode(iocb->ki_filp);

	if (unlikely(ext4_forced_shutdown(inode->i_sb)))
		return -EIO;

	if (!iov_iter_count(to))
		return 0; /* skip atime */

#ifdef CONFIG_FS_DAX
	if (IS_DAX(inode))
		return ext4_dax_read_iter(iocb, to);
#endif
	if (iocb->ki_flags & IOCB_DIRECT)
		return ext4_dio_read_iter(iocb, to);

	return generic_file_read_iter(iocb, to);
}
----
CONFIG_FS_DAX宏: since 5.15, Direct Access (DAX) can be used on memory-backed block devices. 
参考: https://cateee.net/lkddb/web-lkddb/FS_DAX.html

IOCB_DIRECT: 直接IO，直接访问磁盘数据，不经过内核缓冲区。
直接I/O的优点: 去除了缓存的复制环节，降低了文件读取和写入时CPU的利用率。
使用场景: 有非常低的高速缓存命中率文件数据，或者需要自己定制缓存策略。

抛开DAX与IOCB_DIRECT，generic_file_read_iter函数就是通常的主流程了:

=== generic_file_read_iter()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/mm/filemap.c
----
/**
 * generic_file_read_iter - generic filesystem read routine
 * @iocb:	kernel I/O control block
 * @iter:	destination for the data read
 *
 * This is the "read_iter()" routine for all filesystems
 * that can use the page cache directly.
 *
 * The IOCB_NOWAIT flag in iocb->ki_flags indicates that -EAGAIN shall
 * be returned when no data can be read without waiting for I/O requests
 * to complete; it doesn't prevent readahead.
 *
 * The IOCB_NOIO flag in iocb->ki_flags indicates that no new I/O
 * requests shall be made for the read or for readahead.  When no data
 * can be read, -EAGAIN shall be returned.  When readahead would be
 * triggered, a partial, possibly empty read shall be returned.
 *
 * Return:
 * * number of bytes copied, even for partial reads
 * * negative error code (or 0 if IOCB_NOIO) if nothing was read
 */
ssize_t
generic_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	size_t count = iov_iter_count(iter);
	ssize_t retval = 0;

	if (!count)
		return 0; /* skip atime */

	if (iocb->ki_flags & IOCB_DIRECT) {
		struct file *file = iocb->ki_filp;
		struct address_space *mapping = file->f_mapping;
		struct inode *inode = mapping->host;

		retval = kiocb_write_and_wait(iocb, count);
		if (retval < 0)
			return retval;
		file_accessed(file);

		retval = mapping->a_ops->direct_IO(iocb, iter);
		if (retval >= 0) {
			iocb->ki_pos += retval;
			count -= retval;
		}
		if (retval != -EIOCBQUEUED)
			iov_iter_revert(iter, count - iov_iter_count(iter));

		/*
		 * Btrfs can have a short DIO read if we encounter
		 * compressed extents, so if there was an error, or if
		 * we've already read everything we wanted to, or if
		 * there was a short read because we hit EOF, go ahead
		 * and return.  Otherwise fallthrough to buffered io for
		 * the rest of the read.  Buffered reads will not work for
		 * DAX files, so don't bother trying.
		 */
		if (retval < 0 || !count || IS_DAX(inode))
			return retval;
		if (iocb->ki_pos >= i_size_read(inode))
			return retval;
	}

	return filemap_read(iocb, iter, retval);
}
----
generic_file_read_iter()的主要实现为filemap_read()。

=== filemap_read()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/mm/filemap.c
----
/**
 * filemap_read - Read data from the page cache.
 * @iocb: The iocb to read.
 * @iter: Destination for the data.
 * @already_read: Number of bytes already read by the caller.
 *
 * Copies data from the page cache.  If the data is not currently present,
 * uses the readahead and read_folio address_space operations to fetch it.
 *
 * Return: Total number of bytes copied, including those already read by
 * the caller.  If an error happens before any bytes are copied, returns
 * a negative error number.
 */
ssize_t filemap_read(struct kiocb *iocb, struct iov_iter *iter,
		ssize_t already_read)
{
	struct file *filp = iocb->ki_filp;
	struct file_ra_state *ra = &filp->f_ra;
	struct address_space *mapping = filp->f_mapping;
	struct inode *inode = mapping->host;
	struct folio_batch fbatch;
	int i, error = 0;
	bool writably_mapped;
	loff_t isize, end_offset;
	loff_t last_pos = ra->prev_pos;

	if (unlikely(iocb->ki_pos >= inode->i_sb->s_maxbytes))
		return 0;
	if (unlikely(!iov_iter_count(iter)))
		return 0;

	iov_iter_truncate(iter, inode->i_sb->s_maxbytes);
	folio_batch_init(&fbatch);

	do {
		cond_resched();

		/*
		 * If we've already successfully copied some data, then we
		 * can no longer safely return -EIOCBQUEUED. Hence mark
		 * an async read NOWAIT at that point.
		 */
		if ((iocb->ki_flags & IOCB_WAITQ) && already_read)
			iocb->ki_flags |= IOCB_NOWAIT;

		if (unlikely(iocb->ki_pos >= i_size_read(inode)))
			break;

		error = filemap_get_pages(iocb, iter->count, &fbatch, false);
		if (error < 0)
			break;

		/*
		 * i_size must be checked after we know the pages are Uptodate.
		 *
		 * Checking i_size after the check allows us to calculate
		 * the correct value for "nr", which means the zero-filled
		 * part of the page is not copied back to userspace (unless
		 * another truncate extends the file - this is desired though).
		 */
		isize = i_size_read(inode);
		if (unlikely(iocb->ki_pos >= isize))
			goto put_folios;
		end_offset = min_t(loff_t, isize, iocb->ki_pos + iter->count);

		/*
		 * Once we start copying data, we don't want to be touching any
		 * cachelines that might be contended:
		 */
		writably_mapped = mapping_writably_mapped(mapping);

		/*
		 * When a read accesses the same folio several times, only
		 * mark it as accessed the first time.
		 */
		if (!pos_same_folio(iocb->ki_pos, last_pos - 1,
				    fbatch.folios[0]))
			folio_mark_accessed(fbatch.folios[0]);

		for (i = 0; i < folio_batch_count(&fbatch); i++) {
			struct folio *folio = fbatch.folios[i];
			size_t fsize = folio_size(folio);
			size_t offset = iocb->ki_pos & (fsize - 1);
			size_t bytes = min_t(loff_t, end_offset - iocb->ki_pos,
					     fsize - offset);
			size_t copied;

			if (end_offset < folio_pos(folio))
				break;
			if (i > 0)
				folio_mark_accessed(folio);
			/*
			 * If users can be writing to this folio using arbitrary
			 * virtual addresses, take care of potential aliasing
			 * before reading the folio on the kernel side.
			 */
			if (writably_mapped)
				flush_dcache_folio(folio);

			copied = copy_folio_to_iter(folio, offset, bytes, iter);

			already_read += copied;
			iocb->ki_pos += copied;
			last_pos = iocb->ki_pos;

			if (copied < bytes) {
				error = -EFAULT;
				break;
			}
		}
put_folios:
		for (i = 0; i < folio_batch_count(&fbatch); i++)
			folio_put(fbatch.folios[i]);
		folio_batch_init(&fbatch);
	} while (iov_iter_count(iter) && iocb->ki_pos < isize && !error);

	file_accessed(filp);
	ra->prev_pos = last_pos;
	return already_read ? already_read : error;
}
----
从页缓存中获取数据，如果页缓存中不存在，通过操作address_space来获取。

struct file_ra_state *ra = &filp->f_ra: 表示文件的readahead状态。
readhead即预读，如果每次请求时都读取一个新页面，则可能会出现显著的读取延迟。预读考虑空间局部性提前读取后面的部分来减少顺序读取的延迟时间。

if (unlikely(iocb->ki_pos >= inode->i_sb->s_maxbytes)): 如果ki_pos大于超级块上的最大文件大小，则返回。
if (unlikely(!iov_iter_count(iter))): 如果iov_iter_count为0，则返回。

iov_iter_truncate(iter, inode->i_sb->s_maxbytes): 如果大于超级块上的最大文件大小，超出的部分将被截断。

cond_resched(): 一些比较耗时的处理中如文件系统和内存回收的一些路径会主动调用cond_resched()让出CPU，这对吞吐量有轻微影响，但是响应会稍微快些，不过需要注意的是，cond_resched()是否真正起作用与系统的PREEMPT相关配置有关系。

filemap_get_pages(): 获取到文件对应映射的页面集
filemap_get_pages()从页面缓存中查找页面，如果找不到，则从磁盘中获取页面，最终会将address_space->i_pages中的页面放入一个folio批次中。

计算复制页面时要使用的end_offset: end_offset不应大于文件大小。

mapping_writably_mapped(mapping)检查映射(address_space类型)中是否存在可写映射页。如果用户进程可以写入页缓存，则可能会出现别名问题，因此在复制之前必须调用flush_dcache_folio()。

pos_same_folio()判断如果访问统一页面多次，则仅标记页面访问一次。

folio_mark_accessed()标记页面访问。

之后，循环迭代folio批次中的folio(页面)，调用folio_mark_accessed()标记访问并准备开始复制。

flush_dcache_folio(): 之前检查了该address_space中是否存在可写的映射页，在这种情况下，需要调用flush_dcache_folio()以避免cache别名问题。

copy_folio_to_iter(): 进行页面拷贝，将folio复制到iter指示的用户空间缓冲区。

folio_put()减少folio的引用计数。

可见，整个流程的核心为filemap_get_pages():

=== filemap_get_pages()
[source, c]
.https://elixir.bootlin.com/linux/latest/source/mm/filemap.c
----
static int filemap_get_pages(struct kiocb *iocb, size_t count,
		struct folio_batch *fbatch, bool need_uptodate)
{
	struct file *filp = iocb->ki_filp;
	struct address_space *mapping = filp->f_mapping;
	struct file_ra_state *ra = &filp->f_ra;
	pgoff_t index = iocb->ki_pos >> PAGE_SHIFT;
	pgoff_t last_index;
	struct folio *folio;
	int err = 0;

	/* "last_index" is the index of the page beyond the end of the read */
	last_index = DIV_ROUND_UP(iocb->ki_pos + count, PAGE_SIZE);
retry:
	if (fatal_signal_pending(current))
		return -EINTR;

	filemap_get_read_batch(mapping, index, last_index - 1, fbatch);
	if (!folio_batch_count(fbatch)) {
		if (iocb->ki_flags & IOCB_NOIO)
			return -EAGAIN;
		page_cache_sync_readahead(mapping, ra, filp, index,
				last_index - index);
		filemap_get_read_batch(mapping, index, last_index - 1, fbatch);
	}
	if (!folio_batch_count(fbatch)) {
		if (iocb->ki_flags & (IOCB_NOWAIT | IOCB_WAITQ))
			return -EAGAIN;
		err = filemap_create_folio(filp, mapping,
				iocb->ki_pos >> PAGE_SHIFT, fbatch);
		if (err == AOP_TRUNCATED_PAGE)
			goto retry;
		return err;
	}

	folio = fbatch->folios[folio_batch_count(fbatch) - 1];
	if (folio_test_readahead(folio)) {
		err = filemap_readahead(iocb, filp, mapping, folio, last_index);
		if (err)
			goto err;
	}
	if (!folio_test_uptodate(folio)) {
		if ((iocb->ki_flags & IOCB_WAITQ) &&
		    folio_batch_count(fbatch) > 1)
			iocb->ki_flags |= IOCB_NOWAIT;
		err = filemap_update_page(iocb, mapping, count, folio,
					  need_uptodate);
		if (err)
			goto err;
	}

	return 0;
err:
	if (err < 0)
		folio_put(folio);
	if (likely(--fbatch->nr))
		return 0;
	if (err == AOP_TRUNCATED_PAGE)
		goto retry;
	return err;
}
----
filemap_get_read_batch(mapping, index, last_index - 1, fbatch): 将当前address_space中存在的页面中要读取的页面加载到fbatch中。

如果映射中没有要读取的页面，第一个(!folio_batch_count(fbatch))，则使用page_cache_sync_readahead()执行预读，然后使用filemap_get_read_batch()再次将页面放入fbatch中。

如果在执行上述预读之后fbatch仍为空，则使用filemap_create_folio()将folio添加到页面缓存。

=== 参考
