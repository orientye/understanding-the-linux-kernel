:toc:
:toclevels: 5
:hardbreaks-option:

== ext文件系统

=== 演进
▪ 最早期
最开始直接使用MINIX 1.0文件系统

▪ ext(extended filesystem)
0.96c, 1992
ext使用在内核中的新虚拟文件系统(VFS)抽象层
https://en.wikipedia.org/wiki/Ext2

▪ ext2
0.99, 1993
提供了GB级别的最大文件大小和TB级别的文件系统大小

▪ ext3
2.4.15 - 4.2
由于ext4完全覆盖了ex3的功能，造成了许多功能的重复，最终ext3在4.3版本里被移除: 
https://kernelnewbies.org/Linux_4.3#The_Ext3_filesystem_has_been_removed
https://lwn.net/Articles/651645/

ext2工作得很好，但像FAT、FAT32等当时的其它文件系统一样，在断电时容易发生灾难性的破坏。
如果在将数据写入文件系统时候发生断电，则可能会将其留在所谓不一致的状态，这可能导致大量文件丢失或损坏，这些文件与正在保存的文件无关甚至导致整个文件系统无法卸载。

ext3和20世纪90年代后期的其它文件系统，如微软的NTFS，使用日志来解决这个问题。日志是磁盘上的一种特殊的分配区域，其写入被存储在事务中；如果该事务完成磁盘写入，则日志中的数据将提交给文件系统自身。如果系统在该操作提交前崩溃，则重新启动的系统识别其为未完成的事务而将其进行回滚，就像从未发生过一样。这意味着正在处理的文件可能依然会丢失，但文件系统本身保持一致，且其它所有数据都是安全的。

▪ ext4
2.6.28
ext4(fourth extended filesystem)

=== ext2
https://elixir.bootlin.com/linux/latest/source/include/linux/ext2_fs.h
struct ext2_inode: https://elixir.bootlin.com/linux/latest/source/fs/ext2/ext2.h
struct ext2_dir_entry_2: https://elixir.bootlin.com/linux/latest/source/fs/ext2/ext2.h
磁盘上的ext2_inode数据结构对应内存中的inode结构，二者有很大的不同；
同样地，目录项ext2_dir_entry_2结构对应内存中的dentry结构，二者也有很大的不同。

=== ext4

==== 数据结构
struct ext4_dir_entry: https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h
struct ext4_inode: https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h

[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
const struct file_operations ext4_file_operations = {
	.llseek		= ext4_llseek,
	.read_iter	= ext4_file_read_iter,
	.write_iter	= ext4_file_write_iter,
	.iopoll		= iocb_bio_iopoll,
	.unlocked_ioctl = ext4_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= ext4_compat_ioctl,
#endif
	.mmap		= ext4_file_mmap,
	.mmap_supported_flags = MAP_SYNC,
	.open		= ext4_file_open,
	.release	= ext4_release_file,
	.fsync		= ext4_sync_file,
	.get_unmapped_area = thp_get_unmapped_area,
	.splice_read	= generic_file_splice_read,
	.splice_write	= iter_file_splice_write,
	.fallocate	= ext4_fallocate,
};

const struct inode_operations ext4_file_inode_operations = {
	.setattr	= ext4_setattr,
	.getattr	= ext4_file_getattr,
	.listxattr	= ext4_listxattr,
	.get_inode_acl	= ext4_get_acl,
	.set_acl	= ext4_set_acl,
	.fiemap		= ext4_fiemap,
	.fileattr_get	= ext4_fileattr_get,
	.fileattr_set	= ext4_fileattr_set,
};
----

==== read
[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
static ssize_t ext4_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct inode *inode = file_inode(iocb->ki_filp);

	if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
		return -EIO;

	if (!iov_iter_count(to))
		return 0; /* skip atime */

#ifdef CONFIG_FS_DAX
	if (IS_DAX(inode))
		return ext4_dax_read_iter(iocb, to);
#endif
	if (iocb->ki_flags & IOCB_DIRECT)
		return ext4_dio_read_iter(iocb, to);

	return generic_file_read_iter(iocb, to);
}
----

CONFIG_FS_DAX宏: since 5.15, Direct Access (DAX) can be used on memory-backed block devices. 
参考: https://cateee.net/lkddb/web-lkddb/FS_DAX.html

IOCB_DIRECT: 直接IO，直接访问磁盘数据，不经过内核缓冲区。
直接I/O的有点：去除了缓存的复制环节，降低了文件读取和写入时CPU的利用率。
使用场景: 有非常低的高速缓存命中率文件数据，或者需要自己定制缓存策略。

抛开DAX与IOCB_DIRECT，generic_file_read_iter函数就是通常的主流程了：
[source, c]
.https://elixir.bootlin.com/linux/latest/source/mm/filemap.c
----
/**
 * generic_file_read_iter - generic filesystem read routine
 * @iocb:	kernel I/O control block
 * @iter:	destination for the data read
 *
 * This is the "read_iter()" routine for all filesystems
 * that can use the page cache directly.
 *
 * The IOCB_NOWAIT flag in iocb->ki_flags indicates that -EAGAIN shall
 * be returned when no data can be read without waiting for I/O requests
 * to complete; it doesn't prevent readahead.
 *
 * The IOCB_NOIO flag in iocb->ki_flags indicates that no new I/O
 * requests shall be made for the read or for readahead.  When no data
 * can be read, -EAGAIN shall be returned.  When readahead would be
 * triggered, a partial, possibly empty read shall be returned.
 *
 * Return:
 * * number of bytes copied, even for partial reads
 * * negative error code (or 0 if IOCB_NOIO) if nothing was read
 */
ssize_t
generic_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	size_t count = iov_iter_count(iter);
	ssize_t retval = 0;

	if (!count)
		return 0; /* skip atime */

	if (iocb->ki_flags & IOCB_DIRECT) {
		struct file *file = iocb->ki_filp;
		struct address_space *mapping = file->f_mapping;
		struct inode *inode = mapping->host;

		if (iocb->ki_flags & IOCB_NOWAIT) {
			if (filemap_range_needs_writeback(mapping, iocb->ki_pos,
						iocb->ki_pos + count - 1))
				return -EAGAIN;
		} else {
			retval = filemap_write_and_wait_range(mapping,
						iocb->ki_pos,
					        iocb->ki_pos + count - 1);
			if (retval < 0)
				return retval;
		}

		file_accessed(file);

		retval = mapping->a_ops->direct_IO(iocb, iter);
		if (retval >= 0) {
			iocb->ki_pos += retval;
			count -= retval;
		}
		if (retval != -EIOCBQUEUED)
			iov_iter_revert(iter, count - iov_iter_count(iter));

		/*
		 * Btrfs can have a short DIO read if we encounter
		 * compressed extents, so if there was an error, or if
		 * we've already read everything we wanted to, or if
		 * there was a short read because we hit EOF, go ahead
		 * and return.  Otherwise fallthrough to buffered io for
		 * the rest of the read.  Buffered reads will not work for
		 * DAX files, so don't bother trying.
		 */
		if (retval < 0 || !count || IS_DAX(inode))
			return retval;
		if (iocb->ki_pos >= i_size_read(inode))
			return retval;
	}

	return filemap_read(iocb, iter, retval);
}
----

==== write

[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
static ssize_t
ext4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	struct inode *inode = file_inode(iocb->ki_filp);

	if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
		return -EIO;

#ifdef CONFIG_FS_DAX
	if (IS_DAX(inode))
		return ext4_dax_write_iter(iocb, from);
#endif
	if (iocb->ki_flags & IOCB_DIRECT)
		return ext4_dio_write_iter(iocb, from);
	else
		return ext4_buffered_write_iter(iocb, from);
}
----
可见，ext4_file_write_iter()与上述ext4_file_read_iter()类似。

[source, c]
.https://elixir.bootlin.com/linux/latest/source/fs/ext4/file.c
----
static ssize_t ext4_buffered_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	ssize_t ret;
	struct inode *inode = file_inode(iocb->ki_filp);

	if (iocb->ki_flags & IOCB_NOWAIT)
		return -EOPNOTSUPP;

	inode_lock(inode);
	ret = ext4_write_checks(iocb, from);
	if (ret <= 0)
		goto out;

	current->backing_dev_info = inode_to_bdi(inode);
	ret = generic_perform_write(iocb, from);
	current->backing_dev_info = NULL;

out:
	inode_unlock(inode);
	if (likely(ret > 0)) {
		iocb->ki_pos += ret;
		ret = generic_write_sync(iocb, ret);
	}

	return ret;
}
----

==== 参考
https://en.wikipedia.org/wiki/Ext4
https://lwn.net/Kernel/Index/#Filesystems-ext4

=== 备用文件系统
==== XFS

==== ZFS

==== Btrfs

参考: https://en.wikipedia.org/wiki/Btrfs
参考: https://btrfs.wiki.kernel.org/index.php/Main_Page
参考: https://lwn.net/Kernel/Index/#Btrfs

=== 其它
▪ lost+found

=== 参考
https://opensource.com/article/18/4/ext4-filesystem
https://lrita.github.io/images/posts/filesystem/Linux.Kernel.Write.Procedure.pdf