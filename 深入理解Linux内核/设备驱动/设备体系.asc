:toc:
:toclevels: 5
:hardbreaks-option:

== 设备体系

=== 概念
与外设的通信通常称之为输入输出, 一般称为I/O

扩展硬件:
1 总线系统
2 与外设的交互

    I/O端口
    I/O内存映射
    轮询和中断

3 通过总线控制设备

外设可处于CPU的内存空间和I/O空间, 除x86外, 嵌入式处理器一般只存在内存空间。
在Linux系统中, 为I/O内存和I/O端口的访问提高了一套统一的方法
访问流程一般为: 申请资源→映射→访问→去映射→释放资源
=== I/O体系结构

==== I/O端口
https://elixir.bootlin.com/linux/latest/source/include/linux/ioport.h
https://elixir.bootlin.com/linux/latest/source/kernel/resource.c

=== 设备模型
Bus(总线):
Linux认为总线是CPU和一个或多个设备之间信息交互的通道。
为了方便设备模型的抽象，所有的设备都应连接到总线上(无论是CPU内部总线、虚拟的总线还是"platform Bus")。
struct bus_type: https://elixir.bootlin.com/linux/latest/source/include/linux/device/bus.h
    
Class(分类):
可以在多个设备之间共用的数据结构和接口函数。
从属于相同Class的设备的驱动程序，就不再需要重复定义，直接从Class中继承即可。

Device(设备):
抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。

Device Driver(驱动):
Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。
内核中的驱动开发，基本都围绕该抽象进行，即实现约定的接口函数。

=== 数据结构
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/kobject.h
----
struct kobject {
	const char		*name;
	struct list_head	entry;
	struct kobject		*parent;
	struct kset		*kset;
	const struct kobj_type	*ktype;
	struct kernfs_node	*sd; /* sysfs directory entry */
	struct kref		kref;
#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
	struct delayed_work	release;
#endif
	unsigned int state_initialized:1;
	unsigned int state_in_sysfs:1;
	unsigned int state_add_uevent_sent:1;
	unsigned int state_remove_uevent_sent:1;
	unsigned int uevent_suppress:1;
};

//...

/**
 * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.
 *
 * A kset defines a group of kobjects.  They can be individually
 * different "types" but overall these kobjects all want to be grouped
 * together and operated on in the same manner.  ksets are used to
 * define the attribute callbacks and other common events that happen to
 * a kobject.
 *
 * @list: the list of all kobjects for this kset
 * @list_lock: a lock for iterating over the kobjects
 * @kobj: the embedded kobject for this kset (recursion, isn't it fun...)
 * @uevent_ops: the set of uevent operations for this kset.  These are
 * called whenever a kobject has something happen to it so that the kset
 * can add new environment variables, or filter out the uevents if so
 * desired.
 */
struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
} __randomize_layout;
----

=== Device Tree
3.x开始引入设备树的概念, 用于实现驱动代码与设备信息相分离。
设备树出现以前, 关于设备的具体信息都要写在驱动里, 一旦外围设备变化,驱动代码就要重写。
设备树出现之后, 驱动代码只负责处理驱动的逻辑, 设备的具体信息存放到设备树文件中。
因此, 如果设备信息发生变化, 但驱动逻辑没有发生变化, 只需要修改设备树信息, 不需要改动驱动代码。

=== 参考
http://www.wowotech.net/sort/device_model
https://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html
