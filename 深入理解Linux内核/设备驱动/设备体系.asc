:toc:
:toclevels: 5
:hardbreaks-option:

== 设备体系

=== 概念
与外设的通信通常称之为输入输出, 一般称为I/O

扩展硬件:
1 总线系统
2 与外设的交互

    I/O端口
    I/O内存映射
    轮询和中断

3 通过总线控制设备

外设可处于CPU的内存空间和I/O空间，除x86外，嵌入式处理器一般只存在内存空间。
linux系统为I/O内存和I/O端口的访问提供了一套统一的方法
访问流程一般为: 申请资源→映射→访问→去映射→释放资源

=== I/O体系结构

==== I/O端口
https://elixir.bootlin.com/linux/latest/source/include/linux/ioport.h
https://elixir.bootlin.com/linux/latest/source/kernel/resource.c

=== 设备模型

==== Bus(总线)
Linux认为总线是CPU和一个或多个设备之间信息交互的通道。
为了方便设备模型的抽象，所有的设备都应连接到总线上(无论是CPU内部总线、虚拟的总线还是"platform Bus")。

struct bus_type:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/device/bus.h
----
/**
 * struct bus_type - The bus type of the device
 *
 * @name:	The name of the bus.
 * @dev_name:	Used for subsystems to enumerate devices like ("foo%u", dev->id).
 * @bus_groups:	Default attributes of the bus.
 * @dev_groups:	Default attributes of the devices on the bus.
 * @drv_groups: Default attributes of the device drivers on the bus.
 * @match:	Called, perhaps multiple times, whenever a new device or driver
 *		is added for this bus. It should return a positive value if the
 *		given device can be handled by the given driver and zero
 *		otherwise. It may also return error code if determining that
 *		the driver supports the device is not possible. In case of
 *		-EPROBE_DEFER it will queue the device for deferred probing.
 * @uevent:	Called when a device is added, removed, or a few other things
 *		that generate uevents to add the environment variables.
 * @probe:	Called when a new device or driver add to this bus, and callback
 *		the specific driver's probe to initial the matched device.
 * @sync_state:	Called to sync device state to software state after all the
 *		state tracking consumers linked to this device (present at
 *		the time of late_initcall) have successfully bound to a
 *		driver. If the device has no consumers, this function will
 *		be called at late_initcall_sync level. If the device has
 *		consumers that are never bound to a driver, this function
 *		will never get called until they do.
 * @remove:	Called when a device removed from this bus.
 * @shutdown:	Called at shut-down time to quiesce the device.
 *
 * @online:	Called to put the device back online (after offlining it).
 * @offline:	Called to put the device offline for hot-removal. May fail.
 *
 * @suspend:	Called when a device on this bus wants to go to sleep mode.
 * @resume:	Called to bring a device on this bus out of sleep mode.
 * @num_vf:	Called to find out how many virtual functions a device on this
 *		bus supports.
 * @dma_configure:	Called to setup DMA configuration on a device on
 *			this bus.
 * @dma_cleanup:	Called to cleanup DMA configuration on a device on
 *			this bus.
 * @pm:		Power management operations of this bus, callback the specific
 *		device driver's pm-ops.
 * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
 *              driver implementations to a bus and allow the driver to do
 *              bus-specific setup
 * @need_parent_lock:	When probing or removing a device on this bus, the
 *			device core should lock the device's parent.
 *
 * A bus is a channel between the processor and one or more devices. For the
 * purposes of the device model, all devices are connected via a bus, even if
 * it is an internal, virtual, "platform" bus. Buses can plug into each other.
 * A USB controller is usually a PCI device, for example. The device model
 * represents the actual connections between buses and the devices they control.
 * A bus is represented by the bus_type structure. It contains the name, the
 * default attributes, the bus' methods, PM operations, and the driver core's
 * private data.
 */
struct bus_type {
	const char		*name;
	const char		*dev_name;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;

	int (*match)(struct device *dev, struct device_driver *drv);
	int (*uevent)(const struct device *dev, struct kobj_uevent_env *env);
	int (*probe)(struct device *dev);
	void (*sync_state)(struct device *dev);
	void (*remove)(struct device *dev);
	void (*shutdown)(struct device *dev);

	int (*online)(struct device *dev);
	int (*offline)(struct device *dev);

	int (*suspend)(struct device *dev, pm_message_t state);
	int (*resume)(struct device *dev);

	int (*num_vf)(struct device *dev);

	int (*dma_configure)(struct device *dev);
	void (*dma_cleanup)(struct device *dev);

	const struct dev_pm_ops *pm;

	const struct iommu_ops *iommu_ops;

	bool need_parent_lock;
};
----

==== Class(分类)
可以在多个设备之间共用的数据结构和接口函数。
从属于相同Class的设备的驱动程序，就不再需要重复定义，直接从Class中继承即可。

==== Device(设备)
抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。

==== Device Driver(驱动)
Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。
内核中的驱动开发，基本都围绕该抽象进行，即实现约定的接口函数。

=== Device Tree(设备树)
3.x开始引入设备树的概念, 用于实现驱动代码与设备信息相分离: 让驱动的归驱动C代码，让设备的归设备树脚本。
设备树出现以前, 关于设备的具体信息都要写在驱动里, 一旦外围设备变化, 驱动代码就要重写。
设备树出现之后, 驱动代码只负责处理驱动的逻辑, 设备的具体信息存放到设备树文件中。
因此, 如果设备信息发生变化, 但驱动逻辑没有发生变化, 只需要修改设备树信息, 不需要改动驱动代码。

=== 数据结构
[source, c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/kobject.h
----
struct kobject {
	const char		*name;
	struct list_head	entry;
	struct kobject		*parent;
	struct kset		*kset;
	const struct kobj_type	*ktype;
	struct kernfs_node	*sd; /* sysfs directory entry */
	struct kref		kref;
#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
	struct delayed_work	release;
#endif
	unsigned int state_initialized:1;
	unsigned int state_in_sysfs:1;
	unsigned int state_add_uevent_sent:1;
	unsigned int state_remove_uevent_sent:1;
	unsigned int uevent_suppress:1;
};

//...

/**
 * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.
 *
 * A kset defines a group of kobjects.  They can be individually
 * different "types" but overall these kobjects all want to be grouped
 * together and operated on in the same manner.  ksets are used to
 * define the attribute callbacks and other common events that happen to
 * a kobject.
 *
 * @list: the list of all kobjects for this kset
 * @list_lock: a lock for iterating over the kobjects
 * @kobj: the embedded kobject for this kset (recursion, isn't it fun...)
 * @uevent_ops: the set of uevent operations for this kset.  These are
 * called whenever a kobject has something happen to it so that the kset
 * can add new environment variables, or filter out the uevents if so
 * desired.
 */
struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
} __randomize_layout;
----

=== 参考
http://www.wowotech.net/sort/device_model
https://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html
https://lwn.net/Kernel/Index/#Device_drivers
https://lwn.net/Kernel/Index/#Device_tree
