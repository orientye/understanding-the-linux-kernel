:toc:
:toclevels: 5
:hardbreaks-option:

== 字符设备

=== 结构
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/cdev.h
----
struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
} __randomize_layout;
----

=== 简单字符设备
先看一下简单字符设备，以空设备/dev/null为例:
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/major.h
----
#define MEM_MAJOR		1
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/drivers/char/mem.c
----
static ssize_t read_null(struct file *file, char __user *buf,
			 size_t count, loff_t *ppos)
{
	return 0;
}

static ssize_t write_null(struct file *file, const char __user *buf,
			  size_t count, loff_t *ppos)
{
	return count;
}
//...
static const struct file_operations null_fops = {
	.llseek		= null_lseek,
	.read		= read_null,
	.write		= write_null,
	.read_iter	= read_iter_null,
	.write_iter	= write_iter_null,
	.splice_write	= splice_write_null,
	.uring_cmd	= uring_cmd_null,
};
//...
static const struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
} devlist[] = {
#ifdef CONFIG_DEVMEM
	 [DEVMEM_MINOR] = { "mem", 0, &mem_fops, FMODE_UNSIGNED_OFFSET },
#endif
	 [3] = { "null", 0666, &null_fops, FMODE_NOWAIT },
#ifdef CONFIG_DEVPORT
	 [4] = { "port", 0, &port_fops, 0 },
#endif
	 [5] = { "zero", 0666, &zero_fops, FMODE_NOWAIT },
	 [7] = { "full", 0666, &full_fops, 0 },
	 [8] = { "random", 0666, &random_fops, FMODE_NOWAIT },
	 [9] = { "urandom", 0666, &urandom_fops, FMODE_NOWAIT },
#ifdef CONFIG_PRINTK
	[11] = { "kmsg", 0644, &kmsg_fops, 0 },
#endif
};
//...
static int __init chr_dev_init(void)
{
	int minor;

	if (register_chrdev(MEM_MAJOR, "mem", &memory_fops))
		printk("unable to get major %d for memory devs\n", MEM_MAJOR);

	mem_class = class_create(THIS_MODULE, "mem");
	if (IS_ERR(mem_class))
		return PTR_ERR(mem_class);

	mem_class->devnode = mem_devnode;
	for (minor = 1; minor < ARRAY_SIZE(devlist); minor++) {
		if (!devlist[minor].name)
			continue;

		/*
		 * Create /dev/port?
		 */
		if ((minor == DEVPORT_MINOR) && !arch_has_dev_port())
			continue;

		device_create(mem_class, NULL, MKDEV(MEM_MAJOR, minor),
			      NULL, devlist[minor].name);
	}

	return tty_init();
}
----

=== 终端设备
==== 概念与背景
PC机上一般总是以显示器和键盘(可能还有鼠标)组合成控制台，它们就相当于一个终端。
有些情况下，一个系统的控制台不止一个，linux可以将一套物理的显示器和键盘复用于若干个虚拟控制台(virtual console)，通过ALT+Fn来切换，一般键盘会有12个功能键，对应着设备文件/dev/tty1到/dev/tty12。
/dev/tty0永远代表着系统当前的控制台，如果用户按下了ALT+F2则/dev/tty0代表/dev/tty2。
/dev/console一般是连接到/dev/tty0。

为什么要弄多个虚拟控制台呢? 因为这样在前台可以看到多个任务的输出，比较方便。

向虚拟终端写:
这些设备文件实际上都代表着一个输出缓冲区，写入这些设备的内容都写在缓冲区中，直到选择某个特定的虚拟终端才将其缓冲区的内容显示到屏幕上。
从虚拟终端读:
从虚拟终端读实际上是从键盘读，但是键盘只属于当前控制台，因此从虚拟终端的(同步)读操作一直要到选择了该虚拟终端作为当前控制台并从键盘输入后才返回。

主设备号为4的设备字符不全是虚拟终端，还包括一些通过常规UART串行口连接的实际的实际终端设备。具体来说，此设备号为0的/dev/tty0代表着当前控制台，叫当前虚拟终端外，次设备号1-63代表/dev/tty1至/dev/tty63，代表63个虚拟终端；次设备号64至255则分别为/dev/ttyS0至/dev/ttyS191，它们代表192个可能的UART串行口，即一般的串行终端设备。

此外，与/dev/tty0和/dev/tty1至/dev/tty63相对应，在/dev目录下还有一些主设备号为7，代表虚拟终端缓冲区的字符设备文件/dev/vcs和/dev/vcs1至/dev/vcs63。这些设备文件与代表虚拟终端的设备文件相对应，但有所不同。从某个虚拟终端缓冲区（例如/dev/vcs2）读就是从相应的虚拟终端的输出缓冲区读，而不是像虚拟终端本身那样是从键盘读。二者的写操作也不有所不同，对虚拟终端缓冲区的写操作只是简单的对线性缓冲区的操作，而并不像虚拟终端那样以缓冲区来模拟显示器的屏幕。这两种设备的file_options结构也不同，一个为vcs_fops，一个为tty_fops。

此外还有其它类型的终端设备。
还有一种设备叫伪终端(pseudo tty)在逻辑上是终端设备。

参考: 《Linux内核源代码情景分析》8.7

=== console
https://elixir.bootlin.com/linux/latest/source/drivers/video/console
https://elixir.bootlin.com/linux/latest/source/drivers/video/fbdev

https://elixir.bootlin.com/linux/latest/source/include/linux/console_struct.h

控制台输入:
https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input-event-codes.h

https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/keyboard.c

参考: https://www.cnblogs.com/tsecer/p/10485886.html

控制台输出:

    printf进入write系统调用:
    helloworld-24714 [003] 531976.050326: funcgraph_entry:                   |  __x64_sys_write() {
    helloworld-24714 [003] 531976.050327: funcgraph_entry:                   |    ksys_write() {
    helloworld-24714 [003] 531976.050327: funcgraph_entry:                   |      vfs_write() {
    helloworld-24714 [003] 531976.050328: funcgraph_entry:                   |        new_sync_write() {
    helloworld-24714 [003] 531976.050329: funcgraph_entry:                   |          tty_write() {

    tty_write(): https://elixir.bootlin.com/linux/latest/source/drivers/tty/tty_io.c
        file_tty_write()
            n_tty_write()
                con_write(): https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/vt.c
                    do_con_write()

    helloworld-24799 [002] 532659.588813: funcgraph_entry:                   |  tty_write() {
    helloworld-24799 [002] 532659.588815: funcgraph_entry:                   |    file_tty_write.constprop.0() {
    helloworld-24799 [002] 532659.588817: funcgraph_entry:                   |      n_tty_write() {
    helloworld-24799 [002] 532659.588820: funcgraph_entry:                   |          tty_write_room() {
    helloworld-24799 [002] 532659.588820: funcgraph_entry:        0.063 us   |            con_write_room();
    helloworld-24799 [002] 532659.588820: funcgraph_entry:                   |          con_write() {
    helloworld-24799 [002] 532659.588821: funcgraph_entry:                   |            do_con_write() {
    helloworld-24799 [002] 532659.588851: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588852: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588853: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588854: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588856: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588857: funcgraph_entry:                   |              vc_con_write_normal() {

pty:
https://elixir.bootlin.com/linux/latest/source/arch/um/drivers/pty.c

v0.12:
https://elixir.bootlin.com/linux/0.12/source/kernel/chr_drv/console.c

参考: https://www.cnblogs.com/tsecer/p/10485870.html
