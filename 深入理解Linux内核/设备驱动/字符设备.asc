:toc:
:toclevels: 5
:hardbreaks-option:

== 字符设备

=== 结构
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/cdev.h
----
struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
} __randomize_layout;
----

=== 简单字符设备
先看一下简单字符设备，以空设备/dev/null为例:
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/major.h
----
#define MEM_MAJOR		1
----

[source,c]
.https://elixir.bootlin.com/linux/latest/source/drivers/char/mem.c
----
static ssize_t read_null(struct file *file, char __user *buf,
			 size_t count, loff_t *ppos)
{
	return 0;
}

static ssize_t write_null(struct file *file, const char __user *buf,
			  size_t count, loff_t *ppos)
{
	return count;
}
//...
static const struct file_operations null_fops = {
	.llseek		= null_lseek,
	.read		= read_null,
	.write		= write_null,
	.read_iter	= read_iter_null,
	.write_iter	= write_iter_null,
	.splice_write	= splice_write_null,
	.uring_cmd	= uring_cmd_null,
};
//...
static const struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
} devlist[] = {
#ifdef CONFIG_DEVMEM
	 [DEVMEM_MINOR] = { "mem", 0, &mem_fops, FMODE_UNSIGNED_OFFSET },
#endif
	 [3] = { "null", 0666, &null_fops, FMODE_NOWAIT },
#ifdef CONFIG_DEVPORT
	 [4] = { "port", 0, &port_fops, 0 },
#endif
	 [5] = { "zero", 0666, &zero_fops, FMODE_NOWAIT },
	 [7] = { "full", 0666, &full_fops, 0 },
	 [8] = { "random", 0666, &random_fops, FMODE_NOWAIT },
	 [9] = { "urandom", 0666, &urandom_fops, FMODE_NOWAIT },
#ifdef CONFIG_PRINTK
	[11] = { "kmsg", 0644, &kmsg_fops, 0 },
#endif
};
//...
static int __init chr_dev_init(void)
{
	int minor;

	if (register_chrdev(MEM_MAJOR, "mem", &memory_fops))
		printk("unable to get major %d for memory devs\n", MEM_MAJOR);

	mem_class = class_create(THIS_MODULE, "mem");
	if (IS_ERR(mem_class))
		return PTR_ERR(mem_class);

	mem_class->devnode = mem_devnode;
	for (minor = 1; minor < ARRAY_SIZE(devlist); minor++) {
		if (!devlist[minor].name)
			continue;

		/*
		 * Create /dev/port?
		 */
		if ((minor == DEVPORT_MINOR) && !arch_has_dev_port())
			continue;

		device_create(mem_class, NULL, MKDEV(MEM_MAJOR, minor),
			      NULL, devlist[minor].name);
	}

	return tty_init();
}
----

=== 终端设备
==== 概念与背景
PC机上一般总是以显示器和键盘(可能还有鼠标)组合成控制台，它们就相当于一个终端。

有些情况下，一个系统的控制台不止一个，linux可以将一套物理的显示器和键盘复用于若干个虚拟终端，通过ALT+Fn来切换。第一个到第六个虚拟控制台是字符终端，第七个虚拟控制台是图形终端，对应ALT+F1到ALT+F7，对应/dev/tty1到/dev/tty7，这七个终端使用同一个显示器和键盘，这些特殊的终端模拟程序叫做虚拟终端。

7个虚拟终端对应dev/tty1到/dev/tty7。
/dev/tty0永远代表着系统当前的控制台，例如如果用户按下了ALT+F2则/dev/tty0代表/dev/tty2。
/dev/console一般是连接到/dev/tty0。

为什么要弄多个虚拟终端/虚拟控制台呢? 因为这样在前台可以看到多个任务的输出，比较方便。

向虚拟终端写:
这些设备文件实际上都代表着一个输出缓冲区，写入这些设备的内容都写在缓冲区中，直到选择某个特定的虚拟终端才将其缓冲区的内容显示到屏幕上。
从虚拟终端读:
从虚拟终端读实际上是从键盘读，但是键盘只属于当前控制台，因此从虚拟终端的(同步)读操作一直要到选择了该虚拟终端作为当前控制台并从键盘输入后才返回。

主设备号为4的设备字符不全是虚拟终端，还包括一些通过常规UART串行口连接的实际的实际终端设备。具体来说，除设备号为0的/dev/tty0代表着当前控制台，叫当前虚拟终端外，次设备号1-63代表/dev/tty1至/dev/tty63，代表63个虚拟终端；次设备号64至255则分别为/dev/ttyS0至/dev/ttyS191，它们代表192个可能的UART串行口，即一般的串行终端设备。

此外，与/dev/tty0和/dev/tty1至/dev/ttyN相对应，在/dev目录下还有一些主设备号为7，代表虚拟终端缓冲区的字符设备文件/dev/vcs和/dev/vcs1至/dev/vcsN。这些设备文件与代表虚拟终端的设备文件相对应，但有所不同。从某个虚拟终端缓冲区（例如/dev/vcs2）读就是从相应的虚拟终端的输出缓冲区读，而不是像虚拟终端本身那样是从键盘读。二者的写操作也不有所不同，对虚拟终端缓冲区的写操作只是简单的对线性缓冲区的操作，而并不像虚拟终端那样以缓冲区来模拟显示器的屏幕。这两种设备的file_operations结构也不同，一个为vcs_fops，一个为tty_fops。

此外还有其它类型的终端设备，例如一些串口终端设备。

还有一种设备叫伪终端(pseudo tty)在逻辑上是终端设备，通常对应远端的shell。显然，伪终端不同于常规的终端设备，它们的驱动程序也理应有所不同，但是实际上却共享同一个file_operations结构，即tty_fops。事实上，主设备号为2，3，4，5（除7以外）的字符设备，以及分配给各家串行口厂商的主设备号对应的字符设备，全都使用同一个file_operations数据结构。但这并不意味着所有这些设备都使用相同的设备驱动程序，而是说明：
1. 终端设备的驱动程序至少可以分成两层以上，最上层是公共的，因此有相同的入口。
2. 不同类终端设备的读写操作不同，需要有一个类似于file_operations的跳转结构。
3. 终端设备驱动程序也跟信息传输的方式有关，例如通过RS232电缆相连的终端跟通过Modem相连的终端肯定不一样，因此，一定还存在着另一个与传输方式有关的函数跳转结构。
参考: 《Linux内核源代码情景分析》8.7

通过​​/proc/tty/drivers​​文件，可查看当前内核中的tty driver，例如:
orient@my-ubuntu:~$ cat /proc/tty/drivers
驱动名称              节点名称    主设备号 次设备号范围 驱动类型
/dev/tty             /dev/tty        5       0      system:/dev/tty
/dev/console         /dev/console    5       1      system:console
/dev/ptmx            /dev/ptmx       5       2      system
/dev/vc/0            /dev/vc/0       4       0      system:vtmaster
ttyprintk            /dev/ttyprintk  5       3      console
max310x              /dev/ttyMAX   204 209-224      serial
serial               /dev/ttyS       4 64-111       serial
pty_slave            /dev/pts      136 0-1048575    pty:slave
pty_master           /dev/ptm      128 0-1048575    pty:master
unknown              /dev/tty        4 1-63         console

通过​​/sys/class/tty​​目录，即ls -l /sys/class/tty/可查看当前内核中的tty设备对应的符号链接。

==== tty框架
-----------------------
        vfs
-----------------------
      tty core
-----------------------
    tty_ldisc(line discipline): tty_ldisc_ops
-----------------------
    tty_driver: tty_operations, tty_port, tty_port_operations
-----------------------
        物理层
-----------------------

tty core:
接口层， tty_open, tty_read, tty_write, tty_poll等
是对终端概念的抽象, 实现了各种不同类型的终端的通用功能

tty_ldisc:
行规程层

tty_driver:
驱动层

参考: https://blog.csdn.net/lickylin/article/details/105851077
参考: https://blog.csdn.net/liangzc1124/article/details/127469767
参考: https://www.cnblogs.com/jliuxin/p/14129303.html

==== tty_driver
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h
----
/**
 * struct tty_driver -- driver for TTY devices
 *
 * @magic: set to %TTY_DRIVER_MAGIC in __tty_alloc_driver()
 * @kref: reference counting. Reaching zero frees all the internals and the
 *	  driver.
 * @cdevs: allocated/registered character /dev devices
 * @owner: modules owning this driver. Used drivers cannot be rmmod'ed.
 *	   Automatically set by tty_alloc_driver().
 * @driver_name: name of the driver used in /proc/tty
 * @name: used for constructing /dev node name
 * @name_base: used as a number base for constructing /dev node name
 * @major: major /dev device number (zero for autoassignment)
 * @minor_start: the first minor /dev device number
 * @num: number of devices allocated
 * @type: type of tty driver (%TTY_DRIVER_TYPE_)
 * @subtype: subtype of tty driver (%SYSTEM_TYPE_, %PTY_TYPE_, %SERIAL_TYPE_)
 * @init_termios: termios to set to each tty initially (e.g. %tty_std_termios)
 * @flags: tty driver flags (%TTY_DRIVER_)
 * @proc_entry: proc fs entry, used internally
 * @other: driver of the linked tty; only used for the PTY driver
 * @ttys: array of active &struct tty_struct, set by tty_standard_install()
 * @ports: array of &struct tty_port; can be set during initialization by
 *	   tty_port_link_device() and similar
 * @termios: storage for termios at each TTY close for the next open
 * @driver_state: pointer to driver's arbitrary data
 * @ops: driver hooks for TTYs. Set them using tty_set_operations(). Use &struct
 *	 tty_port helpers in them as much as possible.
 * @tty_drivers: used internally to link tty_drivers together
 *
 * The usual handling of &struct tty_driver is to allocate it by
 * tty_alloc_driver(), set up all the necessary members, and register it by
 * tty_register_driver(). At last, the driver is torn down by calling
 * tty_unregister_driver() followed by tty_driver_kref_put().
 *
 * The fields required to be set before calling tty_register_driver() include
 * @driver_name, @name, @type, @subtype, @init_termios, and @ops.
 */
struct tty_driver {
	int	magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module	*owner;
	const char	*driver_name;
	const char	*name;
	int	name_base;
	int	major;
	int	minor_start;
	unsigned int	num;
	short	type;
	short	subtype;
	struct ktermios init_termios;
	unsigned long	flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;

	/*
	 * Pointer to the tty data structures
	 */
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;

	/*
	 * Driver methods
	 */

	const struct tty_operations *ops;
	struct list_head tty_drivers;
} __randomize_layout;
----

==== tty_port
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty_port.h
----
/**
 * struct tty_port_operations -- operations on tty_port
 * @carrier_raised: return 1 if the carrier is raised on @port
 * @dtr_rts: raise the DTR line if @raise is nonzero, otherwise lower DTR
 * @shutdown: called when the last close completes or a hangup finishes IFF the
 *	port was initialized. Do not use to free resources. Turn off the device
 *	only. Called under the port mutex to serialize against @activate and
 *	@shutdown.
 * @activate: called under the port mutex from tty_port_open(), serialized using
 *	the port mutex. Supposed to turn on the device.
 *
 *	FIXME: long term getting the tty argument *out* of this would be good
 *	for consoles.
 *
 * @destruct: called on the final put of a port. Free resources, possibly incl.
 *	the port itself.
 */
struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *port);
	void (*dtr_rts)(struct tty_port *port, int raise);
	void (*shutdown)(struct tty_port *port);
	int (*activate)(struct tty_port *port, struct tty_struct *tty);
	void (*destruct)(struct tty_port *port);
};
//...
/**
 * struct tty_port -- port level information
 *
 * @buf: buffer for this port, locked internally
 * @tty: back pointer to &struct tty_struct, valid only if the tty is open. Use
 *	 tty_port_tty_get() to obtain it (and tty_kref_put() to release).
 * @itty: internal back pointer to &struct tty_struct. Avoid this. It should be
 *	  eliminated in the long term.
 * @ops: tty port operations (like activate, shutdown), see &struct
 *	 tty_port_operations
 * @client_ops: tty port client operations (like receive_buf, write_wakeup).
 *		By default, tty_port_default_client_ops is used.
 * @lock: lock protecting @tty
 * @blocked_open: # of procs waiting for open in tty_port_block_til_ready()
 * @count: usage count
 * @open_wait: open waiters queue (waiting e.g. for a carrier)
 * @delta_msr_wait: modem status change queue (waiting for MSR changes)
 * @flags: user TTY flags (%ASYNC_)
 * @iflags: internal flags (%TTY_PORT_)
 * @console: when set, the port is a console
 * @mutex: locking, for open, shutdown and other port operations
 * @buf_mutex: @xmit_buf alloc lock
 * @xmit_buf: optional xmit buffer used by some drivers
 * @xmit_fifo: optional xmit buffer used by some drivers
 * @close_delay: delay in jiffies to wait when closing the port
 * @closing_wait: delay in jiffies for output to be sent before closing
 * @drain_delay: set to zero if no pure time based drain is needed else set to
 *		 size of fifo
 * @kref: references counter. Reaching zero calls @ops->destruct() if non-%NULL
 *	  or frees the port otherwise.
 * @client_data: pointer to private data, for @client_ops
 *
 * Each device keeps its own port level information. &struct tty_port was
 * introduced as a common structure for such information. As every TTY device
 * shall have a backing tty_port structure, every driver can use these members.
 *
 * The tty port has a different lifetime to the tty so must be kept apart.
 * In addition be careful as tty -> port mappings are valid for the life
 * of the tty object but in many cases port -> tty mappings are valid only
 * until a hangup so don't use the wrong path.
 *
 * Tty port shall be initialized by tty_port_init() and shut down either by
 * tty_port_destroy() (refcounting not used), or tty_port_put() (refcounting).
 *
 * There is a lot of helpers around &struct tty_port too. To name the most
 * significant ones: tty_port_open(), tty_port_close() (or
 * tty_port_close_start() and tty_port_close_end() separately if need be), and
 * tty_port_hangup(). These call @ops->activate() and @ops->shutdown() as
 * needed.
 */
struct tty_port {
	struct tty_bufhead	buf;
	struct tty_struct	*tty;
	struct tty_struct	*itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t		lock;
	int			blocked_open;
	int			count;
	wait_queue_head_t	open_wait;
	wait_queue_head_t	delta_msr_wait;
	unsigned long		flags;
	unsigned long		iflags;
	unsigned char		console:1;
	struct mutex		mutex;
	struct mutex		buf_mutex;
	unsigned char		*xmit_buf;
	DECLARE_KFIFO_PTR(xmit_fifo, unsigned char);
	unsigned int		close_delay;
	unsigned int		closing_wait;
	int			drain_delay;
	struct kref		kref;
	void			*client_data;
};
----

==== tty_buffer
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h
----
struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int lookahead;		/* Lazy update on recv, can become less than "read" */
	int read;
	int flags;
	/* Data points here */
	unsigned long data[];
};
//...
struct tty_bufhead {
	struct tty_buffer *head;	/* Queue head */
	struct work_struct work;
	struct mutex	   lock;
	atomic_t	   priority;
	struct tty_buffer sentinel;
	struct llist_head free;		/* Free queue head */
	atomic_t	   mem_used;    /* In-use buffers excluding free list */
	int		   mem_limit;
	struct tty_buffer *tail;	/* Active buffer */
};
----

参考: https://lwn.net/Articles/105770/

==== tty_operations
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h
----
/**
 * struct tty_operations -- interface between driver and tty
 *
 * @lookup: ``struct tty_struct *()(struct tty_driver *self, struct file *,
 *				    int idx)``
 *
 *	Return the tty device corresponding to @idx, %NULL if there is not
 *	one currently in use and an %ERR_PTR value on error. Called under
 *	%tty_mutex (for now!)
 *
 *	Optional method. Default behaviour is to use the @self->ttys array.
 *
 * @install: ``int ()(struct tty_driver *self, struct tty_struct *tty)``
 *
 *	Install a new @tty into the @self's internal tables. Used in
 *	conjunction with @lookup and @remove methods.
 *
 *	Optional method. Default behaviour is to use the @self->ttys array.
 *
 * @remove: ``void ()(struct tty_driver *self, struct tty_struct *tty)``
 *
 *	Remove a closed @tty from the @self's internal tables. Used in
 *	conjunction with @lookup and @remove methods.
 *
 *	Optional method. Default behaviour is to use the @self->ttys array.
 *
 * @open: ``int ()(struct tty_struct *tty, struct file *)``
 *
 *	This routine is called when a particular @tty device is opened. This
 *	routine is mandatory; if this routine is not filled in, the attempted
 *	open will fail with %ENODEV.
 *
 *	Required method. Called with tty lock held. May sleep.
 *
 * @close: ``void ()(struct tty_struct *tty, struct file *)``
 *
 *	This routine is called when a particular @tty device is closed. At the
 *	point of return from this call the driver must make no further ldisc
 *	calls of any kind.
 *
 *	Remark: called even if the corresponding @open() failed.
 *
 *	Required method. Called with tty lock held. May sleep.
 *
 * @shutdown: ``void ()(struct tty_struct *tty)``
 *
 *	This routine is called under the tty lock when a particular @tty device
 *	is closed for the last time. It executes before the @tty resources
 *	are freed so may execute while another function holds a @tty kref.
 *
 * @cleanup: ``void ()(struct tty_struct *tty)``
 *
 *	This routine is called asynchronously when a particular @tty device
 *	is closed for the last time freeing up the resources. This is
 *	actually the second part of shutdown for routines that might sleep.
 *
 * @write: ``int ()(struct tty_struct *tty, const unsigned char *buf,
 *		    int count)``
 *
 *	This routine is called by the kernel to write a series (@count) of
 *	characters (@buf) to the @tty device. The characters may come from
 *	user space or kernel space.  This routine will return the
 *	number of characters actually accepted for writing.
 *
 *	May occur in parallel in special cases. Because this includes panic
 *	paths drivers generally shouldn't try and do clever locking here.
 *
 *	Optional: Required for writable devices. May not sleep.
 *
 * @put_char: ``int ()(struct tty_struct *tty, unsigned char ch)``
 *
 *	This routine is called by the kernel to write a single character @ch to
 *	the @tty device. If the kernel uses this routine, it must call the
 *	@flush_chars() routine (if defined) when it is done stuffing characters
 *	into the driver. If there is no room in the queue, the character is
 *	ignored.
 *
 *	Optional: Kernel will use the @write method if not provided. Do not
 *	call this function directly, call tty_put_char().
 *
 * @flush_chars: ``void ()(struct tty_struct *tty)``
 *
 *	This routine is called by the kernel after it has written a
 *	series of characters to the tty device using @put_char().
 *
 *	Optional. Do not call this function directly, call
 *	tty_driver_flush_chars().
 *
 * @write_room: ``unsigned int ()(struct tty_struct *tty)``
 *
 *	This routine returns the numbers of characters the @tty driver
 *	will accept for queuing to be written.  This number is subject
 *	to change as output buffers get emptied, or if the output flow
 *	control is acted.
 *
 *	The ldisc is responsible for being intelligent about multi-threading of
 *	write_room/write calls
 *
 *	Required if @write method is provided else not needed. Do not call this
 *	function directly, call tty_write_room()
 *
 * @chars_in_buffer: ``unsigned int ()(struct tty_struct *tty)``
 *
 *	This routine returns the number of characters in the device private
 *	output queue. Used in tty_wait_until_sent() and for poll()
 *	implementation.
 *
 *	Optional: if not provided, it is assumed there is no queue on the
 *	device. Do not call this function directly, call tty_chars_in_buffer().
 *
 * @ioctl: ``int ()(struct tty_struct *tty, unsigned int cmd,
 *		    unsigned long arg)``
 *
 *	This routine allows the @tty driver to implement device-specific
 *	ioctls. If the ioctl number passed in @cmd is not recognized by the
 *	driver, it should return %ENOIOCTLCMD.
 *
 *	Optional.
 *
 * @compat_ioctl: ``long ()(struct tty_struct *tty, unsigned int cmd,
 *			  unsigned long arg)``
 *
 *	Implement ioctl processing for 32 bit process on 64 bit system.
 *
 *	Optional.
 *
 * @set_termios: ``void ()(struct tty_struct *tty, struct ktermios *old)``
 *
 *	This routine allows the @tty driver to be notified when device's
 *	termios settings have changed. New settings are in @tty->termios.
 *	Previous settings are passed in the @old argument.
 *
 *	The API is defined such that the driver should return the actual modes
 *	selected. This means that the driver is responsible for modifying any
 *	bits in @tty->termios it cannot fulfill to indicate the actual modes
 *	being used.
 *
 *	Optional. Called under the @tty->termios_rwsem. May sleep.
 *
 * @set_ldisc: ``void ()(struct tty_struct *tty)``
 *
 *	This routine allows the @tty driver to be notified when the device's
 *	line discipline is being changed. At the point this is done the
 *	discipline is not yet usable.
 *
 *	Optional. Called under the @tty->ldisc_sem and @tty->termios_rwsem.
 *
 * @throttle: ``void ()(struct tty_struct *tty)``
 *
 *	This routine notifies the @tty driver that input buffers for the line
 *	discipline are close to full, and it should somehow signal that no more
 *	characters should be sent to the @tty.
 *
 *	Serialization including with @unthrottle() is the job of the ldisc
 *	layer.
 *
 *	Optional: Always invoke via tty_throttle_safe(). Called under the
 *	@tty->termios_rwsem.
 *
 * @unthrottle: ``void ()(struct tty_struct *tty)``
 *
 *	This routine notifies the @tty driver that it should signal that
 *	characters can now be sent to the @tty without fear of overrunning the
 *	input buffers of the line disciplines.
 *
 *	Optional. Always invoke via tty_unthrottle(). Called under the
 *	@tty->termios_rwsem.
 *
 * @stop: ``void ()(struct tty_struct *tty)``
 *
 *	This routine notifies the @tty driver that it should stop outputting
 *	characters to the tty device.
 *
 *	Called with @tty->flow.lock held. Serialized with @start() method.
 *
 *	Optional. Always invoke via stop_tty().
 *
 * @start: ``void ()(struct tty_struct *tty)``
 *
 *	This routine notifies the @tty driver that it resumed sending
 *	characters to the @tty device.
 *
 *	Called with @tty->flow.lock held. Serialized with stop() method.
 *
 *	Optional. Always invoke via start_tty().
 *
 * @hangup: ``void ()(struct tty_struct *tty)``
 *
 *	This routine notifies the @tty driver that it should hang up the @tty
 *	device.
 *
 *	Optional. Called with tty lock held.
 *
 * @break_ctl: ``int ()(struct tty_struct *tty, int state)``
 *
 *	This optional routine requests the @tty driver to turn on or off BREAK
 *	status on the RS-232 port. If @state is -1, then the BREAK status
 *	should be turned on; if @state is 0, then BREAK should be turned off.
 *
 *	If this routine is implemented, the high-level tty driver will handle
 *	the following ioctls: %TCSBRK, %TCSBRKP, %TIOCSBRK, %TIOCCBRK.
 *
 *	If the driver sets %TTY_DRIVER_HARDWARE_BREAK in tty_alloc_driver(),
 *	then the interface will also be called with actual times and the
 *	hardware is expected to do the delay work itself. 0 and -1 are still
 *	used for on/off.
 *
 *	Optional: Required for %TCSBRK/%BRKP/etc. handling. May sleep.
 *
 * @flush_buffer: ``void ()(struct tty_struct *tty)``
 *
 *	This routine discards device private output buffer. Invoked on close,
 *	hangup, to implement %TCOFLUSH ioctl and similar.
 *
 *	Optional: if not provided, it is assumed there is no queue on the
 *	device. Do not call this function directly, call
 *	tty_driver_flush_buffer().
 *
 * @wait_until_sent: ``void ()(struct tty_struct *tty, int timeout)``
 *
 *	This routine waits until the device has written out all of the
 *	characters in its transmitter FIFO. Or until @timeout (in jiffies) is
 *	reached.
 *
 *	Optional: If not provided, the device is assumed to have no FIFO.
 *	Usually correct to invoke via tty_wait_until_sent(). May sleep.
 *
 * @send_xchar: ``void ()(struct tty_struct *tty, char ch)``
 *
 *	This routine is used to send a high-priority XON/XOFF character (@ch)
 *	to the @tty device.
 *
 *	Optional: If not provided, then the @write method is called under
 *	the @tty->atomic_write_lock to keep it serialized with the ldisc.
 *
 * @tiocmget: ``int ()(struct tty_struct *tty)``
 *
 *	This routine is used to obtain the modem status bits from the @tty
 *	driver.
 *
 *	Optional: If not provided, then %ENOTTY is returned from the %TIOCMGET
 *	ioctl. Do not call this function directly, call tty_tiocmget().
 *
 * @tiocmset: ``int ()(struct tty_struct *tty,
 *		       unsigned int set, unsigned int clear)``
 *
 *	This routine is used to set the modem status bits to the @tty driver.
 *	First, @clear bits should be cleared, then @set bits set.
 *
 *	Optional: If not provided, then %ENOTTY is returned from the %TIOCMSET
 *	ioctl. Do not call this function directly, call tty_tiocmset().
 *
 * @resize: ``int ()(struct tty_struct *tty, struct winsize *ws)``
 *
 *	Called when a termios request is issued which changes the requested
 *	terminal geometry to @ws.
 *
 *	Optional: the default action is to update the termios structure
 *	without error. This is usually the correct behaviour. Drivers should
 *	not force errors here if they are not resizable objects (e.g. a serial
 *	line). See tty_do_resize() if you need to wrap the standard method
 *	in your own logic -- the usual case.
 *
 * @get_icount: ``int ()(struct tty_struct *tty,
 *			 struct serial_icounter *icount)``
 *
 *	Called when the @tty device receives a %TIOCGICOUNT ioctl. Passed a
 *	kernel structure @icount to complete.
 *
 *	Optional: called only if provided, otherwise %ENOTTY will be returned.
 *
 * @get_serial: ``int ()(struct tty_struct *tty, struct serial_struct *p)``
 *
 *	Called when the @tty device receives a %TIOCGSERIAL ioctl. Passed a
 *	kernel structure @p (&struct serial_struct) to complete.
 *
 *	Optional: called only if provided, otherwise %ENOTTY will be returned.
 *	Do not call this function directly, call tty_tiocgserial().
 *
 * @set_serial: ``int ()(struct tty_struct *tty, struct serial_struct *p)``
 *
 *	Called when the @tty device receives a %TIOCSSERIAL ioctl. Passed a
 *	kernel structure @p (&struct serial_struct) to set the values from.
 *
 *	Optional: called only if provided, otherwise %ENOTTY will be returned.
 *	Do not call this function directly, call tty_tiocsserial().
 *
 * @show_fdinfo: ``void ()(struct tty_struct *tty, struct seq_file *m)``
 *
 *	Called when the @tty device file descriptor receives a fdinfo request
 *	from VFS (to show in /proc/<pid>/fdinfo/). @m should be filled with
 *	information.
 *
 *	Optional: called only if provided, otherwise nothing is written to @m.
 *	Do not call this function directly, call tty_show_fdinfo().
 *
 * @poll_init: ``int ()(struct tty_driver *driver, int line, char *options)``
 *
 *	kgdboc support (Documentation/dev-tools/kgdb.rst). This routine is
 *	called to initialize the HW for later use by calling @poll_get_char or
 *	@poll_put_char.
 *
 *	Optional: called only if provided, otherwise skipped as a non-polling
 *	driver.
 *
 * @poll_get_char: ``int ()(struct tty_driver *driver, int line)``
 *
 *	kgdboc support (see @poll_init). @driver should read a character from a
 *	tty identified by @line and return it.
 *
 *	Optional: called only if @poll_init provided.
 *
 * @poll_put_char: ``void ()(struct tty_driver *driver, int line, char ch)``
 *
 *	kgdboc support (see @poll_init). @driver should write character @ch to
 *	a tty identified by @line.
 *
 *	Optional: called only if @poll_init provided.
 *
 * @proc_show: ``int ()(struct seq_file *m, void *driver)``
 *
 *	Driver @driver (cast to &struct tty_driver) can show additional info in
 *	/proc/tty/driver/<driver_name>. It is enough to fill in the information
 *	into @m.
 *
 *	Optional: called only if provided, otherwise no /proc entry created.
 *
 * This structure defines the interface between the low-level tty driver and
 * the tty routines. These routines can be defined. Unless noted otherwise,
 * they are optional, and can be filled in with a %NULL pointer.
 */
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
			struct file *filp, int idx);
	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int  (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int  (*write)(struct tty_struct * tty,
		      const unsigned char *buf, int count);
	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	unsigned int (*write_room)(struct tty_struct *tty);
	unsigned int (*chars_in_buffer)(struct tty_struct *tty);
	int  (*ioctl)(struct tty_struct *tty,
		    unsigned int cmd, unsigned long arg);
	long (*compat_ioctl)(struct tty_struct *tty,
			     unsigned int cmd, unsigned long arg);
	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
	void (*throttle)(struct tty_struct * tty);
	void (*unthrottle)(struct tty_struct * tty);
	void (*stop)(struct tty_struct *tty);
	void (*start)(struct tty_struct *tty);
	void (*hangup)(struct tty_struct *tty);
	int (*break_ctl)(struct tty_struct *tty, int state);
	void (*flush_buffer)(struct tty_struct *tty);
	void (*set_ldisc)(struct tty_struct *tty);
	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
	void (*send_xchar)(struct tty_struct *tty, char ch);
	int (*tiocmget)(struct tty_struct *tty);
	int (*tiocmset)(struct tty_struct *tty,
			unsigned int set, unsigned int clear);
	int (*resize)(struct tty_struct *tty, struct winsize *ws);
	int (*get_icount)(struct tty_struct *tty,
				struct serial_icounter_struct *icount);
	int  (*get_serial)(struct tty_struct *tty, struct serial_struct *p);
	int  (*set_serial)(struct tty_struct *tty, struct serial_struct *p);
	void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
#ifdef CONFIG_CONSOLE_POLL
	int (*poll_init)(struct tty_driver *driver, int line, char *options);
	int (*poll_get_char)(struct tty_driver *driver, int line);
	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
#endif
	int (*proc_show)(struct seq_file *m, void *driver);
} __randomize_layout;
----

==== tty_struct
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty.h
----
/**
 * struct tty_struct - state associated with a tty while open
 *
 * @magic: magic value set early in @alloc_tty_struct to %TTY_MAGIC, for
 *	   debugging purposes
 * @kref: reference counting by tty_kref_get() and tty_kref_put(), reaching zero
 *	  frees the structure
 * @dev: class device or %NULL (e.g. ptys, serdev)
 * @driver: &struct tty_driver operating this tty
 * @ops: &struct tty_operations of @driver for this tty (open, close, etc.)
 * @index: index of this tty (e.g. to construct @name like tty12)
 * @ldisc_sem: protects line discipline changes (@ldisc) -- lock tty not pty
 * @ldisc: the current line discipline for this tty (n_tty by default)
 * @atomic_write_lock: protects against concurrent writers, i.e. locks
 *		       @write_cnt, @write_buf and similar
 * @legacy_mutex: leftover from history (BKL -> BTM -> @legacy_mutex),
 *		  protecting several operations on this tty
 * @throttle_mutex: protects against concurrent tty_throttle_safe() and
 *		    tty_unthrottle_safe() (but not tty_unthrottle())
 * @termios_rwsem: protects @termios and @termios_locked
 * @winsize_mutex: protects @winsize
 * @termios: termios for the current tty, copied from/to @driver.termios
 * @termios_locked: locked termios (by %TIOCGLCKTRMIOS and %TIOCSLCKTRMIOS
 *		    ioctls)
 * @name: name of the tty constructed by tty_line_name() (e.g. ttyS3)
 * @flags: bitwise OR of %TTY_THROTTLED, %TTY_IO_ERROR, ...
 * @count: count of open processes, reaching zero cancels all the work for
 *	   this tty and drops a @kref too (but does not free this tty)
 * @winsize: size of the terminal "window" (cf. @winsize_mutex)
 * @flow: flow settings grouped together, see also @flow.unused
 * @flow.lock: lock for @flow members
 * @flow.stopped: tty stopped/started by stop_tty()/start_tty()
 * @flow.tco_stopped: tty stopped/started by %TCOOFF/%TCOON ioctls (it has
 *		      precedence over @flow.stopped)
 * @flow.unused: alignment for Alpha, so that no members other than @flow.* are
 *		 modified by the same 64b word store. The @flow's __aligned is
 *		 there for the very same reason.
 * @ctrl: control settings grouped together, see also @ctrl.unused
 * @ctrl.lock: lock for @ctrl members
 * @ctrl.pgrp: process group of this tty (setpgrp(2))
 * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both
 *		  @ctrl.lock and @legacy_mutex, readers must use at least one of
 *		  them.
 * @ctrl.pktstatus: packet mode status (bitwise OR of %TIOCPKT_ constants)
 * @ctrl.packet: packet mode enabled
 * @ctrl.unused: alignment for Alpha, see @flow.unused for explanation
 * @hw_stopped: not controlled by the tty layer, under @driver's control for CTS
 *		handling
 * @receive_room: bytes permitted to feed to @ldisc without any being lost
 * @flow_change: controls behavior of throttling, see tty_throttle_safe() and
 *		 tty_unthrottle_safe()
 * @link: link to another pty (master -> slave and vice versa)
 * @fasync: state for %O_ASYNC (for %SIGIO); managed by fasync_helper()
 * @write_wait: concurrent writers are waiting in this queue until they are
 *		allowed to write
 * @read_wait: readers wait for data in this queue
 * @hangup_work: normally a work to perform a hangup (do_tty_hangup()); while
 *		 freeing the tty, (re)used to release_one_tty()
 * @disc_data: pointer to @ldisc's private data (e.g. to &struct n_tty_data)
 * @driver_data: pointer to @driver's private data (e.g. &struct uart_state)
 * @files_lock:	protects @tty_files list
 * @tty_files: list of (re)openers of this tty (i.e. linked &struct
 *	       tty_file_private)
 * @closing: when set during close, n_tty processes only START & STOP chars
 * @write_buf: temporary buffer used during tty_write() to copy user data to
 * @write_cnt: count of bytes written in tty_write() to @write_buf
 * @SAK_work: if the tty has a pending do_SAK, it is queued here
 * @port: persistent storage for this device (i.e. &struct tty_port)
 *
 * All of the state associated with a tty while the tty is open. Persistent
 * storage for tty devices is referenced here as @port and is documented in
 * &struct tty_port.
 */
struct tty_struct {
	int	magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;

	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;

	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios, termios_locked;
	char name[64];
	unsigned long flags;
	int count;
	struct winsize winsize;

	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
		unsigned long unused[0];
	} __aligned(sizeof(unsigned long)) flow;

	struct {
		spinlock_t lock;
		struct pid *pgrp;
		struct pid *session;
		unsigned char pktstatus;
		bool packet;
		unsigned long unused[0];
	} __aligned(sizeof(unsigned long)) ctrl;

	int hw_stopped;
	unsigned int receive_room;
	int flow_change;

	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;

#define N_TTY_BUF_SIZE 4096

	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
} __randomize_layout;
----

==== tty_ldisc
[source,c]
.https://elixir.bootlin.com/linux/latest/source/include/linux/tty_driver.h
----
/**
 * struct tty_ldisc_ops - ldisc operations
 *
 * @name: name of this ldisc rendered in /proc/tty/ldiscs
 * @num: ``N_*`` number (%N_TTY, %N_HDLC, ...) reserved to this ldisc
 *
 * @open: [TTY] ``int ()(struct tty_struct *tty)``
 *
 *	This function is called when the line discipline is associated with the
 *	@tty. No other call into the line discipline for this tty will occur
 *	until it completes successfully. It should initialize any state needed
 *	by the ldisc, and set @tty->receive_room to the maximum amount of data
 *	the line discipline is willing to accept from the driver with a single
 *	call to @receive_buf(). Returning an error will prevent the ldisc from
 *	being attached.
 *
 *	Can sleep.
 *
 * @close: [TTY] ``void ()(struct tty_struct *tty)``
 *
 *	This function is called when the line discipline is being shutdown,
 *	either because the @tty is being closed or because the @tty is being
 *	changed to use a new line discipline. At the point of execution no
 *	further users will enter the ldisc code for this tty.
 *
 *	Can sleep.
 *
 * @flush_buffer: [TTY] ``void ()(struct tty_struct *tty)``
 *
 *	This function instructs the line discipline to clear its buffers of any
 *	input characters it may have queued to be delivered to the user mode
 *	process. It may be called at any point between open and close.
 *
 * @read: [TTY] ``ssize_t ()(struct tty_struct *tty, struct file *file,
 *		unsigned char *buf, size_t nr)``
 *
 *	This function is called when the user requests to read from the @tty.
 *	The line discipline will return whatever characters it has buffered up
 *	for the user. If this function is not defined, the user will receive
 *	an %EIO error. Multiple read calls may occur in parallel and the ldisc
 *	must deal with serialization issues.
 *
 *	Can sleep.
 *
 * @write: [TTY] ``ssize_t ()(struct tty_struct *tty, struct file *file,
 *		const unsigned char *buf, size_t nr)``
 *
 *	This function is called when the user requests to write to the @tty.
 *	The line discipline will deliver the characters to the low-level tty
 *	device for transmission, optionally performing some processing on the
 *	characters first. If this function is not defined, the user will
 *	receive an %EIO error.
 *
 *	Can sleep.
 *
 * @ioctl: [TTY] ``int ()(struct tty_struct *tty, unsigned int cmd,
 *		unsigned long arg)``
 *
 *	This function is called when the user requests an ioctl which is not
 *	handled by the tty layer or the low-level tty driver. It is intended
 *	for ioctls which affect line discpline operation.  Note that the search
 *	order for ioctls is (1) tty layer, (2) tty low-level driver, (3) line
 *	discpline. So a low-level driver can "grab" an ioctl request before
 *	the line discpline has a chance to see it.
 *
 * @compat_ioctl: [TTY] ``int ()(struct tty_struct *tty, unsigned int cmd,
 *		unsigned long arg)``
 *
 *	Process ioctl calls from 32-bit process on 64-bit system.
 *
 *	Note that only ioctls that are neither "pointer to compatible
 *	structure" nor tty-generic.  Something private that takes an integer or
 *	a pointer to wordsize-sensitive structure belongs here, but most of
 *	ldiscs will happily leave it %NULL.
 *
 * @set_termios: [TTY] ``void ()(struct tty_struct *tty, struct ktermios *old)``
 *
 *	This function notifies the line discpline that a change has been made
 *	to the termios structure.
 *
 * @poll: [TTY] ``int ()(struct tty_struct *tty, struct file *file,
 *		  struct poll_table_struct *wait)``
 *
 *	This function is called when a user attempts to select/poll on a @tty
 *	device. It is solely the responsibility of the line discipline to
 *	handle poll requests.
 *
 * @hangup: [TTY] ``void ()(struct tty_struct *tty)``
 *
 *	Called on a hangup. Tells the discipline that it should cease I/O to
 *	the tty driver. The driver should seek to perform this action quickly
 *	but should wait until any pending driver I/O is completed. No further
 *	calls into the ldisc code will occur.
 *
 *	Can sleep.
 *
 * @receive_buf: [DRV] ``void ()(struct tty_struct *tty,
 *		       const unsigned char *cp, const char *fp, int count)``
 *
 *	This function is called by the low-level tty driver to send characters
 *	received by the hardware to the line discpline for processing. @cp is
 *	a pointer to the buffer of input character received by the device. @fp
 *	is a pointer to an array of flag bytes which indicate whether a
 *	character was received with a parity error, etc. @fp may be %NULL to
 *	indicate all data received is %TTY_NORMAL.
 *
 * @write_wakeup: [DRV] ``void ()(struct tty_struct *tty)``
 *
 *	This function is called by the low-level tty driver to signal that line
 *	discpline should try to send more characters to the low-level driver
 *	for transmission. If the line discpline does not have any more data to
 *	send, it can just return. If the line discipline does have some data to
 *	send, please arise a tasklet or workqueue to do the real data transfer.
 *	Do not send data in this hook, it may lead to a deadlock.
 *
 * @dcd_change: [DRV] ``void ()(struct tty_struct *tty, unsigned int status)``
 *
 *	Tells the discipline that the DCD pin has changed its status. Used
 *	exclusively by the %N_PPS (Pulse-Per-Second) line discipline.
 *
 * @receive_buf2: [DRV] ``int ()(struct tty_struct *tty,
 *			const unsigned char *cp, const char *fp, int count)``
 *
 *	This function is called by the low-level tty driver to send characters
 *	received by the hardware to the line discpline for processing. @cp is a
 *	pointer to the buffer of input character received by the device.  @fp
 *	is a pointer to an array of flag bytes which indicate whether a
 *	character was received with a parity error, etc. @fp may be %NULL to
 *	indicate all data received is %TTY_NORMAL. If assigned, prefer this
 *	function for automatic flow control.
 *
 * @lookahead_buf: [DRV] ``void ()(struct tty_struct *tty,
 *			const unsigned char *cp, const char *fp, int count)``
 *
 *	This function is called by the low-level tty driver for characters
 *	not eaten by ->receive_buf() or ->receive_buf2(). It is useful for
 *	processing high-priority characters such as software flow-control
 *	characters that could otherwise get stuck into the intermediate
 *	buffer until tty has room to receive them. Ldisc must be able to
 *	handle later a ->receive_buf() or ->receive_buf2() call for the
 *	same characters (e.g. by skipping the actions for high-priority
 *	characters already handled by ->lookahead_buf()).
 *
 * @owner: module containting this ldisc (for reference counting)
 *
 * This structure defines the interface between the tty line discipline
 * implementation and the tty routines. The above routines can be defined.
 * Unless noted otherwise, they are optional, and can be filled in with a %NULL
 * pointer.
 *
 * Hooks marked [TTY] are invoked from the TTY core, the [DRV] ones from the
 * tty_driver side.
 */
struct tty_ldisc_ops {
	char	*name;
	int	num;

	/*
	 * The following routines are called from above.
	 */
	int	(*open)(struct tty_struct *tty);
	void	(*close)(struct tty_struct *tty);
	void	(*flush_buffer)(struct tty_struct *tty);
	ssize_t	(*read)(struct tty_struct *tty, struct file *file,
			unsigned char *buf, size_t nr,
			void **cookie, unsigned long offset);
	ssize_t	(*write)(struct tty_struct *tty, struct file *file,
			 const unsigned char *buf, size_t nr);
	int	(*ioctl)(struct tty_struct *tty, unsigned int cmd,
			unsigned long arg);
	int	(*compat_ioctl)(struct tty_struct *tty, unsigned int cmd,
			unsigned long arg);
	void	(*set_termios)(struct tty_struct *tty, struct ktermios *old);
	__poll_t (*poll)(struct tty_struct *tty, struct file *file,
			     struct poll_table_struct *wait);
	void	(*hangup)(struct tty_struct *tty);

	/*
	 * The following routines are called from below.
	 */
	void	(*receive_buf)(struct tty_struct *tty, const unsigned char *cp,
			       const char *fp, int count);
	void	(*write_wakeup)(struct tty_struct *tty);
	void	(*dcd_change)(struct tty_struct *tty, unsigned int status);
	int	(*receive_buf2)(struct tty_struct *tty, const unsigned char *cp,
				const char *fp, int count);
	void	(*lookahead_buf)(struct tty_struct *tty, const unsigned char *cp,
				 const unsigned char *fp, unsigned int count);

	struct  module *owner;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};
----

ldisc(Line Discipline)表示链路规则的意思。这个结构有供上层调用的函数指针open,close,read,write等，也有供下层调用的函数指针
receive_buf,write_wakeup等。

[source,c]
.https://elixir.bootlin.com/linux/latest/source/drivers/tty/tty_ldisc.c
----
/* Line disc dispatch table */
static struct tty_ldisc_ops *tty_ldiscs[NR_LDISCS];
----

==== 参考
https://docs.kernel.org/driver-api/tty/index.html
http://www.wowotech.net/sort/tty_framework
http://www.wowotech.net/tty_framework/435.html

=== console
https://elixir.bootlin.com/linux/latest/source/drivers/video/console
https://elixir.bootlin.com/linux/latest/source/drivers/video/fbdev

https://elixir.bootlin.com/linux/latest/source/include/linux/console_struct.h

==== 输入
https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input-event-codes.h

[source,c]
.https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/keyboard.c
----
static void kbd_event(struct input_handle *handle, unsigned int event_type,
		      unsigned int event_code, int value)
{
	/* We are called with interrupts disabled, just take the lock */
	spin_lock(&kbd_event_lock);

	if (event_type == EV_MSC && event_code == MSC_RAW &&
			kbd_is_hw_raw(handle->dev))
		kbd_rawcode(value);
	if (event_type == EV_KEY && event_code <= KEY_MAX)
		kbd_keycode(event_code, value, kbd_is_hw_raw(handle->dev));

	spin_unlock(&kbd_event_lock);

	tasklet_schedule(&keyboard_tasklet);
	do_poke_blanked_console = 1;
	schedule_console_callback();
}
----

参考: https://www.cnblogs.com/tsecer/p/10485886.html

==== 输出

    printf进入write系统调用:
    helloworld-24714 [003] 531976.050326: funcgraph_entry:                   |  __x64_sys_write() {
    helloworld-24714 [003] 531976.050327: funcgraph_entry:                   |    ksys_write() {
    helloworld-24714 [003] 531976.050327: funcgraph_entry:                   |      vfs_write() {
    helloworld-24714 [003] 531976.050328: funcgraph_entry:                   |        new_sync_write() {
    helloworld-24714 [003] 531976.050329: funcgraph_entry:                   |          tty_write() {

    tty_write(): https://elixir.bootlin.com/linux/latest/source/drivers/tty/tty_io.c
        file_tty_write()
            n_tty_write(): https://elixir.bootlin.com/linux/latest/source/drivers/tty/n_tty.c
                con_write(): https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/vt.c
                    do_con_write()

    helloworld-24799 [002] 532659.588813: funcgraph_entry:                   |  tty_write() {
    helloworld-24799 [002] 532659.588815: funcgraph_entry:                   |    file_tty_write.constprop.0() {
    helloworld-24799 [002] 532659.588817: funcgraph_entry:                   |      n_tty_write() {
    helloworld-24799 [002] 532659.588820: funcgraph_entry:                   |          tty_write_room() {
    helloworld-24799 [002] 532659.588820: funcgraph_entry:        0.063 us   |            con_write_room();
    helloworld-24799 [002] 532659.588820: funcgraph_entry:                   |          con_write() {
    helloworld-24799 [002] 532659.588821: funcgraph_entry:                   |            do_con_write() {
    helloworld-24799 [002] 532659.588851: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588852: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588853: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588854: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588856: funcgraph_entry:                   |              vc_con_write_normal() {
    helloworld-24799 [002] 532659.588857: funcgraph_entry:                   |              vc_con_write_normal() {

[source,c]
.https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/vt.c
----
struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};
//...
static struct console vt_console_driver = {
	.name		= "tty",
	.write		= vt_console_print,
	.device		= vt_console_device,
	.unblank	= unblank_screen,
	.flags		= CON_PRINTBUFFER,
	.index		= -1,
};
----

==== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/chr_drv/console.c

==== 参考
https://www.cnblogs.com/tsecer/p/10485870.html

=== pty
https://elixir.bootlin.com/linux/latest/source/arch/um/drivers/pty.c

