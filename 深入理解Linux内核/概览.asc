:toc:
:toclevels: 5
:hardbreaks-option:

== 概览

=== 为什么要学习linux内核
- 吃饭的家伙
    linux内核可以分为驱动与内核两个大的方向。
    驱动工程师一般分布在嵌入式设备，芯片原厂等公司，其工作方向主要是驱动开发，集成适配，性能优化等
    内核工程师一般分布在基础软件，安全领域，芯片或互联网巨头公司，其工作方向主要是是内核开发，性能优化，安全加固等

- 更深入地理解计算机系统
    操作系统是管理计算机硬件与软件资源的计算机程序，而linux又是开源操作系统里的璀璨明珠。
    深入地理解linux, 能让我们更深入地理解计算机系统, 写出性能更好的程序，更快地debug一些疑难问题。
    另外，linux系统发展30多年了，庞大复杂，很多软件设计上的类似问题，或许都能在这里找到类似的成熟的工业级的解决方案。

- just for fun
    linux是几千万的C代码加上少量汇编的庞然大物，管理着各式各样的硬件与软件，它强调稳定性，性能，并行/并发安全, 代码充满技巧，难于调试，毫无疑问，充满了乐趣与挑战性。

=== linux的历史

    ▪ Unix 1969, 1970年C语言, 重写
        ▪ Unix history:
            https://en.wikipedia.org/wiki/History_of_Unix#/media/File:Unix_history-simple.svg
            https://www.cnblogs.com/Solstice/p/unix_bwk.html
        ▪ Linux vs. Unix: https://www.zhihu.com/question/23710284
    ▪ 1983年GNU
    ▪ Minix 1987
    ▪ Linux 1991 Linus Torvalds
    ▪ 版本历史: https://en.wikipedia.org/wiki/Linux_kernel_version_history
    ▪ 版本历史: https://kernelnewbies.org/LinuxVersions
    ▪ 版本历史: https://cdn.kernel.org/pub/linux/kernel/
    ▪ 2020-01-01 统计: https://phoronix.com/misc/linux-eoy2019/index.html  27852148行(包括文档、配置、用户空间实用程序等)
    
    ▪ 最新统计在3000多万行
    ▪ 但其实并不可怕:
        drivers目录接近2000万行，arch目录接近400万行
        核心kernel小于50万行，fs小于150万行，net小于120万行，mm在15万行左右

=== linux与其它操作系统
- 宏内核 微内核 混合内核

    微内核(micro kernel): 把不是最核心的内核功能独立成服务进程(用户态), 然后这些服务进程使用IPC来通信, 也正因如此内核更微小
    微内核的优点: 扩展性好
    微内核的缺点: 性能较差
    例如, L4操作系统: https://en.wikipedia.org/wiki/L4_microkernel_family

    宏内核(macro kernel): 模块集中
    宏内核的优点: 性能好
    宏内核的缺点: 功能耦合, 扩展性差些
    linux是宏内核

    混合内核(hybrid kernel):
    类似微内核，但独立出来的功能依然放在内核，不通过IPC来调用
    特点: 高内聚低耦合 兼具宏内核微内核的特点
    Windows NT(from windows2000)和Darwin-XNU都算是混合内核
    《Mac OS X and iOS Internals》第8章Hybrid Kernels一节: Windows和MacOS虽然是混合内核，但实际上还是宏内核。
    
    参考: https://www.zhihu.com/question/20314255
    参考: https://github.com/apple/darwin-xnu

- 实时与非实时

    实时操作系统(RTOS)保证任务在特定时间内完成。
    硬实时操作系统必须使任务在确定的时间内完成。
    软实时操作系统能让绝大多数任务在确定时间内完成。

    Q: linux是实时操作系统吗?支持硬实时吗?为什么?PREEMPT_RT?
    A: linux是通用操作系统, 典型的实时操作系统如Vxworks。linux通过补丁PREEMPT_RT支持实时, 但只能算是软实时。
    参考: https://rt.wiki.kernel.org/index.php/Frequently_Asked_Questions

=== linux架构概览
- linux全景图
image:https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[]
.Image source: https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[window=read-later]

- 模块与层次

    对于全景图，我们横向地看，即是模块。纵向地看，即是层次。

    横向看全景图, linux分为以下几个大模块:
    system
    processing
    memory
    storage
    networking
    human interface
    如果把storage和human interface看成文件系统的话, 内核也可以看成系统, 进程, 内存, 文件, 网络5个模块。

    纵向看全景图, linux分为以下个层次:
    user space interfaces
    virtual
    bridges
    functiontal
    device control
    hardware interfaces
    如果粗略地看, 也可以将linux内核看成系统接口层, 实现层, 硬件抽象层3个层次。

    从操作系统的角度上看, 不是所有的操作系统具有这些类似的模块的：
    有些操作系统没有进程管理，例如MSDOS
    有些操作系统没有文件系统，例如一些"嵌入式"操作系统

    内核一般要做到arch与drivers的软件架构分离。
    
    从全景图上也可以看出, linux是一个宏内核结构, 模块间耦合性较强, 这也是linux内核代码分析的难点。

- 代码结构

    include/uapi:
        https://lwn.net/Articles/507832/
        https://lwn.net/Articles/507794/

=== helloworld

下面，我们将从用户空间入手，结合内核，深入理解一下hellworld程序。

    附测试机器信息:
    $ uname -a
    Linux my-ubuntu 5.4.0-94-generic #106-Ubuntu SMP Thu Jan 6 23:58:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
    $ cat /etc/issue
    Ubuntu 20.04.3 LTS

==== 编译运行helloworld程序, 究竟发生了什么
[source, c]
.helloworld.c
----
#include <stdio.h>
int main(int argc, char* argv[]) {
        printf("helloworld");
        return 0;
}
----

gcc helloworld.c -o helloworld 编译生成可执行文件helloworld.

接下来，我们通过几个命令认识一下可执行程序以及执行的过程:

===== 1. gcc
gcc -v helloworld.c -o helloworld(执行-v选项可以看到编译链接子过程):

可以看到预处理, 编译, 汇编(as命令), 链接(collct2命令)等过程
预处理生成展开文件，编译生成汇编文件，汇编生成目标文件，链接生成可执行文件或库文件。
当然, 也可以分步骤看:

    预处理：gcc -v -E helloworld.c -o helloworld.i
    编译：gcc -v -S  helloworld.i -o helloworld.s
    汇编: gcc -v -c helloworld.s -o helloworld.o
    链接: gcc -v helloworld.o -o helloworld

这样, 就生成了可执行文件helloworld。

TIP: -v选项可以看到编译链接子过程, 如果带上-g选项, 生成的可执行文件还会附带上源码级的调试符号信息。

使用gcc -S -fno-asynchronous-unwind-tables helloworld.c -o helloworld.s命令，生成的helloworld.s文件主要内容如下:

[source, assembly]
----           
            .file   "helloworld.c"
            .text
            .section        .rodata
    .LC0:
            .string "helloworld"
            .text
            .globl  main
            .type   main, @function
    main:
            endbr64                    # endbr64这是Control-flow Enforcement Technology(CET)技术
            pushq   %rbp               # 上一个堆栈帧rbp入栈
            movq    %rsp, %rbp         # 设置当前堆栈帧rbp
            subq    $16, %rsp          # 两个函数局部变量的空间, 即argc, argv
            movl    %edi, -4(%rbp)     # 第一个局部变量即argc入栈
            movq    %rsi, -16(%rbp)    # 第二个局部变量即argv入栈
            leaq    .LC0(%rip), %rdi   # printf函数的第一个参数, 即helloworld字符串
            movl    $0, %eax           # printf函数的浮点数参数个数为0
            call    printf@PLT         # 调用printf  PLT(Procedure Linkage Table)
            movl    $0, %eax           # 返回值
            leave                      # 恢复到原堆栈帧
            ret                        # 返回
----

===== 2. readelf
执行readelf -a helloworld(或readelf -S helloworld):
    
    可以看到这么一段:
    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    ...
    [12] .init             PROGBITS         0000000000001000  00001000
        000000000000001b  0000000000000000  AX       0     0     4
    [13] .plt              PROGBITS         0000000000001020  00001020
        0000000000000020  0000000000000010  AX       0     0     16
    [14] .plt.got          PROGBITS         0000000000001040  00001040
        0000000000000010  0000000000000010  AX       0     0     16
    [15] .plt.sec          PROGBITS         0000000000001050  00001050
        0000000000000010  0000000000000010  AX       0     0     16
    [16] .text             PROGBITS         0000000000001060  00001060
        0000000000000185  0000000000000000  AX       0     0     16
    [17] .fini             PROGBITS         00000000000011e8  000011e8
        000000000000000d  0000000000000000  AX       0     0     4
    [18] .rodata           PROGBITS         0000000000002000  00002000
        000000000000000f  0000000000000000   A       0     0     4
    ...
    [25] .data             PROGBITS         0000000000004000  00003000
        0000000000000010  0000000000000000  WA       0     0     8
    [26] .bss              NOBITS           0000000000004010  00003010
        0000000000000008  0000000000000000  WA       0     0     1
    [27] .comment          PROGBITS         0000000000000000  00003010
        000000000000002a  0000000000000001  MS       0     0     1
    ...
       
    如上述结果, .text里的00001060实际上就是代码段的起始地址。
    该命令结果里的ELF Header能看到Entry point address: 0x1060这一行，也验证了这一点。(objdump -f helloworld命令也可以)
    同理, 还能看到rodata(只读常量数据), data段(初始化过的数据), bss段(Block Started by Symbol, 未初始化数据), 且text段, rodata段, data段, bss段地址依次增大。
    也印证了下图中进程的虚拟内存。

.Image source: CSAPP chapter9
image::img/vm-of-a-process.png[]

参考: https://en.wikipedia.org/wiki/Data_segment
参考: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

===== 3. objdump
执行objdump -d helloworld:

[source, assembly]
----
Disassembly of section .text:

0000000000001060 <_start>:
    1060:	f3 0f 1e fa          	endbr64                         # endbr64这是Control-flow Enforcement Technology(CET)技术
    1064:	31 ed                	xor    %ebp,%ebp                # %ebp=0
    1066:	49 89 d1             	mov    %rdx,%r9                 # %r9=终止函数地址, __libc_start_main第6个参数(即rtld_fini)
    1069:	5e                   	pop    %rsi                     # %rsi=argc, __libc_start_main第2个参数
    106a:	48 89 e2             	mov    %rsp,%rdx                # %rdx=argv, __libc_start_main第3个参数
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp # 栈按16字节对齐
    1071:	50                   	push   %rax                     # 保存%rax, 仅仅为了栈对齐，是一个无效值
    1072:	54                   	push   %rsp                     # stack_end __libc_start_main第7个参数，保存在栈上
    1073:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8          # 11f0 <__libc_csu_fini>  __libc_start_main第5个参数
    107a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx          # 1180 <__libc_csu_init>  __libc_start_main第4个参数
    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi          # 1149 <main>             __libc_start_main第1个参数
    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)            # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    108e:	f4                   	hlt    
    108f:	90                   	nop

0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    ... 
----

首先需要说明的是, 在不考虑浮点参数的情况下, 对于X86-64下System V AMD64 ABI, 函数前六个参数通过RDI, RSI, RDX, RCX, R8, R9传递, 超过6个的参数则放在栈上。参考: https://en.wikipedia.org/wiki/X86_calling_conventions

可以看到_start的位置正是上面readelf命令里打印出来的.text段的首地址。

_start调用链:

    __libc_start_main
        main
            printf

__libc_start_main函数:
https://elixir.bootlin.com/glibc/glibc-2.25/source/csu/libc-start.c#L107

    STATIC int
    LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
            int argc, char **argv,
    #ifdef LIBC_START_MAIN_AUXVEC_ARG
            ElfW(auxv_t) *auxvec,
    #endif
            __typeof (main) init,
            void (*fini) (void),
            void (*rtld_fini) (void), void *stack_end)

ElfW(auxv_t) *auxvec这个参数究竟有没有呢？(如果有，就应该是8个参数)
在我实验的平台上，是没有的(参考上面的汇编代码), 验证过程请参考下一节的GDB.

1149这个main函数地址怎么来的呢? 看1081这一行: 0xc1 + 1081 + 该条指令本身7个字节 = 1149

参考: https://github.com/bminor/glibc/blob/master/sysdeps/x86_64/start.S 里面有注释
参考: https://xinqiu.gitbooks.io/linux-insides-cn/content/Misc/linux-misc-4.html
参考: https://wiki.osdev.org/Creating_a_C_Library
参考: https://lyyl.online/posts/2085258898.html
参考: http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

===== 4. gdb
使用gdb执行如下命令:

[source, shell]
----
orient@my-ubuntu:/data$ gdb -q helloworld
Reading symbols from helloworld...
(gdb) set backtrace past-entry
(gdb) set backtrace past-main
(gdb) break main
Breakpoint 1 at 0x1149: file helloworld.c, line 2.
(gdb) run
Starting program: /data/helloworld
Breakpoint 1, main (argc=0, argv=0x7fffffffe4f0) at helloworld.c:2
2	int main(int argc, char* argv[]) {
(gdb) bt
#0  main (argc=0, argv=0x7fffffffe4f0) at helloworld.c:2
#1  0x00007ffff7df70b3 in __libc_start_main (main=0x555555555149 <main>, argc=1, argv=0x7fffffffe4f8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffe4e8) at ../csu/libc-start.c:308
#2  0x000055555555508e in _start ()
----

可以看到__libc_start_main的参数依次是: main, argc, argv, init, fini, rtld_fini和stack_end共7个参数，没有auxvec这个参数。

===== 5. strace
执行strace ./helloworld(ltrace -S ./helloworld命令也有类似strace的效果), 显示结果如下:

[source, c]
----
//This is your program starting. Since it is dynamically linked, the first code to execute is from the dynamic loader.
execve("./helloworld", ["./helloworld"], 0x7ffe13915b40 /* 25 vars */) = 0

//The dynamic loader is allocating some heap space.
brk(NULL)                               = 0x55a0d53bd000
arch_prctl(0x3001 /* ARCH_??? */, 0x7fff1b4310e0) = -1 EINVAL (Invalid argument)
//0x3001: ARCH_CET_STATUS https://elixir.bootlin.com/glibc/latest/source/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h

//The dynamic loader checks whether there are dynamic libraries to preload. There aren not any.
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)

/*
The dynamic loader is looking for libc6, which is the standard library. It looks in several directories: first in the directories specified in the LD_LIBRARY_PATH, then in the directories listed in /etc/ld.so.conf. (See the manual for the full story.). In each directory, the loader checks several subdirectories first: it determines which hardware features are present (P6 instructions, SSE2), and looks for a version of the library binary which may use these extra features to run more efficiently; when it fails to find one that may use all the features, it looks for a more generic one. In the end, the library is found in a standard system directory, in a non-specialized version.
*/
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=26248, ...}) = 0
mmap(NULL, 26248, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0271290000
close(3)                                = 0


//The standard library is loaded, then its initialization code runs.
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360q\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f027128e000
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
mmap(NULL, 2036952, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f027109c000
mprotect(0x7f02710c1000, 1847296, PROT_NONE) = 0
mmap(0x7f02710c1000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7f02710c1000
mmap(0x7f0271239000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19d000) = 0x7f0271239000
mmap(0x7f0271284000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f0271284000
mmap(0x7f027128a000, 13528, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f027128a000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f027128f540) = 0
mprotect(0x7f0271284000, 12288, PROT_READ) = 0
mprotect(0x55a0d4e00000, 4096, PROT_READ) = 0
mprotect(0x7f02712c4000, 4096, PROT_READ) = 0
munmap(0x7f0271290000, 26248)           = 0

//This is the result of executing the printf call.
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}) = 0
brk(NULL)                               = 0x55a0d53bd000
brk(0x55a0d53de000)                     = 0x55a0d53de000

//This is your program exiting, which includes flushing the stdout buffer.
write(1, "helloworld", 10helloworld)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
----

参考: http://glennastory.net/?p=870
参考: https://unix.stackexchange.com/questions/160578/strace-hello-world-program
参考: https://github.com/lattera/glibc/blob/master/sysdeps/x86_64/dl-machine.h
参考: https://stackoverflow.com/questions/26876247/how-does-execve-call-dynamic-linker-loader-ld-linux-so-2
参考: https://grugq.github.io/docs/ul_exec.txt
参考: https://blog.csdn.net/welljrj/article/details/90228534
参考: https://blog.csdn.net/welljrj/article/details/90346108

===== 6. ftrace trace-cmd
更进一步地，上面的strace的结果里输出的execve等系统调用怎么执行的呢？
除了源代码，我们也可以借助ftrace/trace-cmd工具来查看，这里我们采用更为方便的trace-cmd工具(ftrace可以跟踪内核函数的执行，trace-cmd则是ftrace的前端)。

具体步骤如下:
(1) 打开shell，输入./hellworld(但先不要按enter执行)
(2) 再打开一个shell, 执行sudo trace-cmd record -p function_graph -g *sys_execve --max-graph-depth 3
(3) 第一个shell里按enter以执行./helloworld
(4) 第二个shell里CTRL-C停止trace，然后执行sudo trace-cmd report命令, 可以看到如下输出:

    helloworld-1017966 [000] 2240248.899495: funcgraph_entry:                   |  __x64_sys_execve() {
    helloworld-1017966 [000] 2240248.899496: funcgraph_entry:                   |    getname() {
    helloworld-1017966 [000] 2240248.899497: funcgraph_entry:        1.637 us   |      getname_flags();
    helloworld-1017966 [000] 2240248.899498: funcgraph_exit:         2.037 us   |    }
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:                   |    __do_execve_file.isra.0() {
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:        0.220 us   |      unshare_files();
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:        0.610 us   |      kmem_cache_alloc_trace();
    helloworld-1017966 [000] 2240248.899500: funcgraph_entry:        0.203 us   |      mutex_lock_interruptible();
    helloworld-1017966 [000] 2240248.899500: funcgraph_entry:        2.570 us   |      prepare_exec_creds();
    helloworld-1017966 [000] 2240248.899503: funcgraph_entry:        0.193 us   |      _raw_spin_lock();
    helloworld-1017966 [000] 2240248.899503: funcgraph_entry:        8.002 us   |      do_open_execat();
    helloworld-1017966 [000] 2240248.899511: funcgraph_entry:        1.032 us   |      sched_exec();
    helloworld-1017966 [000] 2240248.899512: funcgraph_entry:        3.560 us   |      mm_alloc();
    helloworld-1017966 [000] 2240248.899516: funcgraph_entry:        0.087 us   |      _raw_spin_lock();
    helloworld-1017966 [000] 2240248.899516: funcgraph_entry:        1.185 us   |      vm_area_alloc();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.136 us   |      down_write_killable();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.088 us   |      vm_get_page_prot();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.741 us   |      insert_vm_struct();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        0.083 us   |      up_write();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        0.160 us   |      count.isra.0.constprop.0();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        1.507 us   |      count.isra.0.constprop.0();
    helloworld-1017966 [000] 2240248.899521: funcgraph_entry:      + 13.814 us  |      prepare_binprm();
    helloworld-1017966 [000] 2240248.899535: funcgraph_entry:      + 10.053 us  |      copy_strings_kernel();
    helloworld-1017966 [000] 2240248.899545: funcgraph_entry:        9.617 us   |      copy_strings.isra.0();
    helloworld-1017966 [000] 2240248.899555: funcgraph_entry:        0.869 us   |      copy_strings.isra.0();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:        0.255 us   |      task_active_pid_ns();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:        0.180 us   |      __task_pid_nr_ns();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:      ! 245.789 us |      search_binary_handler();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.209 us   |      proc_exec_connector();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.175 us   |      acct_update_integrals();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.086 us   |      task_numa_free();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.326 us   |      free_bprm();
    helloworld-1017966 [000] 2240248.899804: funcgraph_entry:        0.086 us   |      kfree();
    helloworld-1017966 [000] 2240248.899804: funcgraph_entry:        0.364 us   |      putname();
    helloworld-1017966 [000] 2240248.899804: funcgraph_exit:       ! 305.746 us |    }
    helloworld-1017966 [000] 2240248.899804: funcgraph_exit:       ! 309.477 us |  }

这里我们可以看到execve系统调用的完整调用链以及消耗时间(调大或省略max-graph-depth参数可以看到更为详细的内容)。

===== 7. 其它工具
此外，还可以借助其它的工具来进行分析
例如在helloworld.c中加入getchar(), 可以通过cat /proc/$PID/等一系列命令查看运行信息，例如:

    cat /proc/$PID/status
    cat /proc/$PID/maps
    cat /proc/$PID/statm
    cat /proc/$PID/fd
    cat /proc/$PID/fdinfo

其它工具还有ida: https://hex-rays.com/ida-pro/  pwndbg: https://github.com/pwndbg/pwndbg 等。

===== 8. 全过程概要
- shell创建新进程
    
    shell通过fork系统调用创建新进程
    fork核心函数是copy_process. copy_process创建并复制进程的代码段和数据段以及环境。
    copy_process
        p = dup_task_struct
        设置p的一些其它字段(p为task_struct* 类型)
        sched_fork(clone_flags, p);/* Perform scheduler related setup. Assign this task to a CPU. */
        copy_semundo
        copy_files
        copy_fs
        copy_sighand
        copy_signal
        copy_mm
        copy_namespaces
        copy_io
    参考: https://elixir.bootlin.com/linux/latest/source/kernel/fork.c

- 新进程加载helloworld程序

    新进程通过execve系统调用加载程序
        execve系统调用search_binary_handler函数
            search_binary_handler会启动load_elf_binary
                load_elf_binary
                    获取program header
                    如果是动态链接库则利用interp section确定loader路径
                    将program header记录的地址信息映射到内存中
                    将sys_execve的返回地址改为dynamic loader的entry point


- 执行dynamic loader的_start
    参见<<3. objdump, objdump:_start>>
    从而进入到main函数

- printf屏幕显示hellworld

    printf屏幕显示hellworld可以分为两步:
    第一步，printf调用write fd 1，这一块涉及write系统调用的实现
    第二步，屏幕显示, 这一块涉及console的实现

    我们先简单地介绍以下显示机制:
    如果简单地概括显示机制，那就是往一段内存里写入数据或者指令。
    通常我们这里称这段内存为VRAM。这段VRAM可能是系统内存(主内存)，也可能是显卡的显存。
    如何往这段VRAM里写入数据或者指令呢？
        ▪ 一种方式是CPU(用MMIO即Memory Mapped IO把VRAM map到CPU寻址空间，然后去读写)
        ▪ 一种方式是DMA控制器
    最终，视频控制器会按照某个频率读取VRAM的数据，经过可能的数模转换传递给显示器显示。
    
    linux console最早通过textmode机制来实现, 现代linux则基于framebuffer机制。
    https://elixir.bootlin.com/linux/latest/source/drivers/tty/vt/vt.c
        con_write(）
            con_con_write()

    早期linux内核console机制相对比较简单：
    https://elixir.bootlin.com/linux/0.12/source/kernel/chr_drv/console.c
    https://elixir.bootlin.com/linux/0.12/source/kernel/chr_drv/

==== 实现最简操作系统: 打印helloworld
如果我们实现一个最简单的操作系统: 进入这个操作系统，只做一件事，就是屏幕输出helloworld，那么需要哪些步骤呢？

简单来说，我们可以分为两步，第一步是引导启动进入操作系统，第二步是屏幕输出字符串。

第一步，引导进入操作系统，可以制作MBR(Master Boot Record)镜像，或利用GRUB, 然后由bochs,qume等虚拟机启动BIOS引导。(用更现代的UEFI更简单: https://blog.acdzh.com/tec/2019-12/uefi_tutorial_4-three_ways_helloworld/, 但如果为了说明原理，还是基于传统的引导方式比较好)

BIOS UEFI MBR GPT GRUB等概念参考这里: 
https://segmentfault.com/a/1190000020850901
https://www.daimajiaoliu.com/daima/8c76d06e9d4e805

第二步，屏幕输出helloworld，可以使用BIOS实模式下的0x10中断13号子功能，也可以通过VGA text mode来控制屏幕显示。

实战:
环境准备
代码
构建运行

参考: https://www.youtube.com/watch?v=1rnA6wpF0o4
参考: http://www.ruanyifeng.com/blog/2013/02/booting.html
参考: https://en.wikipedia.org/wiki/VGA_text_mode
参考: https://os.phil-opp.com/vga-text-mode/
参考: https://www.youtube.com/watch?v=mpPbKEeWIHU&list=PLxN4E629pPnJxCQCLy7E0SQY_zuumOVyZ&index=1
参考: https://kviccn.github.io/posts/2020/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82-0x03-%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%8C%87%E4%BB%A4/

=== linux内核组成

==== 中断 异常 系统调用
某种意义上讲，中断，异常，系统调用都是对内核的一种请求，是内核的输入。正是如此，在处理上它们有一定的相似性。
系统调用一定来自用户进程，必然涉及用户态到内核态的转换。X86上早期的系统调用是通过中断来实现的。
中断和异常则不一定，它们有可能来自内核态，典型的中断如时钟中断，键盘鼠标中断，典型的异常如缺页异常。

==== 进程
运行中的程序成为进程。进程拥有独立的地址空间。
通常来说，进程的数目会大于CPU的数目，而真正运行的进程数目不会超过CPU的数目，系统需要在较短的时间内挑选并切换不同的进程，以实现并行。
这个挑选的过程就是调度，要综合考虑公平与效率，优先级，实时性，以及多处理器上的均衡性等要素。
选好进程后，下一步就是切换，在切换进程之前，需要保存进程的状态，在下次重新激活进程的时候，需要到恢复之前的状态。
进程的管理包含主要包含创建，销毁，内核进程与用户进程在一些处理上也有所不同。
进程的通信机制主要包括共享内存，消息队列，信号量，信号，管道，套接字等。进程的同步机制也多种多样，原子操作，不断改进的自旋锁，信号量，顺序锁，RCU，内存屏障，读写锁，互斥量，Per-CPU变量等。

==== 内存

==== 文件

==== 网络

==== 其它系统

==== 数据结构

=== 注意事项
NOTE: 没有特别说明的情况下, 本文一般尽最大限度地采用内核的最新版本, 同时也会尽可能描绘历史演进的脉络，部分章节也简单描述了一下0.12版本(18935行代码，麻雀虽小五脏俱全)。在涉及体系结构的时候, 通常以x86-64或ARM64为主(x64 = amd64 = x86_64 = Intel64 != IA-64, ARM64 = AArch64)。
