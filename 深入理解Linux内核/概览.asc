:toc:
:toclevels: 5
:hardbreaks-option:

== 概览

=== 为什么要学习linux内核
- 吃饭的家伙

    linux内核可以分为驱动与内核两个大的方向。

    驱动工程师岗位：
    一般分布在嵌入式设备、芯片原厂等公司：
    IP厂商、咨询公司：ARM、IP厂商、开源组织、Linaro
    芯片原厂：TI、NXP、英飞凌、高通、FreeScale
    国内芯片原厂：海思、联发科、瑞芯微、全志、君正、龙芯
    AI芯片、RISC-V系：平头哥、芯来、嘉楠耘智等一大批新兴公司
    方案厂商：模组、方案提供商、智能硬件、开发板
    设备公司：智能音箱、无人机、智能冰箱、电视、投影仪、电视盒子、视频监控
    嵌入式外包公司：承接各大公司嵌入式外包业务

    驱动工程师的主要工作：
    IP开发：主要是芯片、IP厂商，主要做IP开发维护、授权，配套的BSP软件包开发
    驱动硬件：硬件不断升级，添加下的feature，需要软件驱动层支持
    Bug fix：基于某个CPU硬件平台，移植内核，修复各种bug，优化BSP软件包
    性能优化：针对某个CPU平台优化内核驱动，释放硬件最大性能
    系统集成：适配不同的CPU架构、硬件平台
    输出稳定、高性能、可适配的SDK、Turkey解决方案
    能基于新平台，定制平台，基于原厂的SDK进行移植、适配、开发、优化等工作

    内核工程师岗位：
    主要分布在互联网、安全领域、基础软件、芯片巨头公司：
    互联网大厂：服务器、云计算、分布式存储、网络、多媒体游戏
    安全厂商：安全加固、移动安全、物联网安全
    基础软件：RedHat、SUSE、UOS、VMware
    芯片公司：Intel、AMD、IBM、华为、高通、三星
    其他领域：超算、服务器、桌面PC
    
    内核工程师的主要工作：
    内核移植与架构：芯片原厂内核组
    业务模块的开发与优化
    各种Bug fix：云、容器、服务器、存储
    维护kernel稳定版本、各种patch的backporting
    内核安全加固
    开发新的功能：内核社区、Linux基金会、大厂
    内核参数调节、性能优化：运维、调试、服务器

    参考: https://www.zhaixue.cc/kernel/kernel-intro.html

- 更深入地理解计算机系统
    操作系统是管理计算机硬件与软件资源的计算机程序，而linux又是开源操作系统里的璀璨明珠。
    深入地理解linux, 能让我们更深入地理解计算机系统, 写出性能更好的程序，更快地debug一些疑难问题，同时很多设计上类似的问题，也都能在这里找到成熟的工业级的解决方案。

- just for fun
    linux操作系统是几千万的C代码加上少量汇编的庞然大物，管理着各式各样的硬件与软件，它强调稳定性，性能，并行/并发安全, 代码充满技巧，难于调试，毫无疑问，充满了乐趣与挑战性。

=== linux的历史

    ▪ Unix 1969, 1970年C语言, 重写
        ▪ Unix history: https://www.cnblogs.com/Solstice/p/unix_bwk.html
        ▪ Linux vs. Unix: https://www.zhihu.com/question/23710284
    ▪ 1983年GNU
    ▪ Minix 1987
    ▪ Linux 1991 Linus Torvalds
    ▪ 2020-01-01 统计: https://phoronix.com/misc/linux-eoy2019/index.html  27852148行(包括文档、配置、用户空间实用程序等)

=== linux与其它操作系统
- 宏内核 微内核 混合内核

    微内核: 把不是最核心的内核功能独立成服务进程(用户态), 然后这些服务进程使用IPC来通信, 也正因如此内核更微小
    微内核的优点: 扩展性好
    微内核的缺点: 性能较差
    例如, L4操作系统: https://en.wikipedia.org/wiki/L4_microkernel_family

    宏内核: 模块集中
    宏内核的优点: 性能好
    宏内核的缺点: 功能耦合, 扩展性差些
    linux是宏内核

    混合内核(hybrid kernel):
    类似微内核，但独立出来的功能依然放在内核，不通过IPC来调用
    特点: 高内聚低耦合 兼具宏内核微内核的特点
    Windows NT(from windows2000)和Darwin-XNU都算是混合内核
    
    参考: https://www.zhihu.com/question/20314255
    参考: https://github.com/apple/darwin-xnu

- 实时与非实时

    实时操作系统(RTOS)保证任务在特定时间内完成。
    硬实时操作系统必须使任务在确定的时间内完成。
    软实时操作系统能让绝大多数任务在确定时间内完成。

    Q: linux是实时操作系统吗?支持硬实时吗?为什么?PREEMPT_RT?
    A: linux是通用操作系统, 典型的实时操作系统如Vxworks。linux通过补丁PREEMPT_RT支持实时, 但只能算是软实时。
    参考: https://rt.wiki.kernel.org/index.php/Frequently_Asked_Questions

=== linux架构概览
- linux全景图
image:https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[]
.Image source: https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[window=read-later]

- 模块与层次

    对于全景图，我们横向地看，即是模块。纵向地看，即是层次。

    横向看全景图, linux分为以下几个大模块:
    system
    processing
    memory
    storage
    networking
    human interface
    如果把storage和human interfacelinux看成文件系统的话, 内核也可以看成系统, 进程, 内存, 文件, 网络5个模块。

    纵向看全景图, linux分为以下个层次:
    user space interfaces
    virtual
    bridges
    functiontal
    device control
    hardware interfaces
    实际上, 粗略地看, 也可以将linux内核看成系统接口层, 实现层, 硬件抽象层3个层次。

    实际上, 不是所有的操作系统具有这些类似的模块的：
    有些操作系统没有进程管理，例如MSDOS
    有些操作系统没有文件系统，例如一些"嵌入式"操作系统

    内核一般要做到arch与drivers的软件架构分离。
    
    从全景图上也可以看出, linux是一个宏内核结构, 模块间耦合性较强, 这也是linux内核代码分析的难点。

=== helloworld

下面，我们将从用户空间入手，结合内核，深入理解一下hellworld程序。

    附测试机器信息:
    $ uname -a
    Linux my-ubuntu 5.4.0-94-generic #106-Ubuntu SMP Thu Jan 6 23:58:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
    $ cat /etc/issue
    Ubuntu 20.04.3 LTS

==== 编译运行helloworld程序, 究竟发生了什么
[source, c]
.helloworld.c
----
#include <stdio.h>
int main(int argc, char* argv[]) {
        printf("helloworld");
        return 0;
}
----

gcc helloworld.c -o helloworld 编译生成可执行文件helloworld.

接下来，我们通过几个命令认识一下可执行程序以及执行的过程:

===== 1. gcc
gcc -v helloworld.c -o helloworld(执行-v选项可以看到编译链接子过程):

可以看到预处理, 编译, 汇编(as命令), 链接(collct2命令)等过程
预处理生成展开文件，编译生成汇编文件，汇编生成目标文件，链接生成可执行文件或库文件。
当然, 也可以分步骤看:

    预处理：gcc -v -E helloworld.c -o helloworld.i
    编译：gcc -v -S  helloworld.i -o helloworld.s
    汇编: gcc -v -c helloworld.s -o helloworld.o
    链接: gcc -v helloworld.o -o helloworld

这样, 就生成了可执行文件helloworld。

TIP: -v选项可以看到编译链接子过程, 如果带上-g选项, 生成的可执行文件还会附带上源码级的调试符号信息。

使用gcc -S -fno-asynchronous-unwind-tables helloworld.c -o helloworld.s命令，生成的helloworld.s文件主要内容如下:

[source, assembly]
----           
            .file   "helloworld.c"
            .text
            .section        .rodata
    .LC0:
            .string "helloworld"
            .text
            .globl  main
            .type   main, @function
    main:
            endbr64                    # endbr64这是Control-flow Enforcement Technology(CET)技术
            pushq   %rbp               # 上一个堆栈帧rbp入栈
            movq    %rsp, %rbp         # 设置当前堆栈帧rbp
            subq    $16, %rsp          # 两个函数局部变量的空间, 即argc, argv
            movl    %edi, -4(%rbp)     # 第一个局部变量即argc入栈
            movq    %rsi, -16(%rbp)    # 第二个局部变量即argv入栈
            leaq    .LC0(%rip), %rdi   # printf函数的第一个参数, 即helloworld字符串
            movl    $0, %eax           # printf函数的浮点数参数个数为0
            call    printf@PLT         # 调用printf  PLT(Procedure Linkage Table)
            movl    $0, %eax           # 返回值
            leave                      # 恢复到原堆栈帧
            ret                        # 返回
----

===== 2. readelf
执行readelf -a helloworld(或readelf -S helloworld):
    
    可以看到这么一段:
    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    ...
    [12] .init             PROGBITS         0000000000001000  00001000
        000000000000001b  0000000000000000  AX       0     0     4
    [13] .plt              PROGBITS         0000000000001020  00001020
        0000000000000020  0000000000000010  AX       0     0     16
    [14] .plt.got          PROGBITS         0000000000001040  00001040
        0000000000000010  0000000000000010  AX       0     0     16
    [15] .plt.sec          PROGBITS         0000000000001050  00001050
        0000000000000010  0000000000000010  AX       0     0     16
    [16] .text             PROGBITS         0000000000001060  00001060
        0000000000000185  0000000000000000  AX       0     0     16
    [17] .fini             PROGBITS         00000000000011e8  000011e8
        000000000000000d  0000000000000000  AX       0     0     4
    [18] .rodata           PROGBITS         0000000000002000  00002000
        000000000000000f  0000000000000000   A       0     0     4
    ...
    [25] .data             PROGBITS         0000000000004000  00003000
        0000000000000010  0000000000000000  WA       0     0     8
    [26] .bss              NOBITS           0000000000004010  00003010
        0000000000000008  0000000000000000  WA       0     0     1
    [27] .comment          PROGBITS         0000000000000000  00003010
        000000000000002a  0000000000000001  MS       0     0     1
    ...
       
    如上述结果, .text里的00001060实际上就是代码段的起始地址。
    该命令结果里的ELF Header能看到Entry point address: 0x1060这一行，也验证了这一点。(objdump -f helloworld命令也可以)
    同理, 还能看到rodata(只读常量数据), data段(初始化过的数据), bss段(未初始化数据), 且text段, rodata段, data段, bss段地址依次增大。

参考: https://en.wikipedia.org/wiki/Data_segment

===== 3. objdump
执行objdump -d helloworld:

[source, assembly]
----
Disassembly of section .text:

0000000000001060 <_start>:
    1060:	f3 0f 1e fa          	endbr64                         # endbr64这是Control-flow Enforcement Technology(CET)技术
    1064:	31 ed                	xor    %ebp,%ebp                # %ebp=0
    1066:	49 89 d1             	mov    %rdx,%r9                 # %r9=终止函数地址, __libc_start_main第6个参数(即rtld_fini)
    1069:	5e                   	pop    %rsi                     # %rsi=argc, __libc_start_main第2个参数
    106a:	48 89 e2             	mov    %rsp,%rdx                # %rdx=argv, __libc_start_main第3个参数
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp # 栈按16字节对齐
    1071:	50                   	push   %rax                     # 保存%rax, 仅仅为了栈对齐，是一个无效值
    1072:	54                   	push   %rsp                     # stack_end __libc_start_main第7个参数，保存在栈上
    1073:	4c 8d 05 76 01 00 00 	lea    0x176(%rip),%r8          # 11f0 <__libc_csu_fini>  __libc_start_main第5个参数
    107a:	48 8d 0d ff 00 00 00 	lea    0xff(%rip),%rcx          # 1180 <__libc_csu_init>  __libc_start_main第4个参数
    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi          # 1149 <main>             __libc_start_main第1个参数
    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)            # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    108e:	f4                   	hlt    
    108f:	90                   	nop

0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    ... 
----

首先需要说明的是, 在不考虑浮点参数的情况下, 对于X86-64下System V AMD64 ABI, 函数前六个参数通过RDI, RSI, RDX, RCX, R8, R9传递, 超过6个的参数则放在栈上。参考: https://en.wikipedia.org/wiki/X86_calling_conventions

可以看到_start的位置正是上面readelf命令里打印出来的.text段的首地址。

_start调用链:

    __libc_start_main
        main
            printf

__libc_start_main函数:
https://elixir.bootlin.com/glibc/glibc-2.25/source/csu/libc-start.c#L107

    STATIC int
    LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
            int argc, char **argv,
    #ifdef LIBC_START_MAIN_AUXVEC_ARG
            ElfW(auxv_t) *auxvec,
    #endif
            __typeof (main) init,
            void (*fini) (void),
            void (*rtld_fini) (void), void *stack_end)

ElfW(auxv_t) *auxvec这个参数究竟有没有呢？(如果有，就应该是8个参数)
在我实验的平台上，是没有的(参考上面的汇编代码), 验证过程请参考下一节的GDB.

1149这个main函数地址怎么来的呢? 看1081这一行: 0xc1 + 1081 + 该条指令本身7个字节 = 1149

参考: https://github.com/bminor/glibc/blob/master/sysdeps/x86_64/start.S 里面有注释
参考: https://xinqiu.gitbooks.io/linux-insides-cn/content/Misc/linux-misc-4.html
参考: https://wiki.osdev.org/Creating_a_C_Library
参考: https://lyyl.online/posts/2085258898.html
参考: http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

===== 4. gdb
使用gdb执行如下命令:

[source, shell]
----
orient@my-ubuntu:/data$ gdb -q helloworld
Reading symbols from helloworld...
(gdb) set backtrace past-entry
(gdb) set backtrace past-main
(gdb) break main
Breakpoint 1 at 0x1149: file helloworld.c, line 2.
(gdb) run
Starting program: /data/helloworld
Breakpoint 1, main (argc=0, argv=0x7fffffffe4f0) at helloworld.c:2
2	int main(int argc, char* argv[]) {
(gdb) bt
#0  main (argc=0, argv=0x7fffffffe4f0) at helloworld.c:2
#1  0x00007ffff7df70b3 in __libc_start_main (main=0x555555555149 <main>, argc=1, argv=0x7fffffffe4f8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffe4e8) at ../csu/libc-start.c:308
#2  0x000055555555508e in _start ()
----

可以看到__libc_start_main的参数依次是: main, argc, argv, init, fini, rtld_fini和stack_end共7个参数，没有auxvec这个参数。

===== 5. strace
执行strace ./helloworld(ltrace -S ./helloworld命令也有类似strace的效果), 显示结果如下:

[source, c]
----
//This is your program starting. Since it is dynamically linked, the first code to execute is from the dynamic loader.
execve("./helloworld", ["./helloworld"], 0x7ffe13915b40 /* 25 vars */) = 0

//The dynamic loader is allocating some heap space.
brk(NULL)                               = 0x55a0d53bd000
arch_prctl(0x3001 /* ARCH_??? */, 0x7fff1b4310e0) = -1 EINVAL (Invalid argument)
//0x3001: ARCH_CET_STATUS https://elixir.bootlin.com/glibc/latest/source/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h

//The dynamic loader checks whether there are dynamic libraries to preload. There aren not any.
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)

/*
The dynamic loader is looking for libc6, which is the standard library. It looks in several directories: first in the directories specified in the LD_LIBRARY_PATH, then in the directories listed in /etc/ld.so.conf. (See the manual for the full story.). In each directory, the loader checks several subdirectories first: it determines which hardware features are present (P6 instructions, SSE2), and looks for a version of the library binary which may use these extra features to run more efficiently; when it fails to find one that may use all the features, it looks for a more generic one. In the end, the library is found in a standard system directory, in a non-specialized version.
*/
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=26248, ...}) = 0
mmap(NULL, 26248, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0271290000
close(3)                                = 0


//The standard library is loaded, then its initialization code runs.
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360q\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f027128e000
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
mmap(NULL, 2036952, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f027109c000
mprotect(0x7f02710c1000, 1847296, PROT_NONE) = 0
mmap(0x7f02710c1000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7f02710c1000
mmap(0x7f0271239000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19d000) = 0x7f0271239000
mmap(0x7f0271284000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f0271284000
mmap(0x7f027128a000, 13528, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f027128a000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f027128f540) = 0
mprotect(0x7f0271284000, 12288, PROT_READ) = 0
mprotect(0x55a0d4e00000, 4096, PROT_READ) = 0
mprotect(0x7f02712c4000, 4096, PROT_READ) = 0
munmap(0x7f0271290000, 26248)           = 0

//This is the result of executing the printf call.
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}) = 0
brk(NULL)                               = 0x55a0d53bd000
brk(0x55a0d53de000)                     = 0x55a0d53de000

//This is your program exiting, which includes flushing the stdout buffer.
write(1, "helloworld", 10helloworld)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
----

参考: http://glennastory.net/?p=870
参考: https://unix.stackexchange.com/questions/160578/strace-hello-world-program
参考: https://github.com/lattera/glibc/blob/master/sysdeps/x86_64/dl-machine.h
参考: https://stackoverflow.com/questions/26876247/how-does-execve-call-dynamic-linker-loader-ld-linux-so-2
参考: https://grugq.github.io/docs/ul_exec.txt
参考: https://blog.csdn.net/welljrj/article/details/90228534
参考: https://blog.csdn.net/welljrj/article/details/90346108

===== 6. ftrace trace-cmd
更进一步地，上面的strace的结果里输出的execve等系统调用怎么执行的呢？
除了源代码，我们也可以借助ftrace/trace-cmd工具来查看，这里我们采用更为方便的trace-cmd工具(ftrace可以跟踪内核函数的执行，trace-cmd则是ftrace的前端)。

具体步骤如下:
(1) 打开shell，输入./hellworld(但先不要按enter执行)
(2) 再打开一个shell, 执行sudo trace-cmd record -p function_graph -g *sys_execve --max-graph-depth 3
(3) 第一个shell里按enter以执行./helloworld
(4) 第二个shell里CTRL-C停止trace，然后执行sudo trace-cmd report命令, 可以看到如下输出:

    helloworld-1017966 [000] 2240248.899495: funcgraph_entry:                   |  __x64_sys_execve() {
    helloworld-1017966 [000] 2240248.899496: funcgraph_entry:                   |    getname() {
    helloworld-1017966 [000] 2240248.899497: funcgraph_entry:        1.637 us   |      getname_flags();
    helloworld-1017966 [000] 2240248.899498: funcgraph_exit:         2.037 us   |    }
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:                   |    __do_execve_file.isra.0() {
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:        0.220 us   |      unshare_files();
    helloworld-1017966 [000] 2240248.899499: funcgraph_entry:        0.610 us   |      kmem_cache_alloc_trace();
    helloworld-1017966 [000] 2240248.899500: funcgraph_entry:        0.203 us   |      mutex_lock_interruptible();
    helloworld-1017966 [000] 2240248.899500: funcgraph_entry:        2.570 us   |      prepare_exec_creds();
    helloworld-1017966 [000] 2240248.899503: funcgraph_entry:        0.193 us   |      _raw_spin_lock();
    helloworld-1017966 [000] 2240248.899503: funcgraph_entry:        8.002 us   |      do_open_execat();
    helloworld-1017966 [000] 2240248.899511: funcgraph_entry:        1.032 us   |      sched_exec();
    helloworld-1017966 [000] 2240248.899512: funcgraph_entry:        3.560 us   |      mm_alloc();
    helloworld-1017966 [000] 2240248.899516: funcgraph_entry:        0.087 us   |      _raw_spin_lock();
    helloworld-1017966 [000] 2240248.899516: funcgraph_entry:        1.185 us   |      vm_area_alloc();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.136 us   |      down_write_killable();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.088 us   |      vm_get_page_prot();
    helloworld-1017966 [000] 2240248.899518: funcgraph_entry:        0.741 us   |      insert_vm_struct();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        0.083 us   |      up_write();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        0.160 us   |      count.isra.0.constprop.0();
    helloworld-1017966 [000] 2240248.899519: funcgraph_entry:        1.507 us   |      count.isra.0.constprop.0();
    helloworld-1017966 [000] 2240248.899521: funcgraph_entry:      + 13.814 us  |      prepare_binprm();
    helloworld-1017966 [000] 2240248.899535: funcgraph_entry:      + 10.053 us  |      copy_strings_kernel();
    helloworld-1017966 [000] 2240248.899545: funcgraph_entry:        9.617 us   |      copy_strings.isra.0();
    helloworld-1017966 [000] 2240248.899555: funcgraph_entry:        0.869 us   |      copy_strings.isra.0();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:        0.255 us   |      task_active_pid_ns();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:        0.180 us   |      __task_pid_nr_ns();
    helloworld-1017966 [000] 2240248.899556: funcgraph_entry:      ! 245.789 us |      search_binary_handler();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.209 us   |      proc_exec_connector();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.175 us   |      acct_update_integrals();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.086 us   |      task_numa_free();
    helloworld-1017966 [000] 2240248.899803: funcgraph_entry:        0.326 us   |      free_bprm();
    helloworld-1017966 [000] 2240248.899804: funcgraph_entry:        0.086 us   |      kfree();
    helloworld-1017966 [000] 2240248.899804: funcgraph_entry:        0.364 us   |      putname();
    helloworld-1017966 [000] 2240248.899804: funcgraph_exit:       ! 305.746 us |    }
    helloworld-1017966 [000] 2240248.899804: funcgraph_exit:       ! 309.477 us |  }

这里我们可以看到execve系统调用的完整调用链以及消耗时间(调大或省略max-graph-depth参数可以看到更为详细的内容)。

===== 7. 其它工具
此外，还可以借助其它的工具来进行分析
例如ida: https://hex-rays.com/ida-pro/
例如pwndbg: https://github.com/pwndbg/pwndbg

===== 8. 全过程分析
- shell创建新进程
    
    shell通过fork系统调用创建新进程

- 新进程加载helloworld程序

    新进程通过execve系统调用加载程序
        execve系统调用search_binary_handler函数
            search_binary_handler会启动load_elf_binary
                load_elf_binary
                    获取program header
                    如果是动态链接库则利用interp section确定loader路径
                    将program header记录的地址信息映射到内存中
                    将sys_execve的返回地址改为dynamic loader的entry point


- 执行dynamic loader的_start
参见<<3. objdump, objdump:_start>>
从而进入到main函数

- printf屏幕显示hellworld
    参考: https://www.zhihu.com/question/20722310
    参考: https://www.zhihu.com/question/30635966
    参考: https://www.zhihu.com/question/36397999

==== 实现最简操作系统: 打印helloworld

=== linux内核组成

==== 进程

==== 地址空间与特权级别
- 内核态与用户态

    特权级
    x86 CPU hardware actually provides four protection rings: 0, 1, 2, and 3. 
    Only rings 0 (Kernel) and 3 (User) are typically used.
    Q: 内核态是进程的一种特殊状态吗?
    A: 内核态既不是一个特殊的进程，也不是进程的一种特殊状态。内核态用户态指的是CPU在执行指令时所位于的特权层级。
    Q: 哪些操作导致内核态与用户态的切换
    A: 系统调用, 中断, 异常

==== 虚拟内存

==== 页与页表

==== 物理内存

==== 文件系统

==== 中断与异常

==== 设备与设备驱动程序

==== 网络

==== 计时

==== 系统调用

==== 数据结构

=== 注意事项
NOTE: 没有特别说明的情况下, 本文一般采用内核的最新版本

NOTE: 在涉及体系结构的时候, 通常以x86-64或ARM64为主(x64 = amd64 = x86_64 = Intel64 != IA-64, ARM64 = AArch64)
