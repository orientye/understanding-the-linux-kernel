:toc:
:toclevels: 5
:hardbreaks-option:

== 概览

=== 为什么要学习linux内核
- 工作需要
- 更深入地理解计算机系统
- 领会软件设计的一些思想
- 学习不停迭代, 永无止境的精神

=== linux的历史

    ▪ Unix 1969, 1970年C语言, 重写
        ▪ vs. Unix: https://www.zhihu.com/question/23710284
        ▪ Unix history: https://www.cnblogs.com/Solstice/p/unix_bwk.html
    ▪ 1983年GNU
    ▪ Minix 1987
    ▪ Linux 1991 Linus Torvalds
    ▪ 2020-01-01 统计: https://phoronix.com/misc/linux-eoy2019/index.html  27852148行(包括文档、配置、用户空间实用程序等)
    ▪ https://github.com/torvalds/linux/


=== linux与其它操作系统
- 宏内核 微内核 混合内核

    微内核: 把不是最核心的内核功能独立成服务进程(用户态), 然后这些服务进程使用IPC来通信, 也正因如此内核更微小
    微内核的优点: 扩展性好
    微内核的缺点: 性能较差
    例如, L4操作系统: https://en.wikipedia.org/wiki/L4_microkernel_family

    宏内核: 模块集中
    宏内核的优点: 性能好
    宏内核的缺点: 功能耦合, 扩展性差些
    linux是宏内核

    混合内核(hybrid kernel):
    类似微内核，但独立出来的功能依然放在内核，不通过IPC来调用
    特点: 高内聚低耦合 兼具宏内核微内核的特点
    Windows NT(from windows2000)和Darwin-XNU都算是混合内核
    
    参考: https://www.zhihu.com/question/20314255
    参考: https://github.com/apple/darwin-xnu

- 实时与非实时

    实时操作系统(RTOS)保证任务在特定时间内完成。
    硬实时操作系统必须使任务在确定的时间内完成。
    软实时操作系统能让绝大多数任务在确定时间内完成。

    Q: linux是实时操作系统吗?支持硬实时吗?为什么?PREEMPT_RT?
    A: linux是通用操作系统, 典型的实时操作系统如Vxworks。linux通过补丁PREEMPT_RT支持实时, 但只能算是软实时。
    参考: https://rt.wiki.kernel.org/index.php/Frequently_Asked_Questions

- 内核态与用户态

    特权级
    x86 CPU hardware actually provides four protection rings: 0, 1, 2, and 3. 
    Only rings 0 (Kernel) and 3 (User) are typically used.
    Q: 内核态是进程的一种特殊状态吗?
    A: 内核态既不是一个特殊的进程，也不是进程的一种特殊状态。内核态用户态指的是CPU在执行指令时所位于的特权层级。
    Q: 哪些操作导致内核态与用户态的切换
    A: 系统调用, 中断, 异常

=== linux架构概览
- linux全景图
image:https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[]
.Image source: https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png[window=read-later]

- 模块与层次

    对于全景图，我们横向地看，即是模块。纵向地看，即是层次。

    横向看全景图, linux分为以下几个大模块:
    system
    processing
    memory
    storage
    networking
    human interface
    如果把storage和human interfacelinux看成文件系统的话, 内核也可以看成系统, 进程, 内存, 文件, 网络5个模块。

    纵向看全景图, linux分为以下个层次:
    user space interfaces
    virtual
    bridges
    functiontal
    device control
    hardware interfaces
    实际上, 粗略地看, 也可以将linux内核看成系统接口层, 实现层, 硬件抽象层3个层次。

    实际上, 不是所有的操作系统具有这些类似的模块的。
    Q: 有哪些操作系统没有进程管理? 
    A: 例如MSDOS
    Q: 有哪些操作系统没有文件系统? 
    A: 例如一些"嵌入式"操作系统

    内核一般要做到arch与drivers的软件架构分离。
    
    从全景图上也可以看出, linux是一个宏内核结构, 模块间耦合性较强, 这也是linux内核代码分析的难点。

=== helloworld

==== 编译运行helloworld程序, 究竟发生了什么
[source, c]
.helloworld.c
----
#include <stdio.h>
int main() {
        printf("helloworld");
        return 0;
}
----

gcc helloworld.c -o helloworld 编译生成可执行文件helloworld.

接下来，我们通过几个命令认识一下可执行程序以及执行的过程:
    
    附测试机器信息:
    $ uname -a
    Linux my-ubuntu 5.4.0-94-generic #106-Ubuntu SMP Thu Jan 6 23:58:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
    $ cat /etc/issue
    Ubuntu 20.04.3 LTS

===== 1. gcc
gcc -v helloworld.c -o helloworld(执行-v选项可以看到编译链接子过程):

可以看到预处理, 编译, 汇编(as命令), 链接(collct2命令)等过程
当然, 也可以分步骤看:

    预处理：gcc -v -E helloworld.c -o helloworld.i
    编译：gcc -v -S  helloworld.i -o helloworld.s
    汇编: gcc -v -c helloworld.s -o helloworld.o
    链接: gcc -v helloworld.o -o helloworld

这样, 就生成了可执行文件helloworld。

TIP: -v选项可以看到编译链接子过程, 如果带上-g选项, 生成的可执行文件还会附带上源码级的调试符号信息。

===== 2. readelf
执行readelf -a helloworld(或readelf -S helloworld):
    
    可以看到这么一段:
    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    [ 1] .interp           PROGBITS         0000000000000318  00000318
        000000000000001c  0000000000000000   A       0     0     1
    [ 2] .note.gnu.propert NOTE             0000000000000338  00000338
        0000000000000020  0000000000000000   A       0     0     8
    [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358
        0000000000000024  0000000000000000   A       0     0     4
    [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c
        0000000000000020  0000000000000000   A       0     0     4
    [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0
        0000000000000024  0000000000000000   A       6     0     8
    [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8
        00000000000000a8  0000000000000018   A       7     1     8
    [ 7] .dynstr           STRTAB           0000000000000470  00000470
        0000000000000084  0000000000000000   A       0     0     1
    [ 8] .gnu.version      VERSYM           00000000000004f4  000004f4
        000000000000000e  0000000000000002   A       6     0     2
    [ 9] .gnu.version_r    VERNEED          0000000000000508  00000508
        0000000000000020  0000000000000000   A       7     1     8
    [10] .rela.dyn         RELA             0000000000000528  00000528
        00000000000000c0  0000000000000018   A       6     0     8
    [11] .rela.plt         RELA             00000000000005e8  000005e8
        0000000000000018  0000000000000018  AI       6    24     8
    [12] .init             PROGBITS         0000000000001000  00001000
        000000000000001b  0000000000000000  AX       0     0     4
    [13] .plt              PROGBITS         0000000000001020  00001020
        0000000000000020  0000000000000010  AX       0     0     16
    [14] .plt.got          PROGBITS         0000000000001040  00001040
        0000000000000010  0000000000000010  AX       0     0     16
    [15] .plt.sec          PROGBITS         0000000000001050  00001050
        0000000000000010  0000000000000010  AX       0     0     16
    [16] .text             PROGBITS         0000000000001060  00001060
        0000000000000185  0000000000000000  AX       0     0     16
    [17] .fini             PROGBITS         00000000000011e8  000011e8
        000000000000000d  0000000000000000  AX       0     0     4
    [18] .rodata           PROGBITS         0000000000002000  00002000
        000000000000000f  0000000000000000   A       0     0     4
    [19] .eh_frame_hdr     PROGBITS         0000000000002010  00002010
        0000000000000044  0000000000000000   A       0     0     4
    [20] .eh_frame         PROGBITS         0000000000002058  00002058
        0000000000000108  0000000000000000   A       0     0     8
    [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8
        0000000000000008  0000000000000008  WA       0     0     8
    [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0
        0000000000000008  0000000000000008  WA       0     0     8
    [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8
        00000000000001f0  0000000000000010  WA       7     0     8
    [24] .got              PROGBITS         0000000000003fb8  00002fb8
        0000000000000048  0000000000000008  WA       0     0     8
    [25] .data             PROGBITS         0000000000004000  00003000
        0000000000000010  0000000000000000  WA       0     0     8
    [26] .bss              NOBITS           0000000000004010  00003010
        0000000000000008  0000000000000000  WA       0     0     1
    [27] .comment          PROGBITS         0000000000000000  00003010
        000000000000002a  0000000000000001  MS       0     0     1
    [28] .symtab           SYMTAB           0000000000000000  00003040
        0000000000000618  0000000000000018          29    46     8
    [29] .strtab           STRTAB           0000000000000000  00003658
        0000000000000205  0000000000000000           0     0     1
    [30] .shstrtab         STRTAB           0000000000000000  0000385d
        000000000000011a  0000000000000000           0     0     1
       
    如上述结果, .text里的00001060实际上就是代码段的起始地址。
    同理, 还能看到data段(初始化过的数据), bss段(未初始化数据), 且text段, data段, bss段地址依次增大。

参考: https://en.wikipedia.org/wiki/Data_segment

===== 3. objdump
执行objdump -d helloworld

[source, assembly]
----
Disassembly of section .text:

0000000000001060 <_start>:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	31 ed                	xor    %ebp,%ebp
    1066:	49 89 d1             	mov    %rdx,%r9
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	4c 8d 05 66 01 00 00 	lea    0x166(%rip),%r8        # 11e0 <__libc_csu_fini>
    107a:	48 8d 0d ef 00 00 00 	lea    0xef(%rip),%rcx        # 1170 <__libc_csu_init>
    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi        # 1149 <main>
    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)        # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    108e:	f4                   	hlt    
    108f:	90                   	nop

0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	48 8d 3d ac 0e 00 00 	lea    0xeac(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    1158:	b8 00 00 00 00       	mov    $0x0,%eax
    115d:	e8 ee fe ff ff       	callq  1050 <printf@plt>
    1162:	b8 00 00 00 00       	mov    $0x0,%eax
    1167:	5d                   	pop    %rbp
    1168:	c3                   	retq   
    1169:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
----

可以看到_start的位置正是上面readelf命令里打印出来的.text段的首地址。
然后在_start的函数里面调用了main函数, 而main函数则调用了printf函数。
__libc_start_main函数: 

    extern void __libc_start_main (int (*main) (int, char **, char **),
			       int argc, char **argv, ElfW(auxv_t) *auxv,
			       int (*init) (int, char **, char **),
			       void (*fini) (void),
			       void (*rtld_fini) (void),
			       void *stack_end);

1149这个main函数地址怎么来的呢? 看1081这一行 : 0xc1 + 1081 + 该条指令本身7个字节 = 1149

_start函数具体分析:
首先需要说明的是, 在不考虑浮点参数的情况下, 对于X86-64下System V AMD64 ABI[25], 函数前六个参数通过RDI, RSI, RDX, RCX, R8, R9传递, 参考https://en.wikipedia.org/wiki/X86_calling_conventions
    
    1060:	f3 0f 1e fa          	endbr64                       # endbr64这是Control-flow Enforcement Technology(CET)技术
    1064:	31 ed                	xor    %ebp,%ebp              # %ebp=0
    1066:	49 89 d1             	mov    %rdx,%r9               # %r9=%rdx
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	4c 8d 05 66 01 00 00 	lea    0x166(%rip),%r8        # 11e0 <__libc_csu_fini>
    107a:	48 8d 0d ef 00 00 00 	lea    0xef(%rip),%rcx        # 1170 <__libc_csu_init>
    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi        # 1149 <main>
    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)          # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    108e:	f4                   	hlt    
    108f:	90                   	nop


main函数具体分析:

    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	48 8d 3d ac 0e 00 00 	lea    0xeac(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    1158:	b8 00 00 00 00       	mov    $0x0,%eax
    115d:	e8 ee fe ff ff       	callq  1050 <printf@plt>
    1162:	b8 00 00 00 00       	mov    $0x0,%eax
    1167:	5d                   	pop    %rbp
    1168:	c3                   	retq   
    1169:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

===== 4. strace
执行strace ./helloworld

1.shell进程调用系统调用execve()
2.execve陷入到内核里执行sys_execve()，把用户态的eip设置为_start()
3.当系统调用执行完毕，helloworld进程开始运行时，就从_start()开始执行
4.helloworld进程执行main()

===== 5. 全过程分析
- shell接收命令
- shell创建新进程
- 新进程加载helloworld程序
- 新进程执行, 屏幕显示hellworld 

==== 实现最简操作系统: 打印helloworld

=== 注意事项
NOTE: 没有特别说明的情况下, 本文一般采用内核的最新版本