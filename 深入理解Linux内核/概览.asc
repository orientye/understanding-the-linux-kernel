:toc:
:toclevels: 5
:hardbreaks-option:

== 概览

=== 为什么要学习linux内核
- 工作需要
- 更深入地理解计算机系统
- 领会软件设计的一些思想
- 学习不停迭代, 永无止境的精神

=== linux的历史

    ▪ Unix 1969, 1970年C语言, 重写
        ▪ vs. Unix: https://www.zhihu.com/question/23710284
        ▪ Unix history: https://www.cnblogs.com/Solstice/p/unix_bwk.html
    ▪ 1983年GNU
    ▪ Minix 1987
    ▪ Linux 1991 Linus Torvalds
    ▪ 2020-01-01 统计: https://phoronix.com/misc/linux-eoy2019/index.html  27852148行(包括文档、配置、用户空间实用程序等)
    ▪ https://github.com/torvalds/linux/


=== linux与其它操作系统
- 宏内核 微内核 混合内核

    微内核: 把不是最核心的内核功能独立成服务进程(用户态), 然后这些服务进程使用IPC来通信, 也正因如此内核更微小
    微内核的优点: 扩展性好
    微内核的缺点: 性能较差
    例如, L4操作系统: https://en.wikipedia.org/wiki/L4_microkernel_family

    宏内核: 模块集中
    宏内核的优点: 性能好
    宏内核的缺点: 功能耦合, 扩展性差些
    linux是宏内核

    混合内核(hybrid kernel):
    类似微内核，但独立出来的功能依然放在内核，不通过IPC来调用
    特点: 高内聚低耦合 兼具宏内核微内核的特点
    Windows NT(from windows2000)和Darwin-XNU都算是混合内核
    
    参考: https://www.zhihu.com/question/20314255
    参考: https://github.com/apple/darwin-xnu

- 实时与非实时

    实时操作系统(RTOS)保证任务在特定时间内完成。
    硬实时操作系统必须使任务在确定的时间内完成。
    软实时操作系统能让绝大多数任务在确定时间内完成。

    Q: linux是实时操作系统吗?支持硬实时吗?为什么?PREEMPT_RT?
    A: linux是通用操作系统, 典型的实时操作系统如Vxworks。linux通过补丁PREEMPT_RT支持实时, 但只能算是软实时。
    参考: https://rt.wiki.kernel.org/index.php/Frequently_Asked_Questions

- 内核态与用户态

    特权级
    x86 CPU hardware actually provides four protection rings: 0, 1, 2, and 3. 
    Only rings 0 (Kernel) and 3 (User) are typically used.
    Q: 内核态是进程的一种特殊状态吗?
    A: 内核态既不是一个特殊的进程，也不是进程的一种特殊状态。内核态用户态指的是CPU在执行指令时所位于的特权层级。
    Q: 哪些操作导致内核态与用户态的切换
    A: 系统调用, 中断, 异常

=== linux架构概览
- linux全景图
https://en.wikipedia.org/wiki/Linux_kernel#/media/File:Linux_kernel_map.png

- 模块与层次

    对于全景图，我们横向地看，即是模块。纵向地看，即是层次。我这里简称"六横六纵"。

    横向来看, linux分为6大模块:
    human interface
    system
    processing
    memory
    storage
    networking

    纵向来看, linux分为6个层次:
    user space interfaces
    virtual
    bridges
    logical
    device control
    hardware interfaces

    Q: 有哪些操作系统没有进程管理? 
    A: 例如MSDOS

    Q: 有哪些操作系统没有文件系统? 
    A: 例如一些"嵌入式"操作系统

    内核一般要做到arch与drivers的软件架构分离

- 模块间的关系

=== helloworld

==== 运行helloworld程序, 究竟发生了什么
[source, c]
.hello.c
----
#include <stdio.h>
int main() {
        printf("helloworld");
        return 0;
}
----

gcc -o hello hello.c 编译生成可执行文件hello.

接下来，我们通过几个命令认识一下可执行程序以及执行的过程:
    
    附测试机器信息:
    $ uname -a
    Linux my-ubuntu 5.4.0-94-generic #106-Ubuntu SMP Thu Jan 6 23:58:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
    $ cat /etc/issue
    Ubuntu 20.04.3 LTS

===== objdump
执行objdump -d hello

===== readelf
执行readelf -S hello

===== strace
执行strace ./hello

===== 全过程分析

==== 实现最简操作系统: 打印helloworld

=== 注意事项
NOTE: 没有特别说明的情况下, 本文一般采用内核的最新版本