:toc:
:toclevels: 5
:hardbreaks-option:

== 系统调用

=== 概念
a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system on which it is executed.

▪ vs. 中断
系统调用是从用户态切换到核心态的同步机制，中断则是一种异步切换。
系统调用的整个过程中，会从用户态切换到内核态，然后又切换到用户态。中断则不一定，例如中断有可能全部在核心态中完成。
系统调用与中断在处理过程上，有较多相似之处，早期的系统调用通过中断来实现的。

▪ 有哪些系统调用?
https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
系统调用个数: __NR_syscalls: https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/unistd.h

▪ 命令

    apropos
    man
    例如: apropos write; man 2 write

=== 实现

==== 汇编指令
IA32早期使用汇编指令int $0x80来引发中断(kernel 2.5之前)，更为现代的处理器使用汇编指令syscall和sysret来快速进入和退出核心态，避免了中断的开销。
ARM64则是使用svc指令。

https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux

AMD SYSCALL/SYSRET:
"SYSCALL and SYSRET are low-latency system call and return instructions. These instructions assume the operating system implements a flat-memory model, which greatly simplifies calls to and returns from the operating system. This simplification comes from eliminating unneeded checks, and by loading pre-determined values into the CS and SS segment registers (both visible and hidden portions). As a result, SYSCALL and SYSRET can take fewer than one-fourth the number of internal clock cycles to complete than the legacy CALL and RET instructions. SYSCALL and SYSRET are particularly well-suited for use in 64-bit mode, which requires implementation of a paged, flat-memory model." -- AMD System programming

In legacy mode AMD CPUs support SYSENTER/SYSEXIT. However, in long mode only SYSCALL and SYSRET are supported.

INTEL SYSENTER/SYSEXIT:
"Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT.
The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to
operating system or executive procedures running at privilege level 0." -- Intel IA-32 (64) programming manual, volume 2B.

syscall/sysenter汇编指令作了什么呢？
https://wiki.osdev.org/SYSENTER
https://www.felixcloutier.com/x86/syscall

[source, c]
.https://elixir.bootlin.com/glibc/latest/source/sysdeps/unix/sysv/linux/x86_64/syscall.S
----
/* Please consult the file sysdeps/unix/sysv/linux/x86-64/sysdep.h for
   more information about the value -4095 used below.  */

/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
   We need to do some arg shifting, the syscall_number will be in
   rax.  */


	.text
ENTRY (syscall)
	movq %rdi, %rax		/* Syscall number -> rax.  */
	movq %rsi, %rdi		/* shift arg1 - arg5.  */
	movq %rdx, %rsi
	movq %rcx, %rdx
	movq %r8, %r10
	movq %r9, %r8
	movq 8(%rsp),%r9	/* arg6 is on the stack.  */
	syscall			/* Do the system call.  */
	cmpq $-4095, %rax	/* Check %rax for error.  */
	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
	ret			/* Return to caller.  */

PSEUDO_END (syscall)
----

==== 系统调用表
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_32.tbl

https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/syscall_wrapper.h


==== 进入和退出
entry_SYSCALL_64: https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S
entry_INT80_32: https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_32.S

- 返回值与错误码
    
    错误码语义:
    https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno-base.h
    https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno.h

- 切回用户态

    do_syscall_64(): https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
        syscall_exit_to_user_mode(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c
            __syscall_exit_to_user_mode_work()


void do_syscall_64(struct pt_regs *regs, int nr);
void do_int80_syscall_32(struct pt_regs *regs);
long do_fast_syscall_32(struct pt_regs *regs);
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/syscall.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
----
static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
{
	/*
	 * Convert negative numbers to very high and thus out of range
	 * numbers for comparisons.
	 */
	unsigned int unr = nr;

	if (likely(unr < NR_syscalls)) {
		unr = array_index_nospec(unr, NR_syscalls);
		regs->ax = sys_call_table[unr](regs);
		return true;
	}
	return false;
}
----

==== conventions
▪ x86-64 linux kernel Calling Conventions
1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments, no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.

参考: https://www.ucw.cz/~hubicka/papers/abi/node33.html

==== 访问用户空间
所有的系统调用在核心态执行

某些情况下, 内核必须访问应用程序的虚拟内存:
    
    系统调用需要超过6个不同的参数
        此时只能借助进程内存空间的C结构指针来传递给内核
    系统调用产生了大量数据，不能通过返回值机制传递给用户进程
        此时必须通过指定的内存区交换数据

__user宏: 属性标记，一些源代码检查工具例如sparse会用到
https://stackoverflow.com/questions/4521551/what-are-the-implications-of-the-linux-user-macro

copy_from_user(void *to, const void __user *from, unsigned long n)
copy_to_user(void __user *to, const void *from, unsigned long n)
https://elixir.bootlin.com/linux/latest/source/include/linux/uaccess.h

vs. memcpy
参考: http://www.wowotech.net/memory_management/454.html

get_user __get_user
put_user __put_user
strncpy_from_user clear_user等
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/uaccess.h

参考: https://developer.ibm.com/articles/l-kernel-memory-access/
参考: https://lwn.net/Kernel/Index/#copy__user

==== 系统调用与信号
系统调用的过程中，如果发生信号了呢？

要么返回EINTR错误，要么会自动重启该函数。

与SA_RESTART以及哪种系统调用有关:
[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/signal.c
----
static void
handle_signal(struct ksignal *ksig, struct pt_regs *regs)
{
	bool stepping, failed;
	struct fpu *fpu = &current->thread.fpu;

	if (v8086_mode(regs))
		save_v86_state((struct kernel_vm86_regs *) regs, VM86_SIGNAL);

	/* Are we from a system call? */
	if (syscall_get_nr(current, regs) != -1) {
		/* If so, check system call restarting.. */
		switch (syscall_get_error(current, regs)) {
		case -ERESTART_RESTARTBLOCK:
		case -ERESTARTNOHAND:
			regs->ax = -EINTR;
			break;

		case -ERESTARTSYS:
			if (!(ksig->ka.sa.sa_flags & SA_RESTART)) {
				regs->ax = -EINTR;
				break;
			}
			fallthrough;
		case -ERESTARTNOINTR:
			regs->ax = regs->orig_ax;
			regs->ip -= 2;
			break;
		}
	}

	/*
	 * If TF is set due to a debugger (TIF_FORCED_TF), clear TF now
	 * so that register information in the sigcontext is correct and
	 * then notify the tracer before entering the signal handler.
	 */
	stepping = test_thread_flag(TIF_SINGLESTEP);
	if (stepping)
		user_disable_single_step(current);

	failed = (setup_rt_frame(ksig, regs) < 0);
	if (!failed) {
		/*
		 * Clear the direction flag as per the ABI for function entry.
		 *
		 * Clear RF when entering the signal handler, because
		 * it might disable possible debug exception from the
		 * signal handler.
		 *
		 * Clear TF for the case when it wasn't set by debugger to
		 * avoid the recursive send_sigtrap() in SIGTRAP handler.
		 */
		regs->flags &= ~(X86_EFLAGS_DF|X86_EFLAGS_RF|X86_EFLAGS_TF);
		/*
		 * Ensure the signal handler starts with the new fpu state.
		 */
		fpu__clear_user_states(fpu);
	}
	signal_setup_done(failed, ksig, stepping);
}
----

参考: Interruption of system calls and library functions by signal handlers https://man7.org/linux/man-pages/man7/signal.7.html
参考: https://www.halolinux.us/kernel-reference/reexecution-of-system-calls.html

==== 系统调用与中断
进入系统调用后系统并不会自动关闭中断，因此系统调用的过程是可以中断的。

系统调用的过程中，如果发生中断了呢？
https://stackoverflow.com/questions/8049756/when-and-how-are-system-calls-interrupted
https://unix.stackexchange.com/questions/84273/can-system-calls-be-interrupted

==== 系统调用与线程
https://en.wikipedia.org/wiki/System_call#Processor_mode_and_context_switching
https://stackoverflow.com/questions/54878237/is-there-a-separate-kernel-level-thread-for-handling-system-calls-by-user-proces

系统调用可能被多个进程/线程同时调用，因此系统调用的实现里需要考虑竞态条件。
linux非线程安全函数: https://man7.org/linux/man-pages/man7/pthreads.7.html

==== vDSO与vsyscall
vsyscall(virtual system call) 2.5.53引入内核，它在用户空间映射一个包含一些变量及一些系统调用的实现的内存页，这些系统调用将在用户空间下执行，不需要触发trap机制进入内核。
vsyscall存在一些问题:
vsyscall映射到内存的固定位置处，有潜在的安全风险
vsyscall内存页不包含符号表等信息，程序出错时进行core dump比较麻烦

为了解决上述问题，设计了vDSO机制。

vDSO(virtual dynamic shared object)也是一种系统调用加速机制。
vDSO和vsyscall原理类似，都是通过映射到用户空间的代码和数据来模拟系统调用。
它通过以下手段规避vsyscall的缺陷:
vDSO依赖ASLR(地址空间布局随机化)技术，对vDSO的地址进行随机化
vDSO是一个ELF格式的动态库，拥有完整的符号表信息

不过一般vDSO实现的也就几个系统调用(x86 4个):
https://elixir.bootlin.com/linux/latest/source/arch/x86/um/vdso/vdso.lds.S
    clock_gettime;
    __vdso_clock_gettime;
    gettimeofday;
    __vdso_gettimeofday;
    getcpu;
    __vdso_getcpu;
    time;
    __vdso_time;

ldd /bin/ls
	linux-vdso.so.1 (0x00007ffe3c9a0000)
可以看到，linux-vdso.so.1，其映射的基地址每次都是不同的。

参考: https://lwn.net/Kernel/Index/#vDSO

==== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/sys_call.s
https://elixir.bootlin.com/linux/0.12/source/kernel/sys.c
以及分布在其它文件中的sys_函数

=== 实战
==== 追踪系统调用
strace工具(使用ptrace系统调用, 即sys_ptrace)

示例:

    strace -c ./testgettimeofday
    strace -ce mmap ./testgettimeofday   #统计某个系统调用
    strace -o result.txt ./testgettimeofday

==== 查看对应代码
系统调用的实现分布在不同的文件中。

Q: 如何查看系统调用的实现代码呢？
A: 下面以gettimeofday为例, 说明如何查看系统调用的实现代码:

方法1:

    打开https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
    搜索gettimeofday, 会看到kernel/time.c这样的所在文件注释，这说明其存在于kernel/time.c(实际上是kernel/time/time.c)。

方法2:

    打开https://elixir.bootlin.com/linux/latest/source
    搜索gettimeofday, 会看到很多结果, 找到最有可能出现的, 在kernel/time/time.c某行中出现, 
    跳转到该行, 显示SYSCALL_DEFINE2(gettimeofday,... 说明正是其实现。

方法3:

    搜索SYSCALL_DEFINE2(gettimeofday
    其中数字2表示参数个数，根据函数个数酌情修改, 也可以考虑正则表达式匹配。
    例如: find . -name '*.*' | xargs grep -rn 'SYSCALL_DEFINE2(gettimeofday'

方法4:

    搜索sys_brk
    这时候可能会通过注释看到所在文件，但不一定全面。
    例如brk系统调用, 搜索sys_brk, 会出现如下注释：
    /* mm/nommu.c, also with MMU */
    asmlinkage long sys_brk(unsigned long brk);
    可见nommu下的brk实现在mm/nommu.c文件里，但mmu下的实现则没有给出(实际上mmu下的实现在mm/mmap.c文件里)。

参考: https://unix.stackexchange.com/questions/797/how-can-i-find-the-implementations-of-linux-kernel-system-calls

==== 添加系统调用
参考: https://cloud.tencent.com/developer/article/1517844

=== 参考
https://en.wikipedia.org/wiki/System_call
https://cloud.tencent.com/developer/article/1492374
https://ty-chen.github.io/linux-kernel-system-call/
https://lwn.net/Kernel/Index/#Development_model-User-space_ABI