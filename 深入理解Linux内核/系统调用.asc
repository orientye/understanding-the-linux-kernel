:toc:
:toclevels: 5
:hardbreaks-option:

== 系统调用

=== 概念
a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system on which it is executed.

▪ vs. 中断
系统调用是从用户态切换到核心态的同步机制，中断则是一种异步切换。
系统调用的整个过程中，会从用户态切换到内核态，然后又切换到用户态。中断则不一定，例如中断有可能全部在核心态中完成。
早期的系统调用通过中断来实现的，在系统调用与中断在处理过程上，有较多相似之处。

▪ 有哪些系统调用?
https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
系统调用个数: __NR_syscalls: https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/unistd.h

▪ 命令

    apropos
    man
    例如: apropos printf; man 2 printf

=== 实现

==== 调用
IA32早期使用汇编指令int $0x80来引发中断(kernel 2.5之前)，更为现代的处理器使用汇编指令syscall和sysret来快速进入和退出核心态，避免了中断的开销。

https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux

AMD SYSCALL/SYSRET:
"SYSCALL and SYSRET are low-latency system call and return instructions. These instructions assume the operating system implements a flat-memory model, which greatly simplifies calls to and returns from the operating system. This simplification comes from eliminating unneeded checks, and by loading pre-determined values into the CS and SS segment registers (both visible and hidden portions). As a result, SYSCALL and SYSRET can take fewer than one-fourth the number of internal clock cycles to complete than the legacy CALL and RET instructions. SYSCALL and SYSRET are particularly well-suited for use in 64-bit mode, which requires implementation of a paged, flat-memory model." -- AMD System programming

In legacy mode AMD CPUs support SYSENTER/SYSEXIT. However, in long mode only SYSCALL and SYSRET are supported.

INTEL SYSENTER/SYSEXIT:
"Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT.
The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to
operating system or executive procedures running at privilege level 0." -- Intel IA-32 (64) programming manual, volume 2B.

syscall/sysenter汇编指令作了什么呢？
https://wiki.osdev.org/SYSENTER
https://www.felixcloutier.com/x86/syscall

系统调用表, 例如
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_32.tbl

https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/syscall_wrapper.h

entry_SYSCALL_64: https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S
entry_INT80_32: https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_32.S

void do_syscall_64(struct pt_regs *regs, int nr);
void do_int80_syscall_32(struct pt_regs *regs);
long do_fast_syscall_32(struct pt_regs *regs);
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/syscall.h
https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c

[source, c]
.https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
----
static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
{
	/*
	 * Convert negative numbers to very high and thus out of range
	 * numbers for comparisons.
	 */
	unsigned int unr = nr;

	if (likely(unr < NR_syscalls)) {
		unr = array_index_nospec(unr, NR_syscalls);
		regs->ax = sys_call_table[unr](regs);
		return true;
	}
	return false;
}
----

==== 处理程序函数的实现
每个函数名称前缀都是sys_
所有的处理程序函数最多接受6个参数
所有的系统调用在核心态执行

==== 访问用户空间
某些情况下, 内核必须访问应用程序的虚拟内存:
    
    系统调用需要超过6个不同的参数
        此时只能借助进程内存空间的C结构指针来传递给内核
    系统调用产生了大量数据，不能通过返回值机制传递给用户进程
        此时必须通过指定的内存区交换数据

__user宏: 属性标记，一些源代码检查工具例如sparse会用到
https://stackoverflow.com/questions/4521551/what-are-the-implications-of-the-linux-user-macro

copy_from_user(void *to, const void __user *from, unsigned long n)
copy_to_user(void __user *to, const void *from, unsigned long n)
https://elixir.bootlin.com/linux/latest/source/include/linux/uaccess.h

get_user __get_user
put_user __put_user
strncpy_from_user clear_user等
https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/uaccess.h

==== 系统调用与信号
系统调用的过程中，如果发生信号了呢？

与SA_RESTART以及哪种系统调用有关:
handle_signal(): https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/signal.c

参考: Interruption of system calls and library functions by signal handlers https://man7.org/linux/man-pages/man7/signal.7.html
参考: https://www.halolinux.us/kernel-reference/reexecution-of-system-calls.html

==== 系统调用与中断
进入系统调用后系统并不会自动关闭中断，因此系统调用的过程是可以中断的。

系统调用的过程中，如果发生中断了呢？
https://stackoverflow.com/questions/8049756/when-and-how-are-system-calls-interrupted
https://unix.stackexchange.com/questions/84273/can-system-calls-be-interrupted

==== 系统调用与线程
https://en.wikipedia.org/wiki/System_call#Processor_mode_and_context_switching
https://stackoverflow.com/questions/54878237/is-there-a-separate-kernel-level-thread-for-handling-system-calls-by-user-proces

由于系统调用可能被多个进程/线程同时调用，所以系统调用的实现里需要考虑竞态条件。

==== 返回
- 返回值与错误码
    
    错误码语义:
    https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno-base.h
    https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/errno.h

- 切回用户态

    do_syscall_64(): https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/common.c
        syscall_exit_to_user_mode(): https://elixir.bootlin.com/linux/latest/source/kernel/entry/common.c
            __syscall_exit_to_user_mode_work()

==== v0.12
https://elixir.bootlin.com/linux/0.12/source/kernel/sys_call.s
https://elixir.bootlin.com/linux/0.12/source/kernel/sys.c
以及分布在其它文件中的sys_函数

=== 实战
==== 追踪系统调用
strace工具(使用ptrace系统调用, 即sys_ptrace)

示例:

    strace -c ./testgettimeofday
    strace -ce mmap ./testgettimeofday   #统计某个系统调用
    strace -o result.txt ./testgettimeofday

==== 查看对应代码
https://unix.stackexchange.com/questions/797/how-can-i-find-the-implementations-of-linux-kernel-system-calls

Q: 如何查看系统调用的实现代码呢？
A: 系统调用的实现分布在不同的文件中。

下面以gettimeofday为例, 说明如何查看系统调用的实现代码:

方法1:

    打开https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h
    搜索gettimeofday, 会看到kernel/time.c这样的所在文件注释，这说明其存在于kernel/time.c(实际上是kernel/time/time.c)

方法2:

    打开https://elixir.bootlin.com/linux/latest/source
    搜索gettimeofday, 会看到很多结果, 找到最有可能出现的, 在kernel/time/time.c某行中出现, 
    跳转到该行, 显示SYSCALL_DEFINE2(gettimeofday,... 说明正是其实现。

方法3:

    搜索SYSCALL_DEFINE2(gettimeofday
    其中数字2表示参数个数，根据函数个数酌情修改, 也可以考虑正则表达式匹配。

方法4:

    搜索sys_brk
    这时候可能会通过注释看到所在文件，但不一定全面。
    例如brk系统调用, 搜索sys_brk, 会出现如下注释：
    /* mm/nommu.c, also with MMU */
    asmlinkage long sys_brk(unsigned long brk);
    可见nommu下的brk实现在mm/nommu.c文件里，但mmu下的实现则没有给出(实际上mmu下的实现在mm/mmap.c文件里)。

==== 添加系统调用
参考: https://cloud.tencent.com/developer/article/1517844

=== 参考
https://en.wikipedia.org/wiki/System_call
https://cloud.tencent.com/developer/article/1492374
https://ty-chen.github.io/linux-kernel-system-call/